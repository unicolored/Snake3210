/*! Snake3210 - v0.0.0 - 16-12-2014 [FR] */
//####dev/js/tmp/bower_concat.js
/**
 * @license AngularJS v1.3.7
 * (c) 2010-2014 Google, Inc. http://angularjs.org
 * License: MIT
 */
( function( window, angular, undefined ) {
    'use strict';
    /* jshint maxlen: false */
    /**
     * @ngdoc module
     * @name ngAnimate
     * @description
     *
     * The `ngAnimate` module provides support for JavaScript, CSS3 transition and CSS3 keyframe animation hooks within existing core and custom directives.
     *
     * <div doc-module-components="ngAnimate"></div>
     *
     * # Usage
     *
     * To see animations in action, all that is required is to define the appropriate CSS classes
     * or to register a JavaScript animation via the `myModule.animation()` function. The directives that support animation automatically are:
     * `ngRepeat`, `ngInclude`, `ngIf`, `ngSwitch`, `ngShow`, `ngHide`, `ngView` and `ngClass`. Custom directives can take advantage of animation
     * by using the `$animate` service.
     *
     * Below is a more detailed breakdown of the supported animation events provided by pre-existing ng directives:
     *
     * | Directive                                                                                                | Supported Animations                                                     |
     * |----------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------------|
     * | {@link ng.directive:ngRepeat#animations ngRepeat}                                                        | enter, leave and move                                                    |
     * | {@link ngRoute.directive:ngView#animations ngView}                                                       | enter and leave                                                          |
     * | {@link ng.directive:ngInclude#animations ngInclude}                                                      | enter and leave                                                          |
     * | {@link ng.directive:ngSwitch#animations ngSwitch}                                                        | enter and leave                                                          |
     * | {@link ng.directive:ngIf#animations ngIf}                                                                | enter and leave                                                          |
     * | {@link ng.directive:ngClass#animations ngClass}                                                          | add and remove (the CSS class(es) present)                               |
     * | {@link ng.directive:ngShow#animations ngShow} & {@link ng.directive:ngHide#animations ngHide}            | add and remove (the ng-hide class value)                                 |
     * | {@link ng.directive:form#animation-hooks form} & {@link ng.directive:ngModel#animation-hooks ngModel}    | add and remove (dirty, pristine, valid, invalid & all other validations) |
     * | {@link module:ngMessages#animations ngMessages}                                                          | add and remove (ng-active & ng-inactive)                                 |
     * | {@link module:ngMessages#animations ngMessage}                                                           | enter and leave                                                          |
     *
     * You can find out more information about animations upon visiting each directive page.
     *
     * Below is an example of how to apply animations to a directive that supports animation hooks:
     *
     * ```html
     * <style type="text/css">
     * .slide.ng-enter, .slide.ng-leave {
     *   -webkit-transition:0.5s linear all;
     *   transition:0.5s linear all;
     * }
     *
     * .slide.ng-enter { }        /&#42; starting animations for enter &#42;/
     * .slide.ng-enter.ng-enter-active { } /&#42; terminal animations for enter &#42;/
     * .slide.ng-leave { }        /&#42; starting animations for leave &#42;/
     * .slide.ng-leave.ng-leave-active { } /&#42; terminal animations for leave &#42;/
     * </style>
     *
     * <!--
     * the animate service will automatically add .ng-enter and .ng-leave to the element
     * to trigger the CSS transition/animations
     * -->
     * <ANY class="slide" ng-include="..."></ANY>
     * ```
     *
     * Keep in mind that, by default, if an animation is running, any child elements cannot be animated
     * until the parent element's animation has completed. This blocking feature can be overridden by
     * placing the `ng-animate-children` attribute on a parent container tag.
     *
     * ```html
     * <div class="slide-animation" ng-if="on" ng-animate-children>
     *   <div class="fade-animation" ng-if="on">
     *     <div class="explode-animation" ng-if="on">
     *        ...
     *     </div>
     *   </div>
     * </div>
     * ```
     *
     * When the `on` expression value changes and an animation is triggered then each of the elements within
     * will all animate without the block being applied to child elements.
     *
     * ## Are animations run when the application starts?
     * No they are not. When an application is bootstrapped Angular will disable animations from running to avoid
     * a frenzy of animations from being triggered as soon as the browser has rendered the screen. For this to work,
     * Angular will wait for two digest cycles until enabling animations. From there on, any animation-triggering
     * layout changes in the application will trigger animations as normal.
     *
     * In addition, upon bootstrap, if the routing system or any directives or load remote data (via $http) then Angular
     * will automatically extend the wait time to enable animations once **all** of the outbound HTTP requests
     * are complete.
     *
     * ## CSS-defined Animations
     * The animate service will automatically apply two CSS classes to the animated element and these two CSS classes
     * are designed to contain the start and end CSS styling. Both CSS transitions and keyframe animations are supported
     * and can be used to play along with this naming structure.
     *
     * The following code below demonstrates how to perform animations using **CSS transitions** with Angular:
     *
     * ```html
     * <style type="text/css">
     * /&#42;
     *  The animate class is apart of the element and the ng-enter class
     *  is attached to the element once the enter animation event is triggered
     * &#42;/
     * .reveal-animation.ng-enter {
     *  -webkit-transition: 1s linear all; /&#42; Safari/Chrome &#42;/
     *  transition: 1s linear all; /&#42; All other modern browsers and IE10+ &#42;/
     *
     *  /&#42; The animation preparation code &#42;/
     *  opacity: 0;
     * }
     *
     * /&#42;
     *  Keep in mind that you want to combine both CSS
     *  classes together to avoid any CSS-specificity
     *  conflicts
     * &#42;/
     * .reveal-animation.ng-enter.ng-enter-active {
     *  /&#42; The animation code itself &#42;/
     *  opacity: 1;
     * }
     * </style>
     *
     * <div class="view-container">
     *   <div ng-view class="reveal-animation"></div>
     * </div>
     * ```
     *
     * The following code below demonstrates how to perform animations using **CSS animations** with Angular:
     *
     * ```html
     * <style type="text/css">
     * .reveal-animation.ng-enter {
     *   -webkit-animation: enter_sequence 1s linear; /&#42; Safari/Chrome &#42;/
     *   animation: enter_sequence 1s linear; /&#42; IE10+ and Future Browsers &#42;/
     * }
     * @-webkit-keyframes enter_sequence {
     *   from { opacity:0; }
     *   to { opacity:1; }
     * }
     * @keyframes enter_sequence {
     *   from { opacity:0; }
     *   to { opacity:1; }
     * }
     * </style>
     *
     * <div class="view-container">
     *   <div ng-view class="reveal-animation"></div>
     * </div>
     * ```
     *
     * Both CSS3 animations and transitions can be used together and the animate service will figure out the correct duration and delay timing.
     *
     * Upon DOM mutation, the event class is added first (something like `ng-enter`), then the browser prepares itself to add
     * the active class (in this case `ng-enter-active`) which then triggers the animation. The animation module will automatically
     * detect the CSS code to determine when the animation ends. Once the animation is over then both CSS classes will be
     * removed from the DOM. If a browser does not support CSS transitions or CSS animations then the animation will start and end
     * immediately resulting in a DOM element that is at its final state. This final state is when the DOM element
     * has no CSS transition/animation classes applied to it.
     *
     * ### Structural transition animations
     *
     * Structural transitions (such as enter, leave and move) will always apply a `0s none` transition
     * value to force the browser into rendering the styles defined in the setup (`.ng-enter`, `.ng-leave`
     * or `.ng-move`) class. This means that any active transition animations operating on the element
     * will be cut off to make way for the enter, leave or move animation.
     *
     * ### Class-based transition animations
     *
     * Class-based transitions refer to transition animations that are triggered when a CSS class is
     * added to or removed from the element (via `$animate.addClass`, `$animate.removeClass`,
     * `$animate.setClass`, or by directives such as `ngClass`, `ngModel` and `form`).
     * They are different when compared to structural animations since they **do not cancel existing
     * animations** nor do they **block successive transitions** from rendering on the same element.
     * This distinction allows for **multiple class-based transitions** to be performed on the same element.
     *
     * In addition to ngAnimate supporting the default (natural) functionality of class-based transition
     * animations, ngAnimate also decorates the element with starting and ending CSS classes to aid the
     * developer in further styling the element throughout the transition animation. Earlier versions
     * of ngAnimate may have caused natural CSS transitions to break and not render properly due to
     * $animate temporarily blocking transitions using `0s none` in order to allow the setup CSS class
     * (the `-add` or `-remove` class) to be applied without triggering an animation. However, as of
     * **version 1.3**, this workaround has been removed with ngAnimate and all non-ngAnimate CSS
     * class transitions are compatible with ngAnimate.
     *
     * There is, however, one special case when dealing with class-based transitions in ngAnimate.
     * When rendering class-based transitions that make use of the setup and active CSS classes
     * (e.g. `.fade-add` and `.fade-add-active` for when `.fade` is added) be sure to define
     * the transition value **on the active CSS class** and not the setup class.
     *
     * ```css
     * .fade-add {
     *   /&#42; remember to place a 0s transition here
     *      to ensure that the styles are applied instantly
     *      even if the element already has a transition style &#42;/
     *   transition:0s linear all;
     *
     *   /&#42; starting CSS styles &#42;/
     *   opacity:1;
     * }
     * .fade-add.fade-add-active {
     *   /&#42; this will be the length of the animation &#42;/
     *   transition:1s linear all;
     *   opacity:0;
     * }
     * ```
     *
     * The setup CSS class (in this case `.fade-add`) also has a transition style property, however, it
     * has a duration of zero. This may not be required, however, incase the browser is unable to render
     * the styling present in this CSS class instantly then it could be that the browser is attempting
     * to perform an unnecessary transition.
     *
     * This workaround, however, does not apply to  standard class-based transitions that are rendered
     * when a CSS class containing a transition is applied to an element:
     *
     * ```css
     * /&#42; this works as expected &#42;/
     * .fade {
     *   transition:1s linear all;
     *   opacity:0;
     * }
     * ```
     *
     * Please keep this in mind when coding the CSS markup that will be used within class-based transitions.
     * Also, try not to mix the two class-based animation flavors together since the CSS code may become
     * overly complex.
     *
     *
     * ### Preventing Collisions With Third Party Libraries
     *
     * Some third-party frameworks place animation duration defaults across many element or className
     * selectors in order to make their code small and reuseable. This can lead to issues with ngAnimate, which
     * is expecting actual animations on these elements and has to wait for their completion.
     *
     * You can prevent this unwanted behavior by using a prefix on all your animation classes:
     *
     * ```css
     * /&#42; prefixed with animate- &#42;/
     * .animate-fade-add.animate-fade-add-active {
     *   transition:1s linear all;
     *   opacity:0;
     * }
     * ```
     *
     * You then configure `$animate` to enforce this prefix:
     *
     * ```js
     * $animateProvider.classNameFilter(/animate-/);
     * ```
     * </div>
     *
     * ### CSS Staggering Animations
     * A Staggering animation is a collection of animations that are issued with a slight delay in between each successive operation resulting in a
     * curtain-like effect. The ngAnimate module (versions >=1.2) supports staggering animations and the stagger effect can be
     * performed by creating a **ng-EVENT-stagger** CSS class and attaching that class to the base CSS class used for
     * the animation. The style property expected within the stagger class can either be a **transition-delay** or an
     * **animation-delay** property (or both if your animation contains both transitions and keyframe animations).
     *
     * ```css
     * .my-animation.ng-enter {
     *   /&#42; standard transition code &#42;/
     *   -webkit-transition: 1s linear all;
     *   transition: 1s linear all;
     *   opacity:0;
     * }
     * .my-animation.ng-enter-stagger {
     *   /&#42; this will have a 100ms delay between each successive leave animation &#42;/
     *   -webkit-transition-delay: 0.1s;
     *   transition-delay: 0.1s;
     *
     *   /&#42; in case the stagger doesn't work then these two values
     *    must be set to 0 to avoid an accidental CSS inheritance &#42;/
     *   -webkit-transition-duration: 0s;
     *   transition-duration: 0s;
     * }
     * .my-animation.ng-enter.ng-enter-active {
     *   /&#42; standard transition styles &#42;/
     *   opacity:1;
     * }
     * ```
     *
     * Staggering animations work by default in ngRepeat (so long as the CSS class is defined). Outside of ngRepeat, to use staggering animations
     * on your own, they can be triggered by firing multiple calls to the same event on $animate. However, the restrictions surrounding this
     * are that each of the elements must have the same CSS className value as well as the same parent element. A stagger operation
     * will also be reset if more than 10ms has passed after the last animation has been fired.
     *
     * The following code will issue the **ng-leave-stagger** event on the element provided:
     *
     * ```js
     * var kids = parent.children();
     *
     * $animate.leave(kids[0]); //stagger index=0
     * $animate.leave(kids[1]); //stagger index=1
     * $animate.leave(kids[2]); //stagger index=2
     * $animate.leave(kids[3]); //stagger index=3
     * $animate.leave(kids[4]); //stagger index=4
     *
     * $timeout(function() {
     *   //stagger has reset itself
     *   $animate.leave(kids[5]); //stagger index=0
     *   $animate.leave(kids[6]); //stagger index=1
     * }, 100, false);
     * ```
     *
     * Stagger animations are currently only supported within CSS-defined animations.
     *
     * ## JavaScript-defined Animations
     * In the event that you do not want to use CSS3 transitions or CSS3 animations or if you wish to offer animations on browsers that do not
     * yet support CSS transitions/animations, then you can make use of JavaScript animations defined inside of your AngularJS module.
     *
     * ```js
     * //!annotate="YourApp" Your AngularJS Module|Replace this or ngModule with the module that you used to define your application.
     * var ngModule = angular.module('YourApp', ['ngAnimate']);
     * ngModule.animation('.my-crazy-animation', function() {
     *   return {
     *     enter: function(element, done) {
     *       //run the animation here and call done when the animation is complete
     *       return function(cancelled) {
     *         //this (optional) function will be called when the animation
     *         //completes or when the animation is cancelled (the cancelled
     *         //flag will be set to true if cancelled).
     *       };
     *     },
     *     leave: function(element, done) { },
     *     move: function(element, done) { },
     *
     *     //animation that can be triggered before the class is added
     *     beforeAddClass: function(element, className, done) { },
     *
     *     //animation that can be triggered after the class is added
     *     addClass: function(element, className, done) { },
     *
     *     //animation that can be triggered before the class is removed
     *     beforeRemoveClass: function(element, className, done) { },
     *
     *     //animation that can be triggered after the class is removed
     *     removeClass: function(element, className, done) { }
     *   };
     * });
     * ```
     *
     * JavaScript-defined animations are created with a CSS-like class selector and a collection of events which are set to run
     * a javascript callback function. When an animation is triggered, $animate will look for a matching animation which fits
     * the element's CSS class attribute value and then run the matching animation event function (if found).
     * In other words, if the CSS classes present on the animated element match any of the JavaScript animations then the callback function will
     * be executed. It should be also noted that only simple, single class selectors are allowed (compound class selectors are not supported).
     *
     * Within a JavaScript animation, an object containing various event callback animation functions is expected to be returned.
     * As explained above, these callbacks are triggered based on the animation event. Therefore if an enter animation is run,
     * and the JavaScript animation is found, then the enter callback will handle that animation (in addition to the CSS keyframe animation
     * or transition code that is defined via a stylesheet).
     *
     *
     * ### Applying Directive-specific Styles to an Animation
     * In some cases a directive or service may want to provide `$animate` with extra details that the animation will
     * include into its animation. Let's say for example we wanted to render an animation that animates an element
     * towards the mouse coordinates as to where the user clicked last. By collecting the X/Y coordinates of the click
     * (via the event parameter) we can set the `top` and `left` styles into an object and pass that into our function
     * call to `$animate.addClass`.
     *
     * ```js
     * canvas.on('click', function(e) {
     *   $animate.addClass(element, 'on', {
     *     to: {
     *       left : e.client.x + 'px',
     *       top : e.client.y + 'px'
     *     }
     *   }):
     * });
     * ```
     *
     * Now when the animation runs, and a transition or keyframe animation is picked up, then the animation itself will
     * also include and transition the styling of the `left` and `top` properties into its running animation. If we want
     * to provide some starting animation values then we can do so by placing the starting animations styles into an object
     * called `from` in the same object as the `to` animations.
     *
     * ```js
     * canvas.on('click', function(e) {
     *   $animate.addClass(element, 'on', {
     *     from: {
     *        position: 'absolute',
     *        left: '0px',
     *        top: '0px'
     *     },
     *     to: {
     *       left : e.client.x + 'px',
     *       top : e.client.y + 'px'
     *     }
     *   }):
     * });
     * ```
     *
     * Once the animation is complete or cancelled then the union of both the before and after styles are applied to the
     * element. If `ngAnimate` is not present then the styles will be applied immediately.
     *
     */
    angular.module( 'ngAnimate', [ 'ng' ] )
        /**
         * @ngdoc provider
         * @name $animateProvider
         * @description
         *
         * The `$animateProvider` allows developers to register JavaScript animation event handlers directly inside of a module.
         * When an animation is triggered, the $animate service will query the $animate service to find any animations that match
         * the provided name value.
         *
         * Requires the {@link ngAnimate `ngAnimate`} module to be installed.
         *
         * Please visit the {@link ngAnimate `ngAnimate`} module overview page learn more about how to use animations in your application.
         *
         */
        .directive( 'ngAnimateChildren', function() {
            var NG_ANIMATE_CHILDREN = '$$ngAnimateChildren';
            return function( scope, element, attrs ) {
                var val = attrs.ngAnimateChildren;
                if ( angular.isString( val ) && val.length === 0 ) { //empty attribute
                    element.data( NG_ANIMATE_CHILDREN, true );
                } else {
                    scope.$watch( val, function( value ) {
                        element.data( NG_ANIMATE_CHILDREN, !!value );
                    } );
                }
            };
        } )
        //this private service is only used within CSS-enabled animations
        //IE8 + IE9 do not support rAF natively, but that is fine since they
        //also don't support transitions and keyframes which means that the code
        //below will never be used by the two browsers.
        .factory( '$$animateReflow', [ '$$rAF', '$document', function( $$rAF, $document ) {
            var bod = $document[ 0 ].body;
            return function( fn ) {
                //the returned function acts as the cancellation function
                return $$rAF( function() {
                    //the line below will force the browser to perform a repaint
                    //so that all the animated elements within the animation frame
                    //will be properly updated and drawn on screen. This is
                    //required to perform multi-class CSS based animations with
                    //Firefox. DO NOT REMOVE THIS LINE.
                    var a = bod.offsetWidth + 1;
                    fn();
                } );
            };
  } ] ).config( [ '$provide', '$animateProvider', function( $provide, $animateProvider ) {
            var noop = angular.noop;
            var forEach = angular.forEach;
            var selectors = $animateProvider.$$selectors;
            var isArray = angular.isArray;
            var isString = angular.isString;
            var isObject = angular.isObject;
            var ELEMENT_NODE = 1;
            var NG_ANIMATE_STATE = '$$ngAnimateState';
            var NG_ANIMATE_CHILDREN = '$$ngAnimateChildren';
            var NG_ANIMATE_CLASS_NAME = 'ng-animate';
            var rootAnimateState = {
                running: true
            };

            function extractElementNode( element ) {
                for ( var i = 0; i < element.length; i++ ) {
                    var elm = element[ i ];
                    if ( elm.nodeType == ELEMENT_NODE ) {
                        return elm;
                    }
                }
            }

            function prepareElement( element ) {
                return element && angular.element( element );
            }

            function stripCommentsFromElement( element ) {
                return angular.element( extractElementNode( element ) );
            }

            function isMatchingElement( elm1, elm2 ) {
                return extractElementNode( elm1 ) == extractElementNode( elm2 );
            }
            var $$jqLite;
            $provide.decorator( '$animate', [ '$delegate', '$$q', '$injector', '$sniffer', '$rootElement', '$$asyncCallback', '$rootScope', '$document', '$templateRequest', '$$jqLite',
 function( $delegate, $$q, $injector, $sniffer, $rootElement, $$asyncCallback, $rootScope, $document, $templateRequest, $$$jqLite ) {
                    $$jqLite = $$$jqLite;
                    $rootElement.data( NG_ANIMATE_STATE, rootAnimateState );
                    // Wait until all directive and route-related templates are downloaded and
                    // compiled. The $templateRequest.totalPendingRequests variable keeps track of
                    // all of the remote templates being currently downloaded. If there are no
                    // templates currently downloading then the watcher will still fire anyway.
                    var deregisterWatch = $rootScope.$watch( function() {
                        return $templateRequest.totalPendingRequests;
                    }, function( val, oldVal ) {
                        if ( val !== 0 ) return;
                        deregisterWatch();
                        // Now that all templates have been downloaded, $animate will wait until
                        // the post digest queue is empty before enabling animations. By having two
                        // calls to $postDigest calls we can ensure that the flag is enabled at the
                        // very end of the post digest queue. Since all of the animations in $animate
                        // use $postDigest, it's important that the code below executes at the end.
                        // This basically means that the page is fully downloaded and compiled before
                        // any animations are triggered.
                        $rootScope.$$postDigest( function() {
                            $rootScope.$$postDigest( function() {
                                rootAnimateState.running = false;
                            } );
                        } );
                    } );
                    var globalAnimationCounter = 0;
                    var classNameFilter = $animateProvider.classNameFilter();
                    var isAnimatableClassName = !classNameFilter ? function() {
                        return true;
                    } : function( className ) {
                        return classNameFilter.test( className );
                    };

                    function classBasedAnimationsBlocked( element, setter ) {
                        var data = element.data( NG_ANIMATE_STATE ) || {};
                        if ( setter ) {
                            data.running = true;
                            data.structural = true;
                            element.data( NG_ANIMATE_STATE, data );
                        }
                        return data.disabled || ( data.running && data.structural );
                    }

                    function runAnimationPostDigest( fn ) {
                        var cancelFn, defer = $$q.defer();
                        defer.promise.$$cancelFn = function() {
                            cancelFn && cancelFn();
                        };
                        $rootScope.$$postDigest( function() {
                            cancelFn = fn( function() {
                                defer.resolve();
                            } );
                        } );
                        return defer.promise;
                    }

                    function parseAnimateOptions( options ) {
                        // some plugin code may still be passing in the callback
                        // function as the last param for the $animate methods so
                        // it's best to only allow string or array values for now
                        if ( isObject( options ) ) {
                            if ( options.tempClasses && isString( options.tempClasses ) ) {
                                options.tempClasses = options.tempClasses.split( /\s+/ );
                            }
                            return options;
                        }
                    }

                    function resolveElementClasses( element, cache, runningAnimations ) {
                        runningAnimations = runningAnimations || {};
                        var lookup = {};
                        forEach( runningAnimations, function( data, selector ) {
                            forEach( selector.split( ' ' ), function( s ) {
                                lookup[ s ] = data;
                            } );
                        } );
                        var hasClasses = Object.create( null );
                        forEach( ( element.attr( 'class' ) || '' ).split( /\s+/ ), function( className ) {
                            hasClasses[ className ] = true;
                        } );
                        var toAdd = [],
                            toRemove = [];
                        forEach( ( cache && cache.classes ) || [], function( status, className ) {
                            var hasClass = hasClasses[ className ];
                            var matchingAnimation = lookup[ className ] || {};
                            // When addClass and removeClass is called then $animate will check to
                            // see if addClass and removeClass cancel each other out. When there are
                            // more calls to removeClass than addClass then the count falls below 0
                            // and then the removeClass animation will be allowed. Otherwise if the
                            // count is above 0 then that means an addClass animation will commence.
                            // Once an animation is allowed then the code will also check to see if
                            // there exists any on-going animation that is already adding or remvoing
                            // the matching CSS class.
                            if ( status === false ) {
                                //does it have the class or will it have the class
                                if ( hasClass || matchingAnimation.event == 'addClass' ) {
                                    toRemove.push( className );
                                }
                            } else if ( status === true ) {
                                //is the class missing or will it be removed?
                                if ( !hasClass || matchingAnimation.event == 'removeClass' ) {
                                    toAdd.push( className );
                                }
                            }
                        } );
                        return ( toAdd.length + toRemove.length ) > 0 && [ toAdd.join( ' ' ), toRemove.join( ' ' ) ];
                    }

                    function lookup( name ) {
                        if ( name ) {
                            var matches = [],
                                flagMap = {},
                                classes = name.substr( 1 ).split( '.' );
                            //the empty string value is the default animation
                            //operation which performs CSS transition and keyframe
                            //animations sniffing. This is always included for each
                            //element animation procedure if the browser supports
                            //transitions and/or keyframe animations. The default
                            //animation is added to the top of the list to prevent
                            //any previous animations from affecting the element styling
                            //prior to the element being animated.
                            if ( $sniffer.transitions || $sniffer.animations ) {
                                matches.push( $injector.get( selectors[ '' ] ) );
                            }
                            for ( var i = 0; i < classes.length; i++ ) {
                                var klass = classes[ i ],
                                    selectorFactoryName = selectors[ klass ];
                                if ( selectorFactoryName && !flagMap[ klass ] ) {
                                    matches.push( $injector.get( selectorFactoryName ) );
                                    flagMap[ klass ] = true;
                                }
                            }
                            return matches;
                        }
                    }

                    function animationRunner( element, animationEvent, className, options ) {
                            //transcluded directives may sometimes fire an animation using only comment nodes
                            //best to catch this early on to prevent any animation operations from occurring
                            var node = element[ 0 ];
                            if ( !node ) {
                                return;
                            }
                            if ( options ) {
                                options.to = options.to || {};
                                options.from = options.from || {};
                            }
                            var classNameAdd;
                            var classNameRemove;
                            if ( isArray( className ) ) {
                                classNameAdd = className[ 0 ];
                                classNameRemove = className[ 1 ];
                                if ( !classNameAdd ) {
                                    className = classNameRemove;
                                    animationEvent = 'removeClass';
                                } else if ( !classNameRemove ) {
                                    className = classNameAdd;
                                    animationEvent = 'addClass';
                                } else {
                                    className = classNameAdd + ' ' + classNameRemove;
                                }
                            }
                            var isSetClassOperation = animationEvent == 'setClass';
                            var isClassBased = isSetClassOperation || animationEvent == 'addClass' || animationEvent == 'removeClass' || animationEvent == 'animate';
                            var currentClassName = element.attr( 'class' );
                            var classes = currentClassName + ' ' + className;
                            if ( !isAnimatableClassName( classes ) ) {
                                return;
                            }
                            var beforeComplete = noop,
                                beforeCancel = [],
                                before = [],
                                afterComplete = noop,
                                afterCancel = [],
                                after = [];
                            var animationLookup = ( ' ' + classes ).replace( /\s+/g, '.' );
                            forEach( lookup( animationLookup ), function( animationFactory ) {
                                var created = registerAnimation( animationFactory, animationEvent );
                                if ( !created && isSetClassOperation ) {
                                    registerAnimation( animationFactory, 'addClass' );
                                    registerAnimation( animationFactory, 'removeClass' );
                                }
                            } );

                            function registerAnimation( animationFactory, event ) {
                                var afterFn = animationFactory[ event ];
                                var beforeFn = animationFactory[ 'before' + event.charAt( 0 ).toUpperCase() + event.substr( 1 ) ];
                                if ( afterFn || beforeFn ) {
                                    if ( event == 'leave' ) {
                                        beforeFn = afterFn;
                                        //when set as null then animation knows to skip this phase
                                        afterFn = null;
                                    }
                                    after.push( {
                                        event: event,
                                        fn: afterFn
                                    } );
                                    before.push( {
                                        event: event,
                                        fn: beforeFn
                                    } );
                                    return true;
                                }
                            }

                            function run( fns, cancellations, allCompleteFn ) {
                                var animations = [];
                                forEach( fns, function( animation ) {
                                    animation.fn && animations.push( animation );
                                } );
                                var count = 0;

                                function afterAnimationComplete( index ) {
                                        if ( cancellations ) {
                                            ( cancellations[ index ] || noop )();
                                            if ( ++count < animations.length ) return;
                                            cancellations = null;
                                        }
                                        allCompleteFn();
                                    }
                                    //The code below adds directly to the array in order to work with
                                    //both sync and async animations. Sync animations are when the done()
                                    //operation is called right away. DO NOT REFACTOR!
                                forEach( animations, function( animation, index ) {
                                    var progress = function() {
                                        afterAnimationComplete( index );
                                    };
                                    switch ( animation.event ) {
                                        case 'setClass':
                                            cancellations.push( animation.fn( element, classNameAdd, classNameRemove, progress, options ) );
                                            break;
                                        case 'animate':
                                            cancellations.push( animation.fn( element, className, options.from, options.to, progress ) );
                                            break;
                                        case 'addClass':
                                            cancellations.push( animation.fn( element, classNameAdd || className, progress, options ) );
                                            break;
                                        case 'removeClass':
                                            cancellations.push( animation.fn( element, classNameRemove || className, progress, options ) );
                                            break;
                                        default:
                                            cancellations.push( animation.fn( element, progress, options ) );
                                            break;
                                    }
                                } );
                                if ( cancellations && cancellations.length === 0 ) {
                                    allCompleteFn();
                                }
                            }
                            return {
                                node: node,
                                event: animationEvent,
                                className: className,
                                isClassBased: isClassBased,
                                isSetClassOperation: isSetClassOperation,
                                applyStyles: function() {
                                    if ( options ) {
                                        element.css( angular.extend( options.from || {}, options.to || {} ) );
                                    }
                                },
                                before: function( allCompleteFn ) {
                                    beforeComplete = allCompleteFn;
                                    run( before, beforeCancel, function() {
                                        beforeComplete = noop;
                                        allCompleteFn();
                                    } );
                                },
                                after: function( allCompleteFn ) {
                                    afterComplete = allCompleteFn;
                                    run( after, afterCancel, function() {
                                        afterComplete = noop;
                                        allCompleteFn();
                                    } );
                                },
                                cancel: function() {
                                    if ( beforeCancel ) {
                                        forEach( beforeCancel, function( cancelFn ) {
                                            ( cancelFn || noop )( true );
                                        } );
                                        beforeComplete( true );
                                    }
                                    if ( afterCancel ) {
                                        forEach( afterCancel, function( cancelFn ) {
                                            ( cancelFn || noop )( true );
                                        } );
                                        afterComplete( true );
                                    }
                                }
                            };
                        }
                        /**
                         * @ngdoc service
                         * @name $animate
                         * @kind object
                         *
                         * @description
                         * The `$animate` service provides animation detection support while performing DOM operations (enter, leave and move) as well as during addClass and removeClass operations.
                         * When any of these operations are run, the $animate service
                         * will examine any JavaScript-defined animations (which are defined by using the $animateProvider provider object)
                         * as well as any CSS-defined animations against the CSS classes present on the element once the DOM operation is run.
                         *
                         * The `$animate` service is used behind the scenes with pre-existing directives and animation with these directives
                         * will work out of the box without any extra configuration.
                         *
                         * Requires the {@link ngAnimate `ngAnimate`} module to be installed.
                         *
                         * Please visit the {@link ngAnimate `ngAnimate`} module overview page learn more about how to use animations in your application.
                         * ## Callback Promises
                         * With AngularJS 1.3, each of the animation methods, on the `$animate` service, return a promise when called. The
                         * promise itself is then resolved once the animation has completed itself, has been cancelled or has been
                         * skipped due to animations being disabled. (Note that even if the animation is cancelled it will still
                         * call the resolve function of the animation.)
                         *
                         * ```js
                         * $animate.enter(element, container).then(function() {
                         *   //...this is called once the animation is complete...
                         * });
                         * ```
                         *
                         * Also note that, due to the nature of the callback promise, if any Angular-specific code (like changing the scope,
                         * location of the page, etc...) is executed within the callback promise then be sure to wrap the code using
                         * `$scope.$apply(...)`;
                         *
                         * ```js
                         * $animate.leave(element).then(function() {
                         *   $scope.$apply(function() {
                         *     $location.path('/new-page');
                         *   });
                         * });
                         * ```
                         *
                         * An animation can also be cancelled by calling the `$animate.cancel(promise)` method with the provided
                         * promise that was returned when the animation was started.
                         *
                         * ```js
                         * var promise = $animate.addClass(element, 'super-long-animation').then(function() {
                         *   //this will still be called even if cancelled
                         * });
                         *
                         * element.on('click', function() {
                         *   //tooo lazy to wait for the animation to end
                         *   $animate.cancel(promise);
                         * });
                         * ```
                         *
                         * (Keep in mind that the promise cancellation is unique to `$animate` since promises in
                         * general cannot be cancelled.)
                         *
                         */
                    return {
                        /**
                         * @ngdoc method
                         * @name $animate#animate
                         * @kind function
                         *
                         * @description
                         * Performs an inline animation on the element which applies the provided `to` and `from` CSS styles to the element.
                         * If any detected CSS transition, keyframe or JavaScript matches the provided `className` value then the animation
                         * will take on the provided styles. For example, if a transition animation is set for the given className then the
                         * provided `from` and `to` styles will be applied alongside the given transition. If a JavaScript animation is
                         * detected then the provided styles will be given in as function paramters.
                         *
                         * ```js
                         * ngModule.animation('.my-inline-animation', function() {
                         *   return {
                         *     animate : function(element, className, from, to, done) {
                         *       //styles
                         *     }
                         *   }
                         * });
                         * ```
                         *
                         * Below is a breakdown of each step that occurs during the `animate` animation:
                         *
                         * | Animation Step                                                                                                        | What the element class attribute looks like                  |
                         * |-----------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------|
                         * | 1. `$animate.animate(...)` is called                                                                                  | `class="my-animation"`                                       |
                         * | 2. `$animate` waits for the next digest to start the animation                                                        | `class="my-animation ng-animate"`                            |
                         * | 3. `$animate` runs the JavaScript-defined animations detected on the element                                          | `class="my-animation ng-animate"`                            |
                         * | 4. the `className` class value is added to the element                                                                | `class="my-animation ng-animate className"`                  |
                         * | 5. `$animate` scans the element styles to get the CSS transition/animation duration and delay                         | `class="my-animation ng-animate className"`                  |
                         * | 6. `$animate` blocks all CSS transitions on the element to ensure the `.className` class styling is applied right away| `class="my-animation ng-animate className"`                  |
                         * | 7. `$animate` applies the provided collection of `from` CSS styles to the element                                     | `class="my-animation ng-animate className"`                  |
                         * | 8. `$animate` waits for a single animation frame (this performs a reflow)                                             | `class="my-animation ng-animate className"`                  |
                         * | 9. `$animate` removes the CSS transition block placed on the element                                                  | `class="my-animation ng-animate className"`                  |
                         * | 10. the `className-active` class is added (this triggers the CSS transition/animation)                                | `class="my-animation ng-animate className className-active"` |
                         * | 11. `$animate` applies the collection of `to` CSS styles to the element which are then handled by the transition      | `class="my-animation ng-animate className className-active"` |
                         * | 12. `$animate` waits for the animation to complete (via events and timeout)                                           | `class="my-animation ng-animate className className-active"` |
                         * | 13. The animation ends and all generated CSS classes are removed from the element                                     | `class="my-animation"`                                       |
                         * | 14. The returned promise is resolved.                                                                                 | `class="my-animation"`                                       |
                         *
                         * @param {DOMElement} element the element that will be the focus of the enter animation
                         * @param {object} from a collection of CSS styles that will be applied to the element at the start of the animation
                         * @param {object} to a collection of CSS styles that the element will animate towards
                         * @param {string=} className an optional CSS class that will be added to the element for the duration of the animation (the default class is `ng-inline-animate`)
                         * @param {object=} options an optional collection of options that will be picked up by the CSS transition/animation
                         * @return {Promise} the animation callback promise
                         */
                        animate: function( element, from, to, className, options ) {
                            className = className || 'ng-inline-animate';
                            options = parseAnimateOptions( options ) || {};
                            options.from = to ? from : null;
                            options.to = to ? to : from;
                            return runAnimationPostDigest( function( done ) {
                                return performAnimation( 'animate', className, stripCommentsFromElement( element ), null, null, noop, options, done );
                            } );
                        },
                        /**
                         * @ngdoc method
                         * @name $animate#enter
                         * @kind function
                         *
                         * @description
                         * Appends the element to the parentElement element that resides in the document and then runs the enter animation. Once
                         * the animation is started, the following CSS classes will be present on the element for the duration of the animation:
                         *
                         * Below is a breakdown of each step that occurs during enter animation:
                         *
                         * | Animation Step                                                                                                        | What the element class attribute looks like                |
                         * |-----------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------|
                         * | 1. `$animate.enter(...)` is called                                                                                    | `class="my-animation"`                                     |
                         * | 2. element is inserted into the `parentElement` element or beside the `afterElement` element                          | `class="my-animation"`                                     |
                         * | 3. `$animate` waits for the next digest to start the animation                                                        | `class="my-animation ng-animate"`                          |
                         * | 4. `$animate` runs the JavaScript-defined animations detected on the element                                          | `class="my-animation ng-animate"`                          |
                         * | 5. the `.ng-enter` class is added to the element                                                                      | `class="my-animation ng-animate ng-enter"`                 |
                         * | 6. `$animate` scans the element styles to get the CSS transition/animation duration and delay                         | `class="my-animation ng-animate ng-enter"`                 |
                         * | 7. `$animate` blocks all CSS transitions on the element to ensure the `.ng-enter` class styling is applied right away | `class="my-animation ng-animate ng-enter"`                 |
                         * | 8. `$animate` waits for a single animation frame (this performs a reflow)                                             | `class="my-animation ng-animate ng-enter"`                 |
                         * | 9. `$animate` removes the CSS transition block placed on the element                                                  | `class="my-animation ng-animate ng-enter"`                 |
                         * | 10. the `.ng-enter-active` class is added (this triggers the CSS transition/animation)                                | `class="my-animation ng-animate ng-enter ng-enter-active"` |
                         * | 11. `$animate` waits for the animation to complete (via events and timeout)                                           | `class="my-animation ng-animate ng-enter ng-enter-active"` |
                         * | 12. The animation ends and all generated CSS classes are removed from the element                                     | `class="my-animation"`                                     |
                         * | 13. The returned promise is resolved.                                                                                 | `class="my-animation"`                                     |
                         *
                         * @param {DOMElement} element the element that will be the focus of the enter animation
                         * @param {DOMElement} parentElement the parent element of the element that will be the focus of the enter animation
                         * @param {DOMElement} afterElement the sibling element (which is the previous element) of the element that will be the focus of the enter animation
                         * @param {object=} options an optional collection of options that will be picked up by the CSS transition/animation
                         * @return {Promise} the animation callback promise
                         */
                        enter: function( element, parentElement, afterElement, options ) {
                            options = parseAnimateOptions( options );
                            element = angular.element( element );
                            parentElement = prepareElement( parentElement );
                            afterElement = prepareElement( afterElement );
                            classBasedAnimationsBlocked( element, true );
                            $delegate.enter( element, parentElement, afterElement );
                            return runAnimationPostDigest( function( done ) {
                                return performAnimation( 'enter', 'ng-enter', stripCommentsFromElement( element ), parentElement, afterElement, noop, options, done );
                            } );
                        },
                        /**
                         * @ngdoc method
                         * @name $animate#leave
                         * @kind function
                         *
                         * @description
                         * Runs the leave animation operation and, upon completion, removes the element from the DOM. Once
                         * the animation is started, the following CSS classes will be added for the duration of the animation:
                         *
                         * Below is a breakdown of each step that occurs during leave animation:
                         *
                         * | Animation Step                                                                                                        | What the element class attribute looks like                |
                         * |-----------------------------------------------------------------------------------------------------------------------|------------------------------------------------------------|
                         * | 1. `$animate.leave(...)` is called                                                                                    | `class="my-animation"`                                     |
                         * | 2. `$animate` runs the JavaScript-defined animations detected on the element                                          | `class="my-animation ng-animate"`                          |
                         * | 3. `$animate` waits for the next digest to start the animation                                                        | `class="my-animation ng-animate"`                          |
                         * | 4. the `.ng-leave` class is added to the element                                                                      | `class="my-animation ng-animate ng-leave"`                 |
                         * | 5. `$animate` scans the element styles to get the CSS transition/animation duration and delay                         | `class="my-animation ng-animate ng-leave"`                 |
                         * | 6. `$animate` blocks all CSS transitions on the element to ensure the `.ng-leave` class styling is applied right away | `class="my-animation ng-animate ng-leave"`                 |
                         * | 7. `$animate` waits for a single animation frame (this performs a reflow)                                             | `class="my-animation ng-animate ng-leave"`                 |
                         * | 8. `$animate` removes the CSS transition block placed on the element                                                  | `class="my-animation ng-animate ng-leave"`                 |
                         * | 9. the `.ng-leave-active` class is added (this triggers the CSS transition/animation)                                 | `class="my-animation ng-animate ng-leave ng-leave-active"` |
                         * | 10. `$animate` waits for the animation to complete (via events and timeout)                                           | `class="my-animation ng-animate ng-leave ng-leave-active"` |
                         * | 11. The animation ends and all generated CSS classes are removed from the element                                     | `class="my-animation"`                                     |
                         * | 12. The element is removed from the DOM                                                                               | ...                                                        |
                         * | 13. The returned promise is resolved.                                                                                 | ...                                                        |
                         *
                         * @param {DOMElement} element the element that will be the focus of the leave animation
                         * @param {object=} options an optional collection of styles that will be picked up by the CSS transition/animation
                         * @return {Promise} the animation callback promise
                         */
                        leave: function( element, options ) {
                            options = parseAnimateOptions( options );
                            element = angular.element( element );
                            cancelChildAnimations( element );
                            classBasedAnimationsBlocked( element, true );
                            return runAnimationPostDigest( function( done ) {
                                return performAnimation( 'leave', 'ng-leave', stripCommentsFromElement( element ), null, null, function() {
                                    $delegate.leave( element );
                                }, options, done );
                            } );
                        },
                        /**
                         * @ngdoc method
                         * @name $animate#move
                         * @kind function
                         *
                         * @description
                         * Fires the move DOM operation. Just before the animation starts, the animate service will either append it into the parentElement container or
                         * add the element directly after the afterElement element if present. Then the move animation will be run. Once
                         * the animation is started, the following CSS classes will be added for the duration of the animation:
                         *
                         * Below is a breakdown of each step that occurs during move animation:
                         *
                         * | Animation Step                                                                                                       | What the element class attribute looks like              |
                         * |----------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------|
                         * | 1. `$animate.move(...)` is called                                                                                    | `class="my-animation"`                                   |
                         * | 2. element is moved into the parentElement element or beside the afterElement element                                | `class="my-animation"`                                   |
                         * | 3. `$animate` waits for the next digest to start the animation                                                       | `class="my-animation ng-animate"`                        |
                         * | 4. `$animate` runs the JavaScript-defined animations detected on the element                                         | `class="my-animation ng-animate"`                        |
                         * | 5. the `.ng-move` class is added to the element                                                                      | `class="my-animation ng-animate ng-move"`                |
                         * | 6. `$animate` scans the element styles to get the CSS transition/animation duration and delay                        | `class="my-animation ng-animate ng-move"`                |
                         * | 7. `$animate` blocks all CSS transitions on the element to ensure the `.ng-move` class styling is applied right away | `class="my-animation ng-animate ng-move"`                |
                         * | 8. `$animate` waits for a single animation frame (this performs a reflow)                                            | `class="my-animation ng-animate ng-move"`                |
                         * | 9. `$animate` removes the CSS transition block placed on the element                                                 | `class="my-animation ng-animate ng-move"`                |
                         * | 10. the `.ng-move-active` class is added (this triggers the CSS transition/animation)                                | `class="my-animation ng-animate ng-move ng-move-active"` |
                         * | 11. `$animate` waits for the animation to complete (via events and timeout)                                          | `class="my-animation ng-animate ng-move ng-move-active"` |
                         * | 12. The animation ends and all generated CSS classes are removed from the element                                    | `class="my-animation"`                                   |
                         * | 13. The returned promise is resolved.                                                                                | `class="my-animation"`                                   |
                         *
                         * @param {DOMElement} element the element that will be the focus of the move animation
                         * @param {DOMElement} parentElement the parentElement element of the element that will be the focus of the move animation
                         * @param {DOMElement} afterElement the sibling element (which is the previous element) of the element that will be the focus of the move animation
                         * @param {object=} options an optional collection of styles that will be picked up by the CSS transition/animation
                         * @return {Promise} the animation callback promise
                         */
                        move: function( element, parentElement, afterElement, options ) {
                            options = parseAnimateOptions( options );
                            element = angular.element( element );
                            parentElement = prepareElement( parentElement );
                            afterElement = prepareElement( afterElement );
                            cancelChildAnimations( element );
                            classBasedAnimationsBlocked( element, true );
                            $delegate.move( element, parentElement, afterElement );
                            return runAnimationPostDigest( function( done ) {
                                return performAnimation( 'move', 'ng-move', stripCommentsFromElement( element ), parentElement, afterElement, noop, options, done );
                            } );
                        },
                        /**
                         * @ngdoc method
                         * @name $animate#addClass
                         *
                         * @description
                         * Triggers a custom animation event based off the className variable and then attaches the className value to the element as a CSS class.
                         * Unlike the other animation methods, the animate service will suffix the className value with {@type -add} in order to provide
                         * the animate service the setup and active CSS classes in order to trigger the animation (this will be skipped if no CSS transitions
                         * or keyframes are defined on the -add-active or base CSS class).
                         *
                         * Below is a breakdown of each step that occurs during addClass animation:
                         *
                         * | Animation Step                                                                                         | What the element class attribute looks like                        |
                         * |--------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------|
                         * | 1. `$animate.addClass(element, 'super')` is called                                                     | `class="my-animation"`                                             |
                         * | 2. `$animate` runs the JavaScript-defined animations detected on the element                           | `class="my-animation ng-animate"`                                  |
                         * | 3. the `.super-add` class is added to the element                                                      | `class="my-animation ng-animate super-add"`                        |
                         * | 4. `$animate` waits for a single animation frame (this performs a reflow)                              | `class="my-animation ng-animate super-add"`                        |
                         * | 5. the `.super` and `.super-add-active` classes are added (this triggers the CSS transition/animation) | `class="my-animation ng-animate super super-add super-add-active"` |
                         * | 6. `$animate` scans the element styles to get the CSS transition/animation duration and delay          | `class="my-animation ng-animate super super-add super-add-active"` |
                         * | 7. `$animate` waits for the animation to complete (via events and timeout)                             | `class="my-animation ng-animate super super-add super-add-active"` |
                         * | 8. The animation ends and all generated CSS classes are removed from the element                       | `class="my-animation super"`                                       |
                         * | 9. The super class is kept on the element                                                              | `class="my-animation super"`                                       |
                         * | 10. The returned promise is resolved.                                                                  | `class="my-animation super"`                                       |
                         *
                         * @param {DOMElement} element the element that will be animated
                         * @param {string} className the CSS class that will be added to the element and then animated
                         * @param {object=} options an optional collection of styles that will be picked up by the CSS transition/animation
                         * @return {Promise} the animation callback promise
                         */
                        addClass: function( element, className, options ) {
                            return this.setClass( element, className, [], options );
                        },
                        /**
                         * @ngdoc method
                         * @name $animate#removeClass
                         *
                         * @description
                         * Triggers a custom animation event based off the className variable and then removes the CSS class provided by the className value
                         * from the element. Unlike the other animation methods, the animate service will suffix the className value with {@type -remove} in
                         * order to provide the animate service the setup and active CSS classes in order to trigger the animation (this will be skipped if
                         * no CSS transitions or keyframes are defined on the -remove or base CSS classes).
                         *
                         * Below is a breakdown of each step that occurs during removeClass animation:
                         *
                         * | Animation Step                                                                                                       | What the element class attribute looks like                        |
                         * |----------------------------------------------------------------------------------------------------------------------|--------------------------------------------------------------------|
                         * | 1. `$animate.removeClass(element, 'super')` is called                                                                | `class="my-animation super"`                                       |
                         * | 2. `$animate` runs the JavaScript-defined animations detected on the element                                         | `class="my-animation super ng-animate"`                            |
                         * | 3. the `.super-remove` class is added to the element                                                                 | `class="my-animation super ng-animate super-remove"`               |
                         * | 4. `$animate` waits for a single animation frame (this performs a reflow)                                            | `class="my-animation super ng-animate super-remove"`               |
                         * | 5. the `.super-remove-active` classes are added and `.super` is removed (this triggers the CSS transition/animation) | `class="my-animation ng-animate super-remove super-remove-active"` |
                         * | 6. `$animate` scans the element styles to get the CSS transition/animation duration and delay                        | `class="my-animation ng-animate super-remove super-remove-active"` |
                         * | 7. `$animate` waits for the animation to complete (via events and timeout)                                           | `class="my-animation ng-animate super-remove super-remove-active"` |
                         * | 8. The animation ends and all generated CSS classes are removed from the element                                     | `class="my-animation"`                                             |
                         * | 9. The returned promise is resolved.                                                                                 | `class="my-animation"`                                             |
                         *
                         *
                         * @param {DOMElement} element the element that will be animated
                         * @param {string} className the CSS class that will be animated and then removed from the element
                         * @param {object=} options an optional collection of styles that will be picked up by the CSS transition/animation
                         * @return {Promise} the animation callback promise
                         */
                        removeClass: function( element, className, options ) {
                            return this.setClass( element, [], className, options );
                        },
                        /**
                         *
                         * @ngdoc method
                         * @name $animate#setClass
                         *
                         * @description Adds and/or removes the given CSS classes to and from the element.
                         * Once complete, the `done()` callback will be fired (if provided).
                         *
                         * | Animation Step                                                                                                                               | What the element class attribute looks like                                            |
                         * |----------------------------------------------------------------------------------------------------------------------------------------------|----------------------------------------------------------------------------------------|
                         * | 1. `$animate.setClass(element, 'on', 'off')` is called                                                                                       | `class="my-animation off"`                                                             |
                         * | 2. `$animate` runs the JavaScript-defined animations detected on the element                                                                 | `class="my-animation ng-animate off"`                                                  |
                         * | 3. the `.on-add` and `.off-remove` classes are added to the element                                                                          | `class="my-animation ng-animate on-add off-remove off"`                                |
                         * | 4. `$animate` waits for a single animation frame (this performs a reflow)                                                                    | `class="my-animation ng-animate on-add off-remove off"`                                |
                         * | 5. the `.on`, `.on-add-active` and `.off-remove-active` classes are added and `.off` is removed (this triggers the CSS transition/animation) | `class="my-animation ng-animate on on-add on-add-active off-remove off-remove-active"` |
                         * | 6. `$animate` scans the element styles to get the CSS transition/animation duration and delay                                                | `class="my-animation ng-animate on on-add on-add-active off-remove off-remove-active"` |
                         * | 7. `$animate` waits for the animation to complete (via events and timeout)                                                                   | `class="my-animation ng-animate on on-add on-add-active off-remove off-remove-active"` |
                         * | 8. The animation ends and all generated CSS classes are removed from the element                                                             | `class="my-animation on"`                                                              |
                         * | 9. The returned promise is resolved.                                                                                                         | `class="my-animation on"`                                                              |
                         *
                         * @param {DOMElement} element the element which will have its CSS classes changed
                         *   removed from it
                         * @param {string} add the CSS classes which will be added to the element
                         * @param {string} remove the CSS class which will be removed from the element
                         *   CSS classes have been set on the element
                         * @param {object=} options an optional collection of styles that will be picked up by the CSS transition/animation
                         * @return {Promise} the animation callback promise
                         */
                        setClass: function( element, add, remove, options ) {
                            options = parseAnimateOptions( options );
                            var STORAGE_KEY = '$$animateClasses';
                            element = angular.element( element );
                            element = stripCommentsFromElement( element );
                            if ( classBasedAnimationsBlocked( element ) ) {
                                return $delegate.$$setClassImmediately( element, add, remove, options );
                            }
                            // we're using a combined array for both the add and remove
                            // operations since the ORDER OF addClass and removeClass matters
                            var classes, cache = element.data( STORAGE_KEY );
                            var hasCache = !!cache;
                            if ( !cache ) {
                                cache = {};
                                cache.classes = {};
                            }
                            classes = cache.classes;
                            add = isArray( add ) ? add : add.split( ' ' );
                            forEach( add, function( c ) {
                                if ( c && c.length ) {
                                    classes[ c ] = true;
                                }
                            } );
                            remove = isArray( remove ) ? remove : remove.split( ' ' );
                            forEach( remove, function( c ) {
                                if ( c && c.length ) {
                                    classes[ c ] = false;
                                }
                            } );
                            if ( hasCache ) {
                                if ( options && cache.options ) {
                                    cache.options = angular.extend( cache.options || {}, options );
                                }
                                //the digest cycle will combine all the animations into one function
                                return cache.promise;
                            } else {
                                element.data( STORAGE_KEY, cache = {
                                    classes: classes,
                                    options: options
                                } );
                            }
                            return cache.promise = runAnimationPostDigest( function( done ) {
                                var parentElement = element.parent();
                                var elementNode = extractElementNode( element );
                                var parentNode = elementNode.parentNode;
                                // TODO(matsko): move this code into the animationsDisabled() function once #8092 is fixed
                                if ( !parentNode || parentNode[ '$$NG_REMOVED' ] || elementNode[ '$$NG_REMOVED' ] ) {
                                    done();
                                    return;
                                }
                                var cache = element.data( STORAGE_KEY );
                                element.removeData( STORAGE_KEY );
                                var state = element.data( NG_ANIMATE_STATE ) || {};
                                var classes = resolveElementClasses( element, cache, state.active );
                                return !classes ? done() : performAnimation( 'setClass', classes, element, parentElement, null, function() {
                                    if ( classes[ 0 ] ) $delegate.$$addClassImmediately( element, classes[ 0 ] );
                                    if ( classes[ 1 ] ) $delegate.$$removeClassImmediately( element, classes[ 1 ] );
                                }, cache.options, done );
                            } );
                        },
                        /**
                         * @ngdoc method
                         * @name $animate#cancel
                         * @kind function
                         *
                         * @param {Promise} animationPromise The animation promise that is returned when an animation is started.
                         *
                         * @description
                         * Cancels the provided animation.
                         */
                        cancel: function( promise ) {
                            promise.$$cancelFn();
                        },
                        /**
                         * @ngdoc method
                         * @name $animate#enabled
                         * @kind function
                         *
                         * @param {boolean=} value If provided then set the animation on or off.
                         * @param {DOMElement=} element If provided then the element will be used to represent the enable/disable operation
                         * @return {boolean} Current animation state.
                         *
                         * @description
                         * Globally enables/disables animations.
                         *
                         */
                        enabled: function( value, element ) {
                            switch ( arguments.length ) {
                                case 2:
                                    if ( value ) {
                                        cleanup( element );
                                    } else {
                                        var data = element.data( NG_ANIMATE_STATE ) || {};
                                        data.disabled = true;
                                        element.data( NG_ANIMATE_STATE, data );
                                    }
                                    break;
                                case 1:
                                    rootAnimateState.disabled = !value;
                                    break;
                                default:
                                    value = !rootAnimateState.disabled;
                                    break;
                            }
                            return !!value;
                        }
                    };
                    /*
                      all animations call this shared animation triggering function internally.
                      The animationEvent variable refers to the JavaScript animation event that will be triggered
                      and the className value is the name of the animation that will be applied within the
                      CSS code. Element, `parentElement` and `afterElement` are provided DOM elements for the animation
                      and the onComplete callback will be fired once the animation is fully complete.
                    */
                    function performAnimation( animationEvent, className, element, parentElement, afterElement, domOperation, options, doneCallback ) {
                        var noopCancel = noop;
                        var runner = animationRunner( element, animationEvent, className, options );
                        if ( !runner ) {
                            fireDOMOperation();
                            fireBeforeCallbackAsync();
                            fireAfterCallbackAsync();
                            closeAnimation();
                            return noopCancel;
                        }
                        animationEvent = runner.event;
                        className = runner.className;
                        var elementEvents = angular.element._data( runner.node );
                        elementEvents = elementEvents && elementEvents.events;
                        if ( !parentElement ) {
                            parentElement = afterElement ? afterElement.parent() : element.parent();
                        }
                        //skip the animation if animations are disabled, a parent is already being animated,
                        //the element is not currently attached to the document body or then completely close
                        //the animation if any matching animations are not found at all.
                        //NOTE: IE8 + IE9 should close properly (run closeAnimation()) in case an animation was found.
                        if ( animationsDisabled( element, parentElement ) ) {
                            fireDOMOperation();
                            fireBeforeCallbackAsync();
                            fireAfterCallbackAsync();
                            closeAnimation();
                            return noopCancel;
                        }
                        var ngAnimateState = element.data( NG_ANIMATE_STATE ) || {};
                        var runningAnimations = ngAnimateState.active || {};
                        var totalActiveAnimations = ngAnimateState.totalActive || 0;
                        var lastAnimation = ngAnimateState.last;
                        var skipAnimation = false;
                        if ( totalActiveAnimations > 0 ) {
                            var animationsToCancel = [];
                            if ( !runner.isClassBased ) {
                                if ( animationEvent == 'leave' && runningAnimations[ 'ng-leave' ] ) {
                                    skipAnimation = true;
                                } else {
                                    //cancel all animations when a structural animation takes place
                                    for ( var klass in runningAnimations ) {
                                        animationsToCancel.push( runningAnimations[ klass ] );
                                    }
                                    ngAnimateState = {};
                                    cleanup( element, true );
                                }
                            } else if ( lastAnimation.event == 'setClass' ) {
                                animationsToCancel.push( lastAnimation );
                                cleanup( element, className );
                            } else if ( runningAnimations[ className ] ) {
                                var current = runningAnimations[ className ];
                                if ( current.event == animationEvent ) {
                                    skipAnimation = true;
                                } else {
                                    animationsToCancel.push( current );
                                    cleanup( element, className );
                                }
                            }
                            if ( animationsToCancel.length > 0 ) {
                                forEach( animationsToCancel, function( operation ) {
                                    operation.cancel();
                                } );
                            }
                        }
                        if ( runner.isClassBased && !runner.isSetClassOperation && animationEvent != 'animate' && !skipAnimation ) {
                            skipAnimation = ( animationEvent == 'addClass' ) == element.hasClass( className ); //opposite of XOR
                        }
                        if ( skipAnimation ) {
                            fireDOMOperation();
                            fireBeforeCallbackAsync();
                            fireAfterCallbackAsync();
                            fireDoneCallbackAsync();
                            return noopCancel;
                        }
                        runningAnimations = ngAnimateState.active || {};
                        totalActiveAnimations = ngAnimateState.totalActive || 0;
                        if ( animationEvent == 'leave' ) {
                            //there's no need to ever remove the listener since the element
                            //will be removed (destroyed) after the leave animation ends or
                            //is cancelled midway
                            element.one( '$destroy', function( e ) {
                                var element = angular.element( this );
                                var state = element.data( NG_ANIMATE_STATE );
                                if ( state ) {
                                    var activeLeaveAnimation = state.active[ 'ng-leave' ];
                                    if ( activeLeaveAnimation ) {
                                        activeLeaveAnimation.cancel();
                                        cleanup( element, 'ng-leave' );
                                    }
                                }
                            } );
                        }
                        //the ng-animate class does nothing, but it's here to allow for
                        //parent animations to find and cancel child animations when needed
                        $$jqLite.addClass( element, NG_ANIMATE_CLASS_NAME );
                        if ( options && options.tempClasses ) {
                            forEach( options.tempClasses, function( className ) {
                                $$jqLite.addClass( element, className );
                            } );
                        }
                        var localAnimationCount = globalAnimationCounter++;
                        totalActiveAnimations++;
                        runningAnimations[ className ] = runner;
                        element.data( NG_ANIMATE_STATE, {
                            last: runner,
                            active: runningAnimations,
                            index: localAnimationCount,
                            totalActive: totalActiveAnimations
                        } );
                        //first we run the before animations and when all of those are complete
                        //then we perform the DOM operation and run the next set of animations
                        fireBeforeCallbackAsync();
                        runner.before( function( cancelled ) {
                            var data = element.data( NG_ANIMATE_STATE );
                            cancelled = cancelled || !data || !data.active[ className ] || ( runner.isClassBased && data.active[ className ].event != animationEvent );
                            fireDOMOperation();
                            if ( cancelled === true ) {
                                closeAnimation();
                            } else {
                                fireAfterCallbackAsync();
                                runner.after( closeAnimation );
                            }
                        } );
                        return runner.cancel;

                        function fireDOMCallback( animationPhase ) {
                            var eventName = '$animate:' + animationPhase;
                            if ( elementEvents && elementEvents[ eventName ] && elementEvents[ eventName ].length > 0 ) {
                                $$asyncCallback( function() {
                                    element.triggerHandler( eventName, {
                                        event: animationEvent,
                                        className: className
                                    } );
                                } );
                            }
                        }

                        function fireBeforeCallbackAsync() {
                            fireDOMCallback( 'before' );
                        }

                        function fireAfterCallbackAsync() {
                            fireDOMCallback( 'after' );
                        }

                        function fireDoneCallbackAsync() {
                                fireDOMCallback( 'close' );
                                doneCallback();
                            }
                            //it is less complicated to use a flag than managing and canceling
                            //timeouts containing multiple callbacks.
                        function fireDOMOperation() {
                            if ( !fireDOMOperation.hasBeenRun ) {
                                fireDOMOperation.hasBeenRun = true;
                                domOperation();
                            }
                        }

                        function closeAnimation() {
                            if ( !closeAnimation.hasBeenRun ) {
                                if ( runner ) { //the runner doesn't exist if it fails to instantiate
                                    runner.applyStyles();
                                }
                                closeAnimation.hasBeenRun = true;
                                if ( options && options.tempClasses ) {
                                    forEach( options.tempClasses, function( className ) {
                                        $$jqLite.removeClass( element, className );
                                    } );
                                }
                                var data = element.data( NG_ANIMATE_STATE );
                                if ( data ) {
                                    /* only structural animations wait for reflow before removing an
                                       animation, but class-based animations don't. An example of this
                                       failing would be when a parent HTML tag has a ng-class attribute
                                       causing ALL directives below to skip animations during the digest */
                                    if ( runner && runner.isClassBased ) {
                                        cleanup( element, className );
                                    } else {
                                        $$asyncCallback( function() {
                                            var data = element.data( NG_ANIMATE_STATE ) || {};
                                            if ( localAnimationCount == data.index ) {
                                                cleanup( element, className, animationEvent );
                                            }
                                        } );
                                        element.data( NG_ANIMATE_STATE, data );
                                    }
                                }
                                fireDoneCallbackAsync();
                            }
                        }
                    }

                    function cancelChildAnimations( element ) {
                        var node = extractElementNode( element );
                        if ( node ) {
                            var nodes = angular.isFunction( node.getElementsByClassName ) ? node.getElementsByClassName( NG_ANIMATE_CLASS_NAME ) : node.querySelectorAll( '.' + NG_ANIMATE_CLASS_NAME );
                            forEach( nodes, function( element ) {
                                element = angular.element( element );
                                var data = element.data( NG_ANIMATE_STATE );
                                if ( data && data.active ) {
                                    forEach( data.active, function( runner ) {
                                        runner.cancel();
                                    } );
                                }
                            } );
                        }
                    }

                    function cleanup( element, className ) {
                        if ( isMatchingElement( element, $rootElement ) ) {
                            if ( !rootAnimateState.disabled ) {
                                rootAnimateState.running = false;
                                rootAnimateState.structural = false;
                            }
                        } else if ( className ) {
                            var data = element.data( NG_ANIMATE_STATE ) || {};
                            var removeAnimations = className === true;
                            if ( !removeAnimations && data.active && data.active[ className ] ) {
                                data.totalActive--;
                                delete data.active[ className ];
                            }
                            if ( removeAnimations || !data.totalActive ) {
                                $$jqLite.removeClass( element, NG_ANIMATE_CLASS_NAME );
                                element.removeData( NG_ANIMATE_STATE );
                            }
                        }
                    }

                    function animationsDisabled( element, parentElement ) {
                        if ( rootAnimateState.disabled ) {
                            return true;
                        }
                        if ( isMatchingElement( element, $rootElement ) ) {
                            return rootAnimateState.running;
                        }
                        var allowChildAnimations, parentRunningAnimation, hasParent;
                        do {
                            //the element did not reach the root element which means that it
                            //is not apart of the DOM. Therefore there is no reason to do
                            //any animations on it
                            if ( parentElement.length === 0 ) break;
                            var isRoot = isMatchingElement( parentElement, $rootElement );
                            var state = isRoot ? rootAnimateState : ( parentElement.data( NG_ANIMATE_STATE ) || {} );
                            if ( state.disabled ) {
                                return true;
                            }
                            //no matter what, for an animation to work it must reach the root element
                            //this implies that the element is attached to the DOM when the animation is run
                            if ( isRoot ) {
                                hasParent = true;
                            }
                            //once a flag is found that is strictly false then everything before
                            //it will be discarded and all child animations will be restricted
                            if ( allowChildAnimations !== false ) {
                                var animateChildrenFlag = parentElement.data( NG_ANIMATE_CHILDREN );
                                if ( angular.isDefined( animateChildrenFlag ) ) {
                                    allowChildAnimations = animateChildrenFlag;
                                }
                            }
                            parentRunningAnimation = parentRunningAnimation || state.running || ( state.last && !state.last.isClassBased );
                        }
                        while ( parentElement = parentElement.parent() );
                        return !hasParent || ( !allowChildAnimations && parentRunningAnimation );
                    }
    } ] );
            $animateProvider.register( '', [ '$window', '$sniffer', '$timeout', '$$animateReflow',
                           function( $window, $sniffer, $timeout, $$animateReflow ) {
                    // Detect proper transitionend/animationend event names.
                    var CSS_PREFIX = '',
                        TRANSITION_PROP, TRANSITIONEND_EVENT, ANIMATION_PROP, ANIMATIONEND_EVENT;
                    // If unprefixed events are not supported but webkit-prefixed are, use the latter.
                    // Otherwise, just use W3C names, browsers not supporting them at all will just ignore them.
                    // Note: Chrome implements `window.onwebkitanimationend` and doesn't implement `window.onanimationend`
                    // but at the same time dispatches the `animationend` event and not `webkitAnimationEnd`.
                    // Register both events in case `window.onanimationend` is not supported because of that,
                    // do the same for `transitionend` as Safari is likely to exhibit similar behavior.
                    // Also, the only modern browser that uses vendor prefixes for transitions/keyframes is webkit
                    // therefore there is no reason to test anymore for other vendor prefixes: http://caniuse.com/#search=transition
                    if ( window.ontransitionend === undefined && window.onwebkittransitionend !== undefined ) {
                        CSS_PREFIX = '-webkit-';
                        TRANSITION_PROP = 'WebkitTransition';
                        TRANSITIONEND_EVENT = 'webkitTransitionEnd transitionend';
                    } else {
                        TRANSITION_PROP = 'transition';
                        TRANSITIONEND_EVENT = 'transitionend';
                    }
                    if ( window.onanimationend === undefined && window.onwebkitanimationend !== undefined ) {
                        CSS_PREFIX = '-webkit-';
                        ANIMATION_PROP = 'WebkitAnimation';
                        ANIMATIONEND_EVENT = 'webkitAnimationEnd animationend';
                    } else {
                        ANIMATION_PROP = 'animation';
                        ANIMATIONEND_EVENT = 'animationend';
                    }
                    var DURATION_KEY = 'Duration';
                    var PROPERTY_KEY = 'Property';
                    var DELAY_KEY = 'Delay';
                    var ANIMATION_ITERATION_COUNT_KEY = 'IterationCount';
                    var ANIMATION_PLAYSTATE_KEY = 'PlayState';
                    var NG_ANIMATE_PARENT_KEY = '$$ngAnimateKey';
                    var NG_ANIMATE_CSS_DATA_KEY = '$$ngAnimateCSS3Data';
                    var ELAPSED_TIME_MAX_DECIMAL_PLACES = 3;
                    var CLOSING_TIME_BUFFER = 1.5;
                    var ONE_SECOND = 1000;
                    var lookupCache = {};
                    var parentCounter = 0;
                    var animationReflowQueue = [];
                    var cancelAnimationReflow;

                    function clearCacheAfterReflow() {
                        if ( !cancelAnimationReflow ) {
                            cancelAnimationReflow = $$animateReflow( function() {
                                animationReflowQueue = [];
                                cancelAnimationReflow = null;
                                lookupCache = {};
                            } );
                        }
                    }

                    function afterReflow( element, callback ) {
                        if ( cancelAnimationReflow ) {
                            cancelAnimationReflow();
                        }
                        animationReflowQueue.push( callback );
                        cancelAnimationReflow = $$animateReflow( function() {
                            forEach( animationReflowQueue, function( fn ) {
                                fn();
                            } );
                            animationReflowQueue = [];
                            cancelAnimationReflow = null;
                            lookupCache = {};
                        } );
                    }
                    var closingTimer = null;
                    var closingTimestamp = 0;
                    var animationElementQueue = [];

                    function animationCloseHandler( element, totalTime ) {
                        var node = extractElementNode( element );
                        element = angular.element( node );
                        //this item will be garbage collected by the closing
                        //animation timeout
                        animationElementQueue.push( element );
                        //but it may not need to cancel out the existing timeout
                        //if the timestamp is less than the previous one
                        var futureTimestamp = Date.now() + totalTime;
                        if ( futureTimestamp <= closingTimestamp ) {
                            return;
                        }
                        $timeout.cancel( closingTimer );
                        closingTimestamp = futureTimestamp;
                        closingTimer = $timeout( function() {
                            closeAllAnimations( animationElementQueue );
                            animationElementQueue = [];
                        }, totalTime, false );
                    }

                    function closeAllAnimations( elements ) {
                        forEach( elements, function( element ) {
                            var elementData = element.data( NG_ANIMATE_CSS_DATA_KEY );
                            if ( elementData ) {
                                forEach( elementData.closeAnimationFns, function( fn ) {
                                    fn();
                                } );
                            }
                        } );
                    }

                    function getElementAnimationDetails( element, cacheKey ) {
                        var data = cacheKey ? lookupCache[ cacheKey ] : null;
                        if ( !data ) {
                            var transitionDuration = 0;
                            var transitionDelay = 0;
                            var animationDuration = 0;
                            var animationDelay = 0;
                            //we want all the styles defined before and after
                            forEach( element, function( element ) {
                                if ( element.nodeType == ELEMENT_NODE ) {
                                    var elementStyles = $window.getComputedStyle( element ) || {};
                                    var transitionDurationStyle = elementStyles[ TRANSITION_PROP + DURATION_KEY ];
                                    transitionDuration = Math.max( parseMaxTime( transitionDurationStyle ), transitionDuration );
                                    var transitionDelayStyle = elementStyles[ TRANSITION_PROP + DELAY_KEY ];
                                    transitionDelay = Math.max( parseMaxTime( transitionDelayStyle ), transitionDelay );
                                    var animationDelayStyle = elementStyles[ ANIMATION_PROP + DELAY_KEY ];
                                    animationDelay = Math.max( parseMaxTime( elementStyles[ ANIMATION_PROP + DELAY_KEY ] ), animationDelay );
                                    var aDuration = parseMaxTime( elementStyles[ ANIMATION_PROP + DURATION_KEY ] );
                                    if ( aDuration > 0 ) {
                                        aDuration *= parseInt( elementStyles[ ANIMATION_PROP + ANIMATION_ITERATION_COUNT_KEY ], 10 ) || 1;
                                    }
                                    animationDuration = Math.max( aDuration, animationDuration );
                                }
                            } );
                            data = {
                                total: 0,
                                transitionDelay: transitionDelay,
                                transitionDuration: transitionDuration,
                                animationDelay: animationDelay,
                                animationDuration: animationDuration
                            };
                            if ( cacheKey ) {
                                lookupCache[ cacheKey ] = data;
                            }
                        }
                        return data;
                    }

                    function parseMaxTime( str ) {
                        var maxValue = 0;
                        var values = isString( str ) ? str.split( /\s*,\s*/ ) : [];
                        forEach( values, function( value ) {
                            maxValue = Math.max( parseFloat( value ) || 0, maxValue );
                        } );
                        return maxValue;
                    }

                    function getCacheKey( element ) {
                        var parentElement = element.parent();
                        var parentID = parentElement.data( NG_ANIMATE_PARENT_KEY );
                        if ( !parentID ) {
                            parentElement.data( NG_ANIMATE_PARENT_KEY, ++parentCounter );
                            parentID = parentCounter;
                        }
                        return parentID + '-' + extractElementNode( element ).getAttribute( 'class' );
                    }

                    function animateSetup( animationEvent, element, className, styles ) {
                        var structural = [ 'ng-enter', 'ng-leave', 'ng-move' ].indexOf( className ) >= 0;
                        var cacheKey = getCacheKey( element );
                        var eventCacheKey = cacheKey + ' ' + className;
                        var itemIndex = lookupCache[ eventCacheKey ] ? ++lookupCache[ eventCacheKey ].total : 0;
                        var stagger = {};
                        if ( itemIndex > 0 ) {
                            var staggerClassName = className + '-stagger';
                            var staggerCacheKey = cacheKey + ' ' + staggerClassName;
                            var applyClasses = !lookupCache[ staggerCacheKey ];
                            applyClasses && $$jqLite.addClass( element, staggerClassName );
                            stagger = getElementAnimationDetails( element, staggerCacheKey );
                            applyClasses && $$jqLite.removeClass( element, staggerClassName );
                        }
                        $$jqLite.addClass( element, className );
                        var formerData = element.data( NG_ANIMATE_CSS_DATA_KEY ) || {};
                        var timings = getElementAnimationDetails( element, eventCacheKey );
                        var transitionDuration = timings.transitionDuration;
                        var animationDuration = timings.animationDuration;
                        if ( structural && transitionDuration === 0 && animationDuration === 0 ) {
                            $$jqLite.removeClass( element, className );
                            return false;
                        }
                        var blockTransition = styles || ( structural && transitionDuration > 0 );
                        var blockAnimation = animationDuration > 0 && stagger.animationDelay > 0 && stagger.animationDuration === 0;
                        var closeAnimationFns = formerData.closeAnimationFns || [];
                        element.data( NG_ANIMATE_CSS_DATA_KEY, {
                            stagger: stagger,
                            cacheKey: eventCacheKey,
                            running: formerData.running || 0,
                            itemIndex: itemIndex,
                            blockTransition: blockTransition,
                            closeAnimationFns: closeAnimationFns
                        } );
                        var node = extractElementNode( element );
                        if ( blockTransition ) {
                            blockTransitions( node, true );
                            if ( styles ) {
                                element.css( styles );
                            }
                        }
                        if ( blockAnimation ) {
                            blockAnimations( node, true );
                        }
                        return true;
                    }

                    function animateRun( animationEvent, element, className, activeAnimationComplete, styles ) {
                        var node = extractElementNode( element );
                        var elementData = element.data( NG_ANIMATE_CSS_DATA_KEY );
                        if ( node.getAttribute( 'class' ).indexOf( className ) == -1 || !elementData ) {
                            activeAnimationComplete();
                            return;
                        }
                        var activeClassName = '';
                        var pendingClassName = '';
                        forEach( className.split( ' ' ), function( klass, i ) {
                            var prefix = ( i > 0 ? ' ' : '' ) + klass;
                            activeClassName += prefix + '-active';
                            pendingClassName += prefix + '-pending';
                        } );
                        var style = '';
                        var appliedStyles = [];
                        var itemIndex = elementData.itemIndex;
                        var stagger = elementData.stagger;
                        var staggerTime = 0;
                        if ( itemIndex > 0 ) {
                            var transitionStaggerDelay = 0;
                            if ( stagger.transitionDelay > 0 && stagger.transitionDuration === 0 ) {
                                transitionStaggerDelay = stagger.transitionDelay * itemIndex;
                            }
                            var animationStaggerDelay = 0;
                            if ( stagger.animationDelay > 0 && stagger.animationDuration === 0 ) {
                                animationStaggerDelay = stagger.animationDelay * itemIndex;
                                appliedStyles.push( CSS_PREFIX + 'animation-play-state' );
                            }
                            staggerTime = Math.round( Math.max( transitionStaggerDelay, animationStaggerDelay ) * 100 ) / 100;
                        }
                        if ( !staggerTime ) {
                            $$jqLite.addClass( element, activeClassName );
                            if ( elementData.blockTransition ) {
                                blockTransitions( node, false );
                            }
                        }
                        var eventCacheKey = elementData.cacheKey + ' ' + activeClassName;
                        var timings = getElementAnimationDetails( element, eventCacheKey );
                        var maxDuration = Math.max( timings.transitionDuration, timings.animationDuration );
                        if ( maxDuration === 0 ) {
                            $$jqLite.removeClass( element, activeClassName );
                            animateClose( element, className );
                            activeAnimationComplete();
                            return;
                        }
                        if ( !staggerTime && styles ) {
                            if ( !timings.transitionDuration ) {
                                element.css( 'transition', timings.animationDuration + 's linear all' );
                                appliedStyles.push( 'transition' );
                            }
                            element.css( styles );
                        }
                        var maxDelay = Math.max( timings.transitionDelay, timings.animationDelay );
                        var maxDelayTime = maxDelay * ONE_SECOND;
                        if ( appliedStyles.length > 0 ) {
                            //the element being animated may sometimes contain comment nodes in
                            //the jqLite object, so we're safe to use a single variable to house
                            //the styles since there is always only one element being animated
                            var oldStyle = node.getAttribute( 'style' ) || '';
                            if ( oldStyle.charAt( oldStyle.length - 1 ) !== ';' ) {
                                oldStyle += ';';
                            }
                            node.setAttribute( 'style', oldStyle + ' ' + style );
                        }
                        var startTime = Date.now();
                        var css3AnimationEvents = ANIMATIONEND_EVENT + ' ' + TRANSITIONEND_EVENT;
                        var animationTime = ( maxDelay + maxDuration ) * CLOSING_TIME_BUFFER;
                        var totalTime = ( staggerTime + animationTime ) * ONE_SECOND;
                        var staggerTimeout;
                        if ( staggerTime > 0 ) {
                            $$jqLite.addClass( element, pendingClassName );
                            staggerTimeout = $timeout( function() {
                                staggerTimeout = null;
                                if ( timings.transitionDuration > 0 ) {
                                    blockTransitions( node, false );
                                }
                                if ( timings.animationDuration > 0 ) {
                                    blockAnimations( node, false );
                                }
                                $$jqLite.addClass( element, activeClassName );
                                $$jqLite.removeClass( element, pendingClassName );
                                if ( styles ) {
                                    if ( timings.transitionDuration === 0 ) {
                                        element.css( 'transition', timings.animationDuration + 's linear all' );
                                    }
                                    element.css( styles );
                                    appliedStyles.push( 'transition' );
                                }
                            }, staggerTime * ONE_SECOND, false );
                        }
                        element.on( css3AnimationEvents, onAnimationProgress );
                        elementData.closeAnimationFns.push( function() {
                            onEnd();
                            activeAnimationComplete();
                        } );
                        elementData.running++;
                        animationCloseHandler( element, totalTime );
                        return onEnd;
                        // This will automatically be called by $animate so
                        // there is no need to attach this internally to the
                        // timeout done method.
                        function onEnd() {
                            element.off( css3AnimationEvents, onAnimationProgress );
                            $$jqLite.removeClass( element, activeClassName );
                            $$jqLite.removeClass( element, pendingClassName );
                            if ( staggerTimeout ) {
                                $timeout.cancel( staggerTimeout );
                            }
                            animateClose( element, className );
                            var node = extractElementNode( element );
                            for ( var i in appliedStyles ) {
                                node.style.removeProperty( appliedStyles[ i ] );
                            }
                        }

                        function onAnimationProgress( event ) {
                            event.stopPropagation();
                            var ev = event.originalEvent || event;
                            var timeStamp = ev.$manualTimeStamp || ev.timeStamp || Date.now();
                            /* Firefox (or possibly just Gecko) likes to not round values up
                             * when a ms measurement is used for the animation */
                            var elapsedTime = parseFloat( ev.elapsedTime.toFixed( ELAPSED_TIME_MAX_DECIMAL_PLACES ) );
                            /* $manualTimeStamp is a mocked timeStamp value which is set
                             * within browserTrigger(). This is only here so that tests can
                             * mock animations properly. Real events fallback to event.timeStamp,
                             * or, if they don't, then a timeStamp is automatically created for them.
                             * We're checking to see if the timeStamp surpasses the expected delay,
                             * but we're using elapsedTime instead of the timeStamp on the 2nd
                             * pre-condition since animations sometimes close off early */
                            if ( Math.max( timeStamp - startTime, 0 ) >= maxDelayTime && elapsedTime >= maxDuration ) {
                                activeAnimationComplete();
                            }
                        }
                    }

                    function blockTransitions( node, bool ) {
                        node.style[ TRANSITION_PROP + PROPERTY_KEY ] = bool ? 'none' : '';
                    }

                    function blockAnimations( node, bool ) {
                        node.style[ ANIMATION_PROP + ANIMATION_PLAYSTATE_KEY ] = bool ? 'paused' : '';
                    }

                    function animateBefore( animationEvent, element, className, styles ) {
                        if ( animateSetup( animationEvent, element, className, styles ) ) {
                            return function( cancelled ) {
                                cancelled && animateClose( element, className );
                            };
                        }
                    }

                    function animateAfter( animationEvent, element, className, afterAnimationComplete, styles ) {
                        if ( element.data( NG_ANIMATE_CSS_DATA_KEY ) ) {
                            return animateRun( animationEvent, element, className, afterAnimationComplete, styles );
                        } else {
                            animateClose( element, className );
                            afterAnimationComplete();
                        }
                    }

                    function animate( animationEvent, element, className, animationComplete, options ) {
                        //If the animateSetup function doesn't bother returning a
                        //cancellation function then it means that there is no animation
                        //to perform at all
                        var preReflowCancellation = animateBefore( animationEvent, element, className, options.from );
                        if ( !preReflowCancellation ) {
                            clearCacheAfterReflow();
                            animationComplete();
                            return;
                        }
                        //There are two cancellation functions: one is before the first
                        //reflow animation and the second is during the active state
                        //animation. The first function will take care of removing the
                        //data from the element which will not make the 2nd animation
                        //happen in the first place
                        var cancel = preReflowCancellation;
                        afterReflow( element, function() {
                            //once the reflow is complete then we point cancel to
                            //the new cancellation function which will remove all of the
                            //animation properties from the active animation
                            cancel = animateAfter( animationEvent, element, className, animationComplete, options.to );
                        } );
                        return function( cancelled ) {
                            ( cancel || noop )( cancelled );
                        };
                    }

                    function animateClose( element, className ) {
                        $$jqLite.removeClass( element, className );
                        var data = element.data( NG_ANIMATE_CSS_DATA_KEY );
                        if ( data ) {
                            if ( data.running ) {
                                data.running--;
                            }
                            if ( !data.running || data.running === 0 ) {
                                element.removeData( NG_ANIMATE_CSS_DATA_KEY );
                            }
                        }
                    }
                    return {
                        animate: function( element, className, from, to, animationCompleted, options ) {
                            options = options || {};
                            options.from = from;
                            options.to = to;
                            return animate( 'animate', element, className, animationCompleted, options );
                        },
                        enter: function( element, animationCompleted, options ) {
                            options = options || {};
                            return animate( 'enter', element, 'ng-enter', animationCompleted, options );
                        },
                        leave: function( element, animationCompleted, options ) {
                            options = options || {};
                            return animate( 'leave', element, 'ng-leave', animationCompleted, options );
                        },
                        move: function( element, animationCompleted, options ) {
                            options = options || {};
                            return animate( 'move', element, 'ng-move', animationCompleted, options );
                        },
                        beforeSetClass: function( element, add, remove, animationCompleted, options ) {
                            options = options || {};
                            var className = suffixClasses( remove, '-remove' ) + ' ' + suffixClasses( add, '-add' );
                            var cancellationMethod = animateBefore( 'setClass', element, className, options.from );
                            if ( cancellationMethod ) {
                                afterReflow( element, animationCompleted );
                                return cancellationMethod;
                            }
                            clearCacheAfterReflow();
                            animationCompleted();
                        },
                        beforeAddClass: function( element, className, animationCompleted, options ) {
                            options = options || {};
                            var cancellationMethod = animateBefore( 'addClass', element, suffixClasses( className, '-add' ), options.from );
                            if ( cancellationMethod ) {
                                afterReflow( element, animationCompleted );
                                return cancellationMethod;
                            }
                            clearCacheAfterReflow();
                            animationCompleted();
                        },
                        beforeRemoveClass: function( element, className, animationCompleted, options ) {
                            options = options || {};
                            var cancellationMethod = animateBefore( 'removeClass', element, suffixClasses( className, '-remove' ), options.from );
                            if ( cancellationMethod ) {
                                afterReflow( element, animationCompleted );
                                return cancellationMethod;
                            }
                            clearCacheAfterReflow();
                            animationCompleted();
                        },
                        setClass: function( element, add, remove, animationCompleted, options ) {
                            options = options || {};
                            remove = suffixClasses( remove, '-remove' );
                            add = suffixClasses( add, '-add' );
                            var className = remove + ' ' + add;
                            return animateAfter( 'setClass', element, className, animationCompleted, options.to );
                        },
                        addClass: function( element, className, animationCompleted, options ) {
                            options = options || {};
                            return animateAfter( 'addClass', element, suffixClasses( className, '-add' ), animationCompleted, options.to );
                        },
                        removeClass: function( element, className, animationCompleted, options ) {
                            options = options || {};
                            return animateAfter( 'removeClass', element, suffixClasses( className, '-remove' ), animationCompleted, options.to );
                        }
                    };

                    function suffixClasses( classes, suffix ) {
                        var className = '';
                        classes = isArray( classes ) ? classes : classes.split( /\s+/ );
                        forEach( classes, function( klass, i ) {
                            if ( klass && klass.length > 0 ) {
                                className += ( i > 0 ? ' ' : '' ) + klass + suffix;
                            }
                        } );
                        return className;
                    }
    } ] );
  } ] );
} )( window, window.angular );
/**
 * @license AngularJS v1.3.7
 * (c) 2010-2014 Google, Inc. http://angularjs.org
 * License: MIT
 */
( function( window, angular, undefined ) {
    'use strict';
    /**
     * @ngdoc module
     * @name ngAria
     * @description
     *
     * The `ngAria` module provides support for common
     * [<abbr title="Accessible Rich Internet Applications">ARIA</abbr>](http://www.w3.org/TR/wai-aria/)
     * attributes that convey state or semantic information about the application for users
     * of assistive technologies, such as screen readers.
     *
     * <div doc-module-components="ngAria"></div>
     *
     * ## Usage
     *
     * For ngAria to do its magic, simply include the module as a dependency. The directives supported
     * by ngAria are:
     * `ngModel`, `ngDisabled`, `ngShow`, `ngHide`, `ngClick`, `ngDblClick`, and `ngMessages`.
     *
     * Below is a more detailed breakdown of the attributes handled by ngAria:
     *
     * | Directive                                   | Supported Attributes                                                                   |
     * |---------------------------------------------|----------------------------------------------------------------------------------------|
     * | {@link ng.directive:ngModel ngModel}        | aria-checked, aria-valuemin, aria-valuemax, aria-valuenow, aria-invalid, aria-required |
     * | {@link ng.directive:ngDisabled ngDisabled}  | aria-disabled                                                                          |
     * | {@link ng.directive:ngShow ngShow}          | aria-hidden                                                                            |
     * | {@link ng.directive:ngHide ngHide}          | aria-hidden                                                                            |
     * | {@link ng.directive:ngClick ngClick}        | tabindex, keypress event                                                               |
     * | {@link ng.directive:ngDblclick ngDblclick}  | tabindex                                                                               |
     * | {@link module:ngMessages ngMessages}        | aria-live                                                                              |
     *
     * Find out more information about each directive by reading the
     * {@link guide/accessibility ngAria Developer Guide}.
     *
     * ##Example
     * Using ngDisabled with ngAria:
     * ```html
     * <md-checkbox ng-disabled="disabled">
     * ```
     * Becomes:
     * ```html
     * <md-checkbox ng-disabled="disabled" aria-disabled="true">
     * ```
     *
     * ##Disabling Attributes
     * It's possible to disable individual attributes added by ngAria with the
     * {@link ngAria.$ariaProvider#config config} method. For more details, see the
     * {@link guide/accessibility Developer Guide}.
     */
    /* global -ngAriaModule */
    var ngAriaModule = angular.module( 'ngAria', [ 'ng' ] ).
    provider( '$aria', $AriaProvider );
    /**
     * @ngdoc provider
     * @name $ariaProvider
     *
     * @description
     *
     * Used for configuring the ARIA attributes injected and managed by ngAria.
     *
     * ```js
     * angular.module('myApp', ['ngAria'], function config($ariaProvider) {
     *   $ariaProvider.config({
     *     ariaValue: true,
     *     tabindex: false
     *   });
     * });
     *```
     *
     * ## Dependencies
     * Requires the {@link ngAria} module to be installed.
     *
     */
    function $AriaProvider() {
        var config = {
            ariaHidden: true,
            ariaChecked: true,
            ariaDisabled: true,
            ariaRequired: true,
            ariaInvalid: true,
            ariaMultiline: true,
            ariaValue: true,
            tabindex: true,
            bindKeypress: true
        };
        /**
         * @ngdoc method
         * @name $ariaProvider#config
         *
         * @param {object} config object to enable/disable specific ARIA attributes
         *
         *  - **ariaHidden**  `{boolean}`  Enables/disables aria-hidden tags
         *  - **ariaChecked**  `{boolean}`  Enables/disables aria-checked tags
         *  - **ariaDisabled**  `{boolean}`  Enables/disables aria-disabled tags
         *  - **ariaRequired**  `{boolean}`  Enables/disables aria-required tags
         *  - **ariaInvalid**  `{boolean}`  Enables/disables aria-invalid tags
         *  - **ariaMultiline**  `{boolean}`  Enables/disables aria-multiline tags
         *  - **ariaValue**  `{boolean}`  Enables/disables aria-valuemin, aria-valuemax and aria-valuenow tags
         *  - **tabindex**  `{boolean}`  Enables/disables tabindex tags
         *  - **bindKeypress**  `{boolean}`  Enables/disables keypress event binding on ng-click
         *
         * @description
         * Enables/disables various ARIA attributes
         */
        this.config = function( newConfig ) {
            config = angular.extend( config, newConfig );
        };

        function watchExpr( attrName, ariaAttr, negate ) {
                return function( scope, elem, attr ) {
                    var ariaCamelName = attr.$normalize( ariaAttr );
                    if ( config[ ariaCamelName ] && !attr[ ariaCamelName ] ) {
                        scope.$watch( attr[ attrName ], function( boolVal ) {
                            if ( negate ) {
                                boolVal = !boolVal;
                            }
                            elem.attr( ariaAttr, boolVal );
                        } );
                    }
                };
            }
            /**
             * @ngdoc service
             * @name $aria
             *
             * @description
             *
             * The $aria service contains helper methods for applying common
             * [ARIA](http://www.w3.org/TR/wai-aria/) attributes to HTML directives.
             *
             * ngAria injects common accessibility attributes that tell assistive technologies when HTML
             * elements are enabled, selected, hidden, and more. To see how this is performed with ngAria,
             * let's review a code snippet from ngAria itself:
             *
             *```js
             * ngAriaModule.directive('ngDisabled', ['$aria', function($aria) {
             *   return $aria.$$watchExpr('ngDisabled', 'aria-disabled');
             * }])
             *```
             * Shown above, the ngAria module creates a directive with the same signature as the
             * traditional `ng-disabled` directive. But this ngAria version is dedicated to
             * solely managing accessibility attributes. The internal `$aria` service is used to watch the
             * boolean attribute `ngDisabled`. If it has not been explicitly set by the developer,
             * `aria-disabled` is injected as an attribute with its value synchronized to the value in
             * `ngDisabled`.
             *
             * Because ngAria hooks into the `ng-disabled` directive, developers do not have to do
             * anything to enable this feature. The `aria-disabled` attribute is automatically managed
             * simply as a silent side-effect of using `ng-disabled` with the ngAria module.
             *
             * The full list of directives that interface with ngAria:
             * * **ngModel**
             * * **ngShow**
             * * **ngHide**
             * * **ngClick**
             * * **ngDblclick**
             * * **ngMessages**
             * * **ngDisabled**
             *
             * Read the {@link guide/accessibility ngAria Developer Guide} for a thorough explanation of each
             * directive.
             *
             *
             * ## Dependencies
             * Requires the {@link ngAria} module to be installed.
             */
        this.$get = function() {
            return {
                config: function( key ) {
                    return config[ key ];
                },
                $$watchExpr: watchExpr
            };
        };
    }
    ngAriaModule.directive( 'ngShow', [ '$aria', function( $aria ) {
        return $aria.$$watchExpr( 'ngShow', 'aria-hidden', true );
} ] ).directive( 'ngHide', [ '$aria', function( $aria ) {
        return $aria.$$watchExpr( 'ngHide', 'aria-hidden', false );
} ] ).directive( 'ngModel', [ '$aria', function( $aria ) {
        function shouldAttachAttr( attr, normalizedAttr, elem ) {
            return $aria.config( normalizedAttr ) && !elem.attr( attr );
        }

        function getShape( attr, elem ) {
            var type = attr.type,
                role = attr.role;
            return ( ( type || role ) === 'checkbox' || role === 'menuitemcheckbox' ) ? 'checkbox' : ( ( type || role ) === 'radio' || role === 'menuitemradio' ) ? 'radio' : ( type === 'range' || role === 'progressbar' || role === 'slider' ) ? 'range' : ( type || role ) === 'textbox' || elem[ 0 ].nodeName === 'TEXTAREA' ? 'multiline' : '';
        }
        return {
            restrict: 'A',
            require: '?ngModel',
            link: function( scope, elem, attr, ngModel ) {
                var shape = getShape( attr, elem );
                var needsTabIndex = shouldAttachAttr( 'tabindex', 'tabindex', elem );

                function ngAriaWatchModelValue() {
                    return ngModel.$modelValue;
                }

                function getRadioReaction() {
                    if ( needsTabIndex ) {
                        needsTabIndex = false;
                        return function ngAriaRadioReaction( newVal ) {
                            var boolVal = newVal === attr.value;
                            elem.attr( 'aria-checked', boolVal );
                            elem.attr( 'tabindex', 0 - !boolVal );
                        };
                    } else {
                        return function ngAriaRadioReaction( newVal ) {
                            elem.attr( 'aria-checked', newVal === attr.value );
                        };
                    }
                }

                function ngAriaCheckboxReaction( newVal ) {
                    elem.attr( 'aria-checked', !!newVal );
                }
                switch ( shape ) {
                    case 'radio':
                    case 'checkbox':
                        if ( shouldAttachAttr( 'aria-checked', 'ariaChecked', elem ) ) {
                            scope.$watch( ngAriaWatchModelValue, shape === 'radio' ? getRadioReaction() : ngAriaCheckboxReaction );
                        }
                        break;
                    case 'range':
                        if ( $aria.config( 'ariaValue' ) ) {
                            if ( attr.min && !elem.attr( 'aria-valuemin' ) ) {
                                elem.attr( 'aria-valuemin', attr.min );
                            }
                            if ( attr.max && !elem.attr( 'aria-valuemax' ) ) {
                                elem.attr( 'aria-valuemax', attr.max );
                            }
                            if ( !elem.attr( 'aria-valuenow' ) ) {
                                scope.$watch( ngAriaWatchModelValue, function ngAriaValueNowReaction( newVal ) {
                                    elem.attr( 'aria-valuenow', newVal );
                                } );
                            }
                        }
                        break;
                    case 'multiline':
                        if ( shouldAttachAttr( 'aria-multiline', 'ariaMultiline', elem ) ) {
                            elem.attr( 'aria-multiline', true );
                        }
                        break;
                }
                if ( needsTabIndex ) {
                    elem.attr( 'tabindex', 0 );
                }
                if ( ngModel.$validators.required && shouldAttachAttr( 'aria-required', 'ariaRequired', elem ) ) {
                    scope.$watch( function ngAriaRequiredWatch() {
                        return ngModel.$error.required;
                    }, function ngAriaRequiredReaction( newVal ) {
                        elem.attr( 'aria-required', !!newVal );
                    } );
                }
                if ( shouldAttachAttr( 'aria-invalid', 'ariaInvalid', elem ) ) {
                    scope.$watch( function ngAriaInvalidWatch() {
                        return ngModel.$invalid;
                    }, function ngAriaInvalidReaction( newVal ) {
                        elem.attr( 'aria-invalid', !!newVal );
                    } );
                }
            }
        };
} ] ).directive( 'ngDisabled', [ '$aria', function( $aria ) {
        return $aria.$$watchExpr( 'ngDisabled', 'aria-disabled' );
} ] ).directive( 'ngMessages', function() {
        return {
            restrict: 'A',
            require: '?ngMessages',
            link: function( scope, elem, attr, ngMessages ) {
                if ( !elem.attr( 'aria-live' ) ) {
                    elem.attr( 'aria-live', 'assertive' );
                }
            }
        };
    } ).directive( 'ngClick', [ '$aria', function( $aria ) {
        return {
            restrict: 'A',
            link: function( scope, elem, attr ) {
                if ( $aria.config( 'tabindex' ) && !elem.attr( 'tabindex' ) ) {
                    elem.attr( 'tabindex', 0 );
                }
                if ( $aria.config( 'bindKeypress' ) && !elem.attr( 'ng-keypress' ) ) {
                    elem.on( 'keypress', function( event ) {
                        if ( event.keyCode === 32 || event.keyCode === 13 ) {
                            scope.$eval( attr.ngClick );
                        }
                    } );
                }
            }
        };
} ] ).directive( 'ngDblclick', [ '$aria', function( $aria ) {
        return function( scope, elem, attr ) {
            if ( $aria.config( 'tabindex' ) && !elem.attr( 'tabindex' ) ) {
                elem.attr( 'tabindex', 0 );
            }
        };
} ] );
} )( window, window.angular );
/**
 * An Angular module that gives you access to the browsers local storage
 * @version v0.1.5 - 2014-11-04
 * @link https://github.com/grevory/angular-local-storage
 * @author grevory <greg@gregpike.ca>
 * @license MIT License, http://www.opensource.org/licenses/MIT
 */
! function( a, b ) {
    "use strict";

    function c( a ) {
        return /^-?\d+\.?\d*$/.test( a.replace( /["']/g, "" ) )
    }
    var d = b.isDefined,
        e = b.isUndefined,
        f = b.isNumber,
        g = b.isObject,
        h = b.isArray,
        i = b.extend,
        j = b.toJson,
        k = b.fromJson,
        l = b.module( "LocalStorageModule", [] );
    l.provider( "localStorageService", function() {
        this.prefix = "ls", this.storageType = "localStorage", this.cookie = {
            expiry: 30,
            path: "/"
        }, this.notify = {
            setItem: !0,
            removeItem: !1
        }, this.setPrefix = function( a ) {
            return this.prefix = a, this
        }, this.setStorageType = function( a ) {
            return this.storageType = a, this
        }, this.setStorageCookie = function( a, b ) {
            return this.cookie = {
                expiry: a,
                path: b
            }, this
        }, this.setStorageCookieDomain = function( a ) {
            return this.cookie.domain = a, this
        }, this.setNotify = function( a, b ) {
            return this.notify = {
                setItem: a,
                removeItem: b
            }, this
        }, this.$get = [ "$rootScope", "$window", "$document", "$parse", function( a, b, l, m ) {
            var n, o = this,
                p = o.prefix,
                q = o.cookie,
                r = o.notify,
                s = o.storageType;
            l ? l[ 0 ] && ( l = l[ 0 ] ) : l = document, "." !== p.substr( -1 ) && ( p = p ? p + "." : "" );
            var t = function( a ) {
                    return p + a
                },
                u = function() {
                    try {
                        var c = s in b && null !== b[ s ],
                            d = t( "__" + Math.round( 1e7 * Math.random() ) );
                        return c && ( n = b[ s ], n.setItem( d, "" ), n.removeItem( d ) ), c
                    } catch ( e ) {
                        return s = "cookie", a.$broadcast( "LocalStorageModule.notification.error", e.message ), !1
                    }
                }(),
                v = function( b, c ) {
                    if ( e( c ) ? c = null : ( g( c ) || h( c ) || f( +c || c ) ) && ( c = j( c ) ), !u || "cookie" === o.storageType ) return u || a.$broadcast( "LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED" ), r.setItem && a.$broadcast( "LocalStorageModule.notification.setitem", {
                        key: b,
                        newvalue: c,
                        storageType: "cookie"
                    } ), B( b, c );
                    try {
                        ( g( c ) || h( c ) ) && ( c = j( c ) ), n && n.setItem( t( b ), c ), r.setItem && a.$broadcast( "LocalStorageModule.notification.setitem", {
                            key: b,
                            newvalue: c,
                            storageType: o.storageType
                        } )
                    } catch ( d ) {
                        return a.$broadcast( "LocalStorageModule.notification.error", d.message ), B( b, c )
                    }
                    return !0
                },
                w = function( b ) {
                    if ( !u || "cookie" === o.storageType ) return u || a.$broadcast( "LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED" ), C( b );
                    var d = n ? n.getItem( t( b ) ) : null;
                    return d && "null" !== d ? "{" === d.charAt( 0 ) || "[" === d.charAt( 0 ) || c( d ) ? k( d ) : d : null
                },
                x = function( b ) {
                    if ( !u || "cookie" === o.storageType ) return u || a.$broadcast( "LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED" ), r.removeItem && a.$broadcast( "LocalStorageModule.notification.removeitem", {
                        key: b,
                        storageType: "cookie"
                    } ), D( b );
                    try {
                        n.removeItem( t( b ) ), r.removeItem && a.$broadcast( "LocalStorageModule.notification.removeitem", {
                            key: b,
                            storageType: o.storageType
                        } )
                    } catch ( c ) {
                        return a.$broadcast( "LocalStorageModule.notification.error", c.message ), D( b )
                    }
                    return !0
                },
                y = function() {
                    if ( !u ) return a.$broadcast( "LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED" ), !1;
                    var b = p.length,
                        c = [];
                    for ( var d in n )
                        if ( d.substr( 0, b ) === p ) try {
                            c.push( d.substr( b ) )
                        } catch ( e ) {
                            return a.$broadcast( "LocalStorageModule.notification.error", e.Description ), []
                        }
                    return c
                },
                z = function( b ) {
                    b = b || "";
                    var c = p.slice( 0, -1 ),
                        d = new RegExp( c + "." + b );
                    if ( !u || "cookie" === o.storageType ) return u || a.$broadcast( "LocalStorageModule.notification.warning", "LOCAL_STORAGE_NOT_SUPPORTED" ), E();
                    var e = p.length;
                    for ( var f in n )
                        if ( d.test( f ) ) try {
                            x( f.substr( e ) )
                        } catch ( g ) {
                            return a.$broadcast( "LocalStorageModule.notification.error", g.message ), E()
                        }
                    return !0
                },
                A = function() {
                    try {
                        return b.navigator.cookieEnabled || "cookie" in l && ( l.cookie.length > 0 || ( l.cookie = "test" ).indexOf.call( l.cookie, "test" ) > -1 )
                    } catch ( c ) {
                        return a.$broadcast( "LocalStorageModule.notification.error", c.message ), !1
                    }
                }(),
                B = function( b, c ) {
                    if ( e( c ) ) return !1;
                    if ( ( h( c ) || g( c ) ) && ( c = j( c ) ), !A ) return a.$broadcast( "LocalStorageModule.notification.error", "COOKIES_NOT_SUPPORTED" ), !1;
                    try {
                        var d = "",
                            f = new Date,
                            i = "";
                        if ( null === c ? ( f.setTime( f.getTime() + -864e5 ), d = "; expires=" + f.toGMTString(), c = "" ) : 0 !== q.expiry && ( f.setTime( f.getTime() + 24 * q.expiry * 60 * 60 * 1e3 ), d = "; expires=" + f.toGMTString() ), b ) {
                            var k = "; path=" + q.path;
                            q.domain && ( i = "; domain=" + q.domain ), l.cookie = t( b ) + "=" + encodeURIComponent( c ) + d + k + i
                        }
                    } catch ( m ) {
                        return a.$broadcast( "LocalStorageModule.notification.error", m.message ), !1
                    }
                    return !0
                },
                C = function( b ) {
                    if ( !A ) return a.$broadcast( "LocalStorageModule.notification.error", "COOKIES_NOT_SUPPORTED" ), !1;
                    for ( var c = l.cookie && l.cookie.split( ";" ) || [], d = 0; d < c.length; d++ ) {
                        for ( var e = c[ d ];
                            " " === e.charAt( 0 ); ) e = e.substring( 1, e.length );
                        if ( 0 === e.indexOf( t( b ) + "=" ) ) {
                            var f = decodeURIComponent( e.substring( p.length + b.length + 1, e.length ) );
                            try {
                                var g = JSON.parse( f );
                                return k( g )
                            } catch ( h ) {
                                return f
                            }
                        }
                    }
                    return null
                },
                D = function( a ) {
                    B( a, null )
                },
                E = function() {
                    for ( var a = null, b = p.length, c = l.cookie.split( ";" ), d = 0; d < c.length; d++ ) {
                        for ( a = c[ d ];
                            " " === a.charAt( 0 ); ) a = a.substring( 1, a.length );
                        var e = a.substring( b, a.indexOf( "=" ) );
                        D( e )
                    }
                },
                F = function() {
                    return s
                },
                G = function( a, b, c, e ) {
                    e = e || b;
                    var f = w( e );
                    return null === f && d( c ) ? f = c : g( f ) && g( c ) && ( f = i( c, f ) ), m( b ).assign( a, f ), a.$watch( b, function( a ) {
                        v( e, a )
                    }, g( a[ b ] ) )
                },
                H = function() {
                    for ( var a = 0, c = b[ s ], d = 0; d < c.length; d++ ) 0 === c.key( d ).indexOf( p ) && a++;
                    return a
                };
            return {
                isSupported: u,
                getStorageType: F,
                set: v,
                add: v,
                get: w,
                keys: y,
                remove: x,
                clearAll: z,
                bind: G,
                deriveKey: t,
                length: H,
                cookie: {
                    isSupported: A,
                    set: B,
                    add: B,
                    get: C,
                    remove: D,
                    clearAll: E
                }
            }
        } ]
    } )
}( window, window.angular );
/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
( function( window, document, exportName, undefined ) {
    'use strict';
    var VENDOR_PREFIXES = [ '', 'webkit', 'moz', 'MS', 'ms', 'o' ];
    var TEST_ELEMENT = document.createElement( 'div' );
    var TYPE_FUNCTION = 'function';
    var round = Math.round;
    var abs = Math.abs;
    var now = Date.now;
    /**
     * set a timeout with a given scope
     * @param {Function} fn
     * @param {Number} timeout
     * @param {Object} context
     * @returns {number}
     */
    function setTimeoutContext( fn, timeout, context ) {
            return setTimeout( bindFn( fn, context ), timeout );
        }
        /**
         * if the argument is an array, we want to execute the fn on each entry
         * if it aint an array we don't want to do a thing.
         * this is used by all the methods that accept a single and array argument.
         * @param {*|Array} arg
         * @param {String} fn
         * @param {Object} [context]
         * @returns {Boolean}
         */
    function invokeArrayArg( arg, fn, context ) {
            if ( Array.isArray( arg ) ) {
                each( arg, context[ fn ], context );
                return true;
            }
            return false;
        }
        /**
         * walk objects and arrays
         * @param {Object} obj
         * @param {Function} iterator
         * @param {Object} context
         */
    function each( obj, iterator, context ) {
            var i;
            if ( !obj ) {
                return;
            }
            if ( obj.forEach ) {
                obj.forEach( iterator, context );
            } else if ( obj.length !== undefined ) {
                i = 0;
                while ( i < obj.length ) {
                    iterator.call( context, obj[ i ], i, obj );
                    i++;
                }
            } else {
                for ( i in obj ) {
                    obj.hasOwnProperty( i ) && iterator.call( context, obj[ i ], i, obj );
                }
            }
        }
        /**
         * extend object.
         * means that properties in dest will be overwritten by the ones in src.
         * @param {Object} dest
         * @param {Object} src
         * @param {Boolean} [merge]
         * @returns {Object} dest
         */
    function extend( dest, src, merge ) {
            var keys = Object.keys( src );
            var i = 0;
            while ( i < keys.length ) {
                if ( !merge || ( merge && dest[ keys[ i ] ] === undefined ) ) {
                    dest[ keys[ i ] ] = src[ keys[ i ] ];
                }
                i++;
            }
            return dest;
        }
        /**
         * merge the values from src in the dest.
         * means that properties that exist in dest will not be overwritten by src
         * @param {Object} dest
         * @param {Object} src
         * @returns {Object} dest
         */
    function merge( dest, src ) {
            return extend( dest, src, true );
        }
        /**
         * simple class inheritance
         * @param {Function} child
         * @param {Function} base
         * @param {Object} [properties]
         */
    function inherit( child, base, properties ) {
            var baseP = base.prototype,
                childP;
            childP = child.prototype = Object.create( baseP );
            childP.constructor = child;
            childP._super = baseP;
            if ( properties ) {
                extend( childP, properties );
            }
        }
        /**
         * simple function bind
         * @param {Function} fn
         * @param {Object} context
         * @returns {Function}
         */
    function bindFn( fn, context ) {
            return function boundFn() {
                return fn.apply( context, arguments );
            };
        }
        /**
         * let a boolean value also be a function that must return a boolean
         * this first item in args will be used as the context
         * @param {Boolean|Function} val
         * @param {Array} [args]
         * @returns {Boolean}
         */
    function boolOrFn( val, args ) {
            if ( typeof val == TYPE_FUNCTION ) {
                return val.apply( args ? args[ 0 ] || undefined : undefined, args );
            }
            return val;
        }
        /**
         * use the val2 when val1 is undefined
         * @param {*} val1
         * @param {*} val2
         * @returns {*}
         */
    function ifUndefined( val1, val2 ) {
            return ( val1 === undefined ) ? val2 : val1;
        }
        /**
         * addEventListener with multiple events at once
         * @param {EventTarget} target
         * @param {String} types
         * @param {Function} handler
         */
    function addEventListeners( target, types, handler ) {
            each( splitStr( types ), function( type ) {
                target.addEventListener( type, handler, false );
            } );
        }
        /**
         * removeEventListener with multiple events at once
         * @param {EventTarget} target
         * @param {String} types
         * @param {Function} handler
         */
    function removeEventListeners( target, types, handler ) {
            each( splitStr( types ), function( type ) {
                target.removeEventListener( type, handler, false );
            } );
        }
        /**
         * find if a node is in the given parent
         * @method hasParent
         * @param {HTMLElement} node
         * @param {HTMLElement} parent
         * @return {Boolean} found
         */
    function hasParent( node, parent ) {
            while ( node ) {
                if ( node == parent ) {
                    return true;
                }
                node = node.parentNode;
            }
            return false;
        }
        /**
         * small indexOf wrapper
         * @param {String} str
         * @param {String} find
         * @returns {Boolean} found
         */
    function inStr( str, find ) {
            return str.indexOf( find ) > -1;
        }
        /**
         * split string on whitespace
         * @param {String} str
         * @returns {Array} words
         */
    function splitStr( str ) {
            return str.trim().split( /\s+/g );
        }
        /**
         * find if a array contains the object using indexOf or a simple polyFill
         * @param {Array} src
         * @param {String} find
         * @param {String} [findByKey]
         * @return {Boolean|Number} false when not found, or the index
         */
    function inArray( src, find, findByKey ) {
            if ( src.indexOf && !findByKey ) {
                return src.indexOf( find );
            } else {
                var i = 0;
                while ( i < src.length ) {
                    if ( ( findByKey && src[ i ][ findByKey ] == find ) || ( !findByKey && src[ i ] === find ) ) {
                        return i;
                    }
                    i++;
                }
                return -1;
            }
        }
        /**
         * convert array-like objects to real arrays
         * @param {Object} obj
         * @returns {Array}
         */
    function toArray( obj ) {
            return Array.prototype.slice.call( obj, 0 );
        }
        /**
         * unique array with objects based on a key (like 'id') or just by the array's value
         * @param {Array} src [{id:1},{id:2},{id:1}]
         * @param {String} [key]
         * @param {Boolean} [sort=False]
         * @returns {Array} [{id:1},{id:2}]
         */
    function uniqueArray( src, key, sort ) {
            var results = [];
            var values = [];
            var i = 0;
            while ( i < src.length ) {
                var val = key ? src[ i ][ key ] : src[ i ];
                if ( inArray( values, val ) < 0 ) {
                    results.push( src[ i ] );
                }
                values[ i ] = val;
                i++;
            }
            if ( sort ) {
                if ( !key ) {
                    results = results.sort();
                } else {
                    results = results.sort( function sortUniqueArray( a, b ) {
                        return a[ key ] > b[ key ];
                    } );
                }
            }
            return results;
        }
        /**
         * get the prefixed property
         * @param {Object} obj
         * @param {String} property
         * @returns {String|Undefined} prefixed
         */
    function prefixed( obj, property ) {
            var prefix, prop;
            var camelProp = property[ 0 ].toUpperCase() + property.slice( 1 );
            var i = 0;
            while ( i < VENDOR_PREFIXES.length ) {
                prefix = VENDOR_PREFIXES[ i ];
                prop = ( prefix ) ? prefix + camelProp : property;
                if ( prop in obj ) {
                    return prop;
                }
                i++;
            }
            return undefined;
        }
        /**
         * get a unique id
         * @returns {number} uniqueId
         */
    var _uniqueId = 1;

    function uniqueId() {
            return _uniqueId++;
        }
        /**
         * get the window object of an element
         * @param {HTMLElement} element
         * @returns {DocumentView|Window}
         */
    function getWindowForElement( element ) {
        var doc = element.ownerDocument;
        return ( doc.defaultView || doc.parentWindow );
    }
    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
    var SUPPORT_TOUCH = ( 'ontouchstart' in window );
    var SUPPORT_POINTER_EVENTS = prefixed( window, 'PointerEvent' ) !== undefined;
    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test( navigator.userAgent );
    var INPUT_TYPE_TOUCH = 'touch';
    var INPUT_TYPE_PEN = 'pen';
    var INPUT_TYPE_MOUSE = 'mouse';
    var INPUT_TYPE_KINECT = 'kinect';
    var COMPUTE_INTERVAL = 25;
    var INPUT_START = 1;
    var INPUT_MOVE = 2;
    var INPUT_END = 4;
    var INPUT_CANCEL = 8;
    var DIRECTION_NONE = 1;
    var DIRECTION_LEFT = 2;
    var DIRECTION_RIGHT = 4;
    var DIRECTION_UP = 8;
    var DIRECTION_DOWN = 16;
    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
    var PROPS_XY = [ 'x', 'y' ];
    var PROPS_CLIENT_XY = [ 'clientX', 'clientY' ];
    /**
     * create new input type manager
     * @param {Manager} manager
     * @param {Function} callback
     * @returns {Input}
     * @constructor
     */
    function Input( manager, callback ) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.
        this.domHandler = function( ev ) {
            if ( boolOrFn( manager.options.enable, [ manager ] ) ) {
                self.handler( ev );
            }
        };
        this.init();
    }
    Input.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function() {},
        /**
         * bind the events
         */
        init: function() {
            this.evEl && addEventListeners( this.element, this.evEl, this.domHandler );
            this.evTarget && addEventListeners( this.target, this.evTarget, this.domHandler );
            this.evWin && addEventListeners( getWindowForElement( this.element ), this.evWin, this.domHandler );
        },
        /**
         * unbind the events
         */
        destroy: function() {
            this.evEl && removeEventListeners( this.element, this.evEl, this.domHandler );
            this.evTarget && removeEventListeners( this.target, this.evTarget, this.domHandler );
            this.evWin && removeEventListeners( getWindowForElement( this.element ), this.evWin, this.domHandler );
        }
    };
    /**
     * create new input type manager
     * called by the Manager constructor
     * @param {Hammer} manager
     * @returns {Input}
     */
    function createInputInstance( manager ) {
            var Type;
            var inputClass = manager.options.inputClass;
            if ( inputClass ) {
                Type = inputClass;
            } else if ( SUPPORT_POINTER_EVENTS ) {
                Type = PointerEventInput;
            } else if ( SUPPORT_ONLY_TOUCH ) {
                Type = TouchInput;
            } else if ( !SUPPORT_TOUCH ) {
                Type = MouseInput;
            } else {
                Type = TouchMouseInput;
            }
            return new( Type )( manager, inputHandler );
        }
        /**
         * handle input events
         * @param {Manager} manager
         * @param {String} eventType
         * @param {Object} input
         */
    function inputHandler( manager, eventType, input ) {
            var pointersLen = input.pointers.length;
            var changedPointersLen = input.changedPointers.length;
            var isFirst = ( eventType & INPUT_START && ( pointersLen - changedPointersLen === 0 ) );
            var isFinal = ( eventType & ( INPUT_END | INPUT_CANCEL ) && ( pointersLen - changedPointersLen === 0 ) );
            input.isFirst = !!isFirst;
            input.isFinal = !!isFinal;
            if ( isFirst ) {
                manager.session = {};
            }
            // source event is the normalized value of the domEvents
            // like 'touchstart, mouseup, pointerdown'
            input.eventType = eventType;
            // compute scale, rotation etc
            computeInputData( manager, input );
            // emit secret event
            manager.emit( 'hammer.input', input );
            manager.recognize( input );
            manager.session.prevInput = input;
        }
        /**
         * extend the data with some usable properties like scale, rotate, velocity etc
         * @param {Object} manager
         * @param {Object} input
         */
    function computeInputData( manager, input ) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        // store the first input to calculate the distance and direction
        if ( !session.firstInput ) {
            session.firstInput = simpleCloneInputData( input );
        }
        // to compute scale and rotation we need to store the multiple touches
        if ( pointersLength > 1 && !session.firstMultiple ) {
            session.firstMultiple = simpleCloneInputData( input );
        } else if ( pointersLength === 1 ) {
            session.firstMultiple = false;
        }
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter( pointers );
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle( offsetCenter, center );
        input.distance = getDistance( offsetCenter, center );
        computeDeltaXY( session, input );
        input.offsetDirection = getDirection( input.deltaX, input.deltaY );
        input.scale = firstMultiple ? getScale( firstMultiple.pointers, pointers ) : 1;
        input.rotation = firstMultiple ? getRotation( firstMultiple.pointers, pointers ) : 0;
        computeIntervalInputData( session, input );
        // find the correct target
        var target = manager.element;
        if ( hasParent( input.srcEvent.target, target ) ) {
            target = input.srcEvent.target;
        }
        input.target = target;
    }

    function computeDeltaXY( session, input ) {
            var center = input.center;
            var offset = session.offsetDelta || {};
            var prevDelta = session.prevDelta || {};
            var prevInput = session.prevInput || {};
            if ( input.eventType === INPUT_START || prevInput.eventType === INPUT_END ) {
                prevDelta = session.prevDelta = {
                    x: prevInput.deltaX || 0,
                    y: prevInput.deltaY || 0
                };
                offset = session.offsetDelta = {
                    x: center.x,
                    y: center.y
                };
            }
            input.deltaX = prevDelta.x + ( center.x - offset.x );
            input.deltaY = prevDelta.y + ( center.y - offset.y );
        }
        /**
         * velocity is calculated every x ms
         * @param {Object} session
         * @param {Object} input
         */
    function computeIntervalInputData( session, input ) {
            var last = session.lastInterval || input,
                deltaTime = input.timeStamp - last.timeStamp,
                velocity, velocityX, velocityY, direction;
            if ( input.eventType != INPUT_CANCEL && ( deltaTime > COMPUTE_INTERVAL || last.velocity === undefined ) ) {
                var deltaX = last.deltaX - input.deltaX;
                var deltaY = last.deltaY - input.deltaY;
                var v = getVelocity( deltaTime, deltaX, deltaY );
                velocityX = v.x;
                velocityY = v.y;
                velocity = ( abs( v.x ) > abs( v.y ) ) ? v.x : v.y;
                direction = getDirection( deltaX, deltaY );
                session.lastInterval = input;
            } else {
                // use latest velocity info if it doesn't overtake a minimum period
                velocity = last.velocity;
                velocityX = last.velocityX;
                velocityY = last.velocityY;
                direction = last.direction;
            }
            input.velocity = velocity;
            input.velocityX = velocityX;
            input.velocityY = velocityY;
            input.direction = direction;
        }
        /**
         * create a simple clone from the input used for storage of firstInput and firstMultiple
         * @param {Object} input
         * @returns {Object} clonedInputData
         */
    function simpleCloneInputData( input ) {
            // make a simple copy of the pointers because we will get a reference if we don't
            // we only need clientXY for the calculations
            var pointers = [];
            var i = 0;
            while ( i < input.pointers.length ) {
                pointers[ i ] = {
                    clientX: round( input.pointers[ i ].clientX ),
                    clientY: round( input.pointers[ i ].clientY )
                };
                i++;
            }
            return {
                timeStamp: now(),
                pointers: pointers,
                center: getCenter( pointers ),
                deltaX: input.deltaX,
                deltaY: input.deltaY
            };
        }
        /**
         * get the center of all the pointers
         * @param {Array} pointers
         * @return {Object} center contains `x` and `y` properties
         */
    function getCenter( pointers ) {
            var pointersLength = pointers.length;
            // no need to loop when only one touch
            if ( pointersLength === 1 ) {
                return {
                    x: round( pointers[ 0 ].clientX ),
                    y: round( pointers[ 0 ].clientY )
                };
            }
            var x = 0,
                y = 0,
                i = 0;
            while ( i < pointersLength ) {
                x += pointers[ i ].clientX;
                y += pointers[ i ].clientY;
                i++;
            }
            return {
                x: round( x / pointersLength ),
                y: round( y / pointersLength )
            };
        }
        /**
         * calculate the velocity between two points. unit is in px per ms.
         * @param {Number} deltaTime
         * @param {Number} x
         * @param {Number} y
         * @return {Object} velocity `x` and `y`
         */
    function getVelocity( deltaTime, x, y ) {
            return {
                x: x / deltaTime || 0,
                y: y / deltaTime || 0
            };
        }
        /**
         * get the direction between two points
         * @param {Number} x
         * @param {Number} y
         * @return {Number} direction
         */
    function getDirection( x, y ) {
            if ( x === y ) {
                return DIRECTION_NONE;
            }
            if ( abs( x ) >= abs( y ) ) {
                return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
            }
            return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
        }
        /**
         * calculate the absolute distance between two points
         * @param {Object} p1 {x, y}
         * @param {Object} p2 {x, y}
         * @param {Array} [props] containing x and y keys
         * @return {Number} distance
         */
    function getDistance( p1, p2, props ) {
            if ( !props ) {
                props = PROPS_XY;
            }
            var x = p2[ props[ 0 ] ] - p1[ props[ 0 ] ],
                y = p2[ props[ 1 ] ] - p1[ props[ 1 ] ];
            return Math.sqrt( ( x * x ) + ( y * y ) );
        }
        /**
         * calculate the angle between two coordinates
         * @param {Object} p1
         * @param {Object} p2
         * @param {Array} [props] containing x and y keys
         * @return {Number} angle
         */
    function getAngle( p1, p2, props ) {
            if ( !props ) {
                props = PROPS_XY;
            }
            var x = p2[ props[ 0 ] ] - p1[ props[ 0 ] ],
                y = p2[ props[ 1 ] ] - p1[ props[ 1 ] ];
            return Math.atan2( y, x ) * 180 / Math.PI;
        }
        /**
         * calculate the rotation degrees between two pointersets
         * @param {Array} start array of pointers
         * @param {Array} end array of pointers
         * @return {Number} rotation
         */
    function getRotation( start, end ) {
            return getAngle( end[ 1 ], end[ 0 ], PROPS_CLIENT_XY ) - getAngle( start[ 1 ], start[ 0 ], PROPS_CLIENT_XY );
        }
        /**
         * calculate the scale factor between two pointersets
         * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
         * @param {Array} start array of pointers
         * @param {Array} end array of pointers
         * @return {Number} scale
         */
    function getScale( start, end ) {
        return getDistance( end[ 0 ], end[ 1 ], PROPS_CLIENT_XY ) / getDistance( start[ 0 ], start[ 1 ], PROPS_CLIENT_XY );
    }
    var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
    };
    var MOUSE_ELEMENT_EVENTS = 'mousedown';
    var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
    /**
     * Mouse events input
     * @constructor
     * @extends Input
     */
    function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.allow = true; // used by Input.TouchMouse to disable mouse events
        this.pressed = false; // mousedown state
        Input.apply( this, arguments );
    }
    inherit( MouseInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function MEhandler( ev ) {
            var eventType = MOUSE_INPUT_MAP[ ev.type ];
            // on start we want to have the left mouse button down
            if ( eventType & INPUT_START && ev.button === 0 ) {
                this.pressed = true;
            }
            if ( eventType & INPUT_MOVE && ev.which !== 1 ) {
                eventType = INPUT_END;
            }
            // mouse must be down, and mouse events are allowed (see the TouchMouse input)
            if ( !this.pressed || !this.allow ) {
                return;
            }
            if ( eventType & INPUT_END ) {
                this.pressed = false;
            }
            this.callback( this.manager, eventType, {
                pointers: [ ev ],
                changedPointers: [ ev ],
                pointerType: INPUT_TYPE_MOUSE,
                srcEvent: ev
            } );
        }
    } );
    var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
    };
    // in IE10 the pointer types is defined as an enum
    var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
    };
    var POINTER_ELEMENT_EVENTS = 'pointerdown';
    var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';
    // IE10 has prefixed support, and case-sensitive
    if ( window.MSPointerEvent ) {
        POINTER_ELEMENT_EVENTS = 'MSPointerDown';
        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
    }
    /**
     * Pointer events input
     * @constructor
     * @extends Input
     */
    function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply( this, arguments );
        this.store = ( this.manager.session.pointerEvents = [] );
    }
    inherit( PointerEventInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function PEhandler( ev ) {
            var store = this.store;
            var removePointer = false;
            var eventTypeNormalized = ev.type.toLowerCase().replace( 'ms', '' );
            var eventType = POINTER_INPUT_MAP[ eventTypeNormalized ];
            var pointerType = IE10_POINTER_TYPE_ENUM[ ev.pointerType ] || ev.pointerType;
            var isTouch = ( pointerType == INPUT_TYPE_TOUCH );
            // get index of the event in the store
            var storeIndex = inArray( store, ev.pointerId, 'pointerId' );
            // start and mouse must be down
            if ( eventType & INPUT_START && ( ev.button === 0 || isTouch ) ) {
                if ( storeIndex < 0 ) {
                    store.push( ev );
                    storeIndex = store.length - 1;
                }
            } else if ( eventType & ( INPUT_END | INPUT_CANCEL ) ) {
                removePointer = true;
            }
            // it not found, so the pointer hasn't been down (so it's probably a hover)
            if ( storeIndex < 0 ) {
                return;
            }
            // update the event in the store
            store[ storeIndex ] = ev;
            this.callback( this.manager, eventType, {
                pointers: store,
                changedPointers: [ ev ],
                pointerType: pointerType,
                srcEvent: ev
            } );
            if ( removePointer ) {
                // remove from the store
                store.splice( storeIndex, 1 );
            }
        }
    } );
    var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };
    var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
    var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
    /**
     * Touch events input
     * @constructor
     * @extends Input
     */
    function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply( this, arguments );
    }
    inherit( SingleTouchInput, Input, {
        handler: function TEhandler( ev ) {
            var type = SINGLE_TOUCH_INPUT_MAP[ ev.type ];
            // should we handle the touch events?
            if ( type === INPUT_START ) {
                this.started = true;
            }
            if ( !this.started ) {
                return;
            }
            var touches = normalizeSingleTouches.call( this, ev, type );
            // when done, reset the started state
            if ( type & ( INPUT_END | INPUT_CANCEL ) && touches[ 0 ].length - touches[ 1 ].length === 0 ) {
                this.started = false;
            }
            this.callback( this.manager, type, {
                pointers: touches[ 0 ],
                changedPointers: touches[ 1 ],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            } );
        }
    } );
    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function normalizeSingleTouches( ev, type ) {
        var all = toArray( ev.touches );
        var changed = toArray( ev.changedTouches );
        if ( type & ( INPUT_END | INPUT_CANCEL ) ) {
            all = uniqueArray( all.concat( changed ), 'identifier', true );
        }
        return [ all, changed ];
    }
    var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };
    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
    /**
     * Multi-user touch events input
     * @constructor
     * @extends Input
     */
    function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply( this, arguments );
    }
    inherit( TouchInput, Input, {
        handler: function MTEhandler( ev ) {
            var type = TOUCH_INPUT_MAP[ ev.type ];
            var touches = getTouches.call( this, ev, type );
            if ( !touches ) {
                return;
            }
            this.callback( this.manager, type, {
                pointers: touches[ 0 ],
                changedPointers: touches[ 1 ],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            } );
        }
    } );
    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function getTouches( ev, type ) {
            var allTouches = toArray( ev.touches );
            var targetIds = this.targetIds;
            // when there is only one touch, the process can be simplified
            if ( type & ( INPUT_START | INPUT_MOVE ) && allTouches.length === 1 ) {
                targetIds[ allTouches[ 0 ].identifier ] = true;
                return [ allTouches, allTouches ];
            }
            var i,
                targetTouches,
                changedTouches = toArray( ev.changedTouches ),
                changedTargetTouches = [],
                target = this.target;
            // get target touches from touches
            targetTouches = allTouches.filter( function( touch ) {
                return hasParent( touch.target, target );
            } );
            // collect touches
            if ( type === INPUT_START ) {
                i = 0;
                while ( i < targetTouches.length ) {
                    targetIds[ targetTouches[ i ].identifier ] = true;
                    i++;
                }
            }
            // filter changed touches to only contain touches that exist in the collected target ids
            i = 0;
            while ( i < changedTouches.length ) {
                if ( targetIds[ changedTouches[ i ].identifier ] ) {
                    changedTargetTouches.push( changedTouches[ i ] );
                }
                // cleanup removed touches
                if ( type & ( INPUT_END | INPUT_CANCEL ) ) {
                    delete targetIds[ changedTouches[ i ].identifier ];
                }
                i++;
            }
            if ( !changedTargetTouches.length ) {
                return;
            }
            return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray( targetTouches.concat( changedTargetTouches ), 'identifier', true ),
        changedTargetTouches
    ];
        }
        /**
         * Combined touch and mouse input
         *
         * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
         * This because touch devices also emit mouse events while doing a touch.
         *
         * @constructor
         * @extends Input
         */
    function TouchMouseInput() {
        Input.apply( this, arguments );
        var handler = bindFn( this.handler, this );
        this.touch = new TouchInput( this.manager, handler );
        this.mouse = new MouseInput( this.manager, handler );
    }
    inherit( TouchMouseInput, Input, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function TMEhandler( manager, inputEvent, inputData ) {
            var isTouch = ( inputData.pointerType == INPUT_TYPE_TOUCH ),
                isMouse = ( inputData.pointerType == INPUT_TYPE_MOUSE );
            // when we're in a touch event, so  block all upcoming mouse events
            // most mobile browser also emit mouseevents, right after touchstart
            if ( isTouch ) {
                this.mouse.allow = false;
            } else if ( isMouse && !this.mouse.allow ) {
                return;
            }
            // reset the allowMouse when we're done
            if ( inputEvent & ( INPUT_END | INPUT_CANCEL ) ) {
                this.mouse.allow = true;
            }
            this.callback( manager, inputEvent, inputData );
        },
        /**
         * remove the event listeners
         */
        destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
        }
    } );
    var PREFIXED_TOUCH_ACTION = prefixed( TEST_ELEMENT.style, 'touchAction' );
    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;
    // magical touchAction value
    var TOUCH_ACTION_COMPUTE = 'compute';
    var TOUCH_ACTION_AUTO = 'auto';
    var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
    var TOUCH_ACTION_NONE = 'none';
    var TOUCH_ACTION_PAN_X = 'pan-x';
    var TOUCH_ACTION_PAN_Y = 'pan-y';
    /**
     * Touch Action
     * sets the touchAction property or uses the js alternative
     * @param {Manager} manager
     * @param {String} value
     * @constructor
     */
    function TouchAction( manager, value ) {
        this.manager = manager;
        this.set( value );
    }
    TouchAction.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function( value ) {
            // find out the touch-action by the event handlers
            if ( value == TOUCH_ACTION_COMPUTE ) {
                value = this.compute();
            }
            if ( NATIVE_TOUCH_ACTION ) {
                this.manager.element.style[ PREFIXED_TOUCH_ACTION ] = value;
            }
            this.actions = value.toLowerCase().trim();
        },
        /**
         * just re-set the touchAction value
         */
        update: function() {
            this.set( this.manager.options.touchAction );
        },
        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function() {
            var actions = [];
            each( this.manager.recognizers, function( recognizer ) {
                if ( boolOrFn( recognizer.options.enable, [ recognizer ] ) ) {
                    actions = actions.concat( recognizer.getTouchAction() );
                }
            } );
            return cleanTouchActions( actions.join( ' ' ) );
        },
        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function( input ) {
            // not needed with native support for the touchAction property
            if ( NATIVE_TOUCH_ACTION ) {
                return;
            }
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;
            // if the touch action did prevented once this session
            if ( this.manager.session.prevented ) {
                srcEvent.preventDefault();
                return;
            }
            var actions = this.actions;
            var hasNone = inStr( actions, TOUCH_ACTION_NONE );
            var hasPanY = inStr( actions, TOUCH_ACTION_PAN_Y );
            var hasPanX = inStr( actions, TOUCH_ACTION_PAN_X );
            if ( hasNone || ( hasPanY && direction & DIRECTION_HORIZONTAL ) || ( hasPanX && direction & DIRECTION_VERTICAL ) ) {
                return this.preventSrc( srcEvent );
            }
        },
        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function( srcEvent ) {
            this.manager.session.prevented = true;
            srcEvent.preventDefault();
        }
    };
    /**
     * when the touchActions are collected they are not a valid value, so we need to clean things up. *
     * @param {String} actions
     * @returns {*}
     */
    function cleanTouchActions( actions ) {
            // none
            if ( inStr( actions, TOUCH_ACTION_NONE ) ) {
                return TOUCH_ACTION_NONE;
            }
            var hasPanX = inStr( actions, TOUCH_ACTION_PAN_X );
            var hasPanY = inStr( actions, TOUCH_ACTION_PAN_Y );
            // pan-x and pan-y can be combined
            if ( hasPanX && hasPanY ) {
                return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
            }
            // pan-x OR pan-y
            if ( hasPanX || hasPanY ) {
                return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
            }
            // manipulation
            if ( inStr( actions, TOUCH_ACTION_MANIPULATION ) ) {
                return TOUCH_ACTION_MANIPULATION;
            }
            return TOUCH_ACTION_AUTO;
        }
        /**
         * Recognizer flow explained; *
         * All recognizers have the initial state of POSSIBLE when a input session starts.
         * The definition of a input session is from the first input until the last input, with all it's movement in it. *
         * Example session for mouse-input: mousedown -> mousemove -> mouseup
         *
         * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
         * which determines with state it should be.
         *
         * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
         * POSSIBLE to give it another change on the next cycle.
         *
         *               Possible
         *                  |
         *            +-----+---------------+
         *            |                     |
         *      +-----+-----+               |
         *      |           |               |
         *   Failed      Cancelled          |
         *                          +-------+------+
         *                          |              |
         *                      Recognized       Began
         *                                         |
         *                                      Changed
         *                                         |
         *                                  Ended/Recognized
         */
    var STATE_POSSIBLE = 1;
    var STATE_BEGAN = 2;
    var STATE_CHANGED = 4;
    var STATE_ENDED = 8;
    var STATE_RECOGNIZED = STATE_ENDED;
    var STATE_CANCELLED = 16;
    var STATE_FAILED = 32;
    /**
     * Recognizer
     * Every recognizer needs to extend from this class.
     * @constructor
     * @param {Object} options
     */
    function Recognizer( options ) {
        this.id = uniqueId();
        this.manager = null;
        this.options = merge( options || {}, this.defaults );
        // default is enable true
        this.options.enable = ifUndefined( this.options.enable, true );
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
    }
    Recognizer.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},
        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function( options ) {
            extend( this.options, options );
            // also update the touchAction, in case something changed about the directions/enabled state
            this.manager && this.manager.touchAction.update();
            return this;
        },
        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function( otherRecognizer ) {
            if ( invokeArrayArg( otherRecognizer, 'recognizeWith', this ) ) {
                return this;
            }
            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager( otherRecognizer, this );
            if ( !simultaneous[ otherRecognizer.id ] ) {
                simultaneous[ otherRecognizer.id ] = otherRecognizer;
                otherRecognizer.recognizeWith( this );
            }
            return this;
        },
        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function( otherRecognizer ) {
            if ( invokeArrayArg( otherRecognizer, 'dropRecognizeWith', this ) ) {
                return this;
            }
            otherRecognizer = getRecognizerByNameIfManager( otherRecognizer, this );
            delete this.simultaneous[ otherRecognizer.id ];
            return this;
        },
        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function( otherRecognizer ) {
            if ( invokeArrayArg( otherRecognizer, 'requireFailure', this ) ) {
                return this;
            }
            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager( otherRecognizer, this );
            if ( inArray( requireFail, otherRecognizer ) === -1 ) {
                requireFail.push( otherRecognizer );
                otherRecognizer.requireFailure( this );
            }
            return this;
        },
        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function( otherRecognizer ) {
            if ( invokeArrayArg( otherRecognizer, 'dropRequireFailure', this ) ) {
                return this;
            }
            otherRecognizer = getRecognizerByNameIfManager( otherRecognizer, this );
            var index = inArray( this.requireFail, otherRecognizer );
            if ( index > -1 ) {
                this.requireFail.splice( index, 1 );
            }
            return this;
        },
        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function() {
            return this.requireFail.length > 0;
        },
        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function( otherRecognizer ) {
            return !!this.simultaneous[ otherRecognizer.id ];
        },
        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function( input ) {
            var self = this;
            var state = this.state;

            function emit( withState ) {
                    self.manager.emit( self.options.event + ( withState ? stateStr( state ) : '' ), input );
                }
                // 'panstart' and 'panmove'
            if ( state < STATE_ENDED ) {
                emit( true );
            }
            emit(); // simple 'eventName' events
            // panend and pancancel
            if ( state >= STATE_ENDED ) {
                emit( true );
            }
        },
        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function( input ) {
            if ( this.canEmit() ) {
                return this.emit( input );
            }
            // it's failing anyway
            this.state = STATE_FAILED;
        },
        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function() {
            var i = 0;
            while ( i < this.requireFail.length ) {
                if ( !( this.requireFail[ i ].state & ( STATE_FAILED | STATE_POSSIBLE ) ) ) {
                    return false;
                }
                i++;
            }
            return true;
        },
        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function( inputData ) {
            // make a new copy of the inputData
            // so we can change the inputData without messing up the other recognizers
            var inputDataClone = extend( {}, inputData );
            // is is enabled and allow recognizing?
            if ( !boolOrFn( this.options.enable, [ this, inputDataClone ] ) ) {
                this.reset();
                this.state = STATE_FAILED;
                return;
            }
            // reset when we've reached the end
            if ( this.state & ( STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED ) ) {
                this.state = STATE_POSSIBLE;
            }
            this.state = this.process( inputDataClone );
            // the recognizer has recognized a gesture
            // so trigger an event
            if ( this.state & ( STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED ) ) {
                this.tryEmit( inputDataClone );
            }
        },
        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function( inputData ) {}, // jshint ignore:line
        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function() {},
        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function() {}
    };
    /**
     * get a usable string, used as event postfix
     * @param {Const} state
     * @returns {String} state
     */
    function stateStr( state ) {
            if ( state & STATE_CANCELLED ) {
                return 'cancel';
            } else if ( state & STATE_ENDED ) {
                return 'end';
            } else if ( state & STATE_CHANGED ) {
                return 'move';
            } else if ( state & STATE_BEGAN ) {
                return 'start';
            }
            return '';
        }
        /**
         * direction cons to string
         * @param {Const} direction
         * @returns {String}
         */
    function directionStr( direction ) {
            if ( direction == DIRECTION_DOWN ) {
                return 'down';
            } else if ( direction == DIRECTION_UP ) {
                return 'up';
            } else if ( direction == DIRECTION_LEFT ) {
                return 'left';
            } else if ( direction == DIRECTION_RIGHT ) {
                return 'right';
            }
            return '';
        }
        /**
         * get a recognizer by name if it is bound to a manager
         * @param {Recognizer|String} otherRecognizer
         * @param {Recognizer} recognizer
         * @returns {Recognizer}
         */
    function getRecognizerByNameIfManager( otherRecognizer, recognizer ) {
            var manager = recognizer.manager;
            if ( manager ) {
                return manager.get( otherRecognizer );
            }
            return otherRecognizer;
        }
        /**
         * This recognizer is just used as a base for the simple attribute recognizers.
         * @constructor
         * @extends Recognizer
         */
    function AttrRecognizer() {
        Recognizer.apply( this, arguments );
    }
    inherit( AttrRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
            /**
             * @type {Number}
             * @default 1
             */
            pointers: 1
        },
        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function( input ) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
        },
        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function( input ) {
            var state = this.state;
            var eventType = input.eventType;
            var isRecognized = state & ( STATE_BEGAN | STATE_CHANGED );
            var isValid = this.attrTest( input );
            // on cancel input and we've recognized before, return STATE_CANCELLED
            if ( isRecognized && ( eventType & INPUT_CANCEL || !isValid ) ) {
                return state | STATE_CANCELLED;
            } else if ( isRecognized || isValid ) {
                if ( eventType & INPUT_END ) {
                    return state | STATE_ENDED;
                } else if ( !( state & STATE_BEGAN ) ) {
                    return STATE_BEGAN;
                }
                return state | STATE_CHANGED;
            }
            return STATE_FAILED;
        }
    } );
    /**
     * Pan
     * Recognized when the pointer is down and moved in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function PanRecognizer() {
        AttrRecognizer.apply( this, arguments );
        this.pX = null;
        this.pY = null;
    }
    inherit( PanRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
            event: 'pan',
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
        },
        getTouchAction: function() {
            var direction = this.options.direction;
            var actions = [];
            if ( direction & DIRECTION_HORIZONTAL ) {
                actions.push( TOUCH_ACTION_PAN_Y );
            }
            if ( direction & DIRECTION_VERTICAL ) {
                actions.push( TOUCH_ACTION_PAN_X );
            }
            return actions;
        },
        directionTest: function( input ) {
            var options = this.options;
            var hasMoved = true;
            var distance = input.distance;
            var direction = input.direction;
            var x = input.deltaX;
            var y = input.deltaY;
            // lock to axis?
            if ( !( direction & options.direction ) ) {
                if ( options.direction & DIRECTION_HORIZONTAL ) {
                    direction = ( x === 0 ) ? DIRECTION_NONE : ( x < 0 ) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                    hasMoved = x != this.pX;
                    distance = Math.abs( input.deltaX );
                } else {
                    direction = ( y === 0 ) ? DIRECTION_NONE : ( y < 0 ) ? DIRECTION_UP : DIRECTION_DOWN;
                    hasMoved = y != this.pY;
                    distance = Math.abs( input.deltaY );
                }
            }
            input.direction = direction;
            return hasMoved && distance > options.threshold && direction & options.direction;
        },
        attrTest: function( input ) {
            return AttrRecognizer.prototype.attrTest.call( this, input ) && ( this.state & STATE_BEGAN || ( !( this.state & STATE_BEGAN ) && this.directionTest( input ) ) );
        },
        emit: function( input ) {
            this.pX = input.deltaX;
            this.pY = input.deltaY;
            var direction = directionStr( input.direction );
            if ( direction ) {
                this.manager.emit( this.options.event + direction, input );
            }
            this._super.emit.call( this, input );
        }
    } );
    /**
     * Pinch
     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
     * @constructor
     * @extends AttrRecognizer
     */
    function PinchRecognizer() {
        AttrRecognizer.apply( this, arguments );
    }
    inherit( PinchRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
            event: 'pinch',
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function() {
            return [ TOUCH_ACTION_NONE ];
        },
        attrTest: function( input ) {
            return this._super.attrTest.call( this, input ) && ( Math.abs( input.scale - 1 ) > this.options.threshold || this.state & STATE_BEGAN );
        },
        emit: function( input ) {
            this._super.emit.call( this, input );
            if ( input.scale !== 1 ) {
                var inOut = input.scale < 1 ? 'in' : 'out';
                this.manager.emit( this.options.event + inOut, input );
            }
        }
    } );
    /**
     * Press
     * Recognized when the pointer is down for x ms without any movement.
     * @constructor
     * @extends Recognizer
     */
    function PressRecognizer() {
        Recognizer.apply( this, arguments );
        this._timer = null;
        this._input = null;
    }
    inherit( PressRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
            event: 'press',
            pointers: 1,
            time: 500, // minimal time of the pointer to be pressed
            threshold: 5 // a minimal movement is ok, but keep it low
        },
        getTouchAction: function() {
            return [ TOUCH_ACTION_AUTO ];
        },
        process: function( input ) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;
            this._input = input;
            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if ( !validMovement || !validPointers || ( input.eventType & ( INPUT_END | INPUT_CANCEL ) && !validTime ) ) {
                this.reset();
            } else if ( input.eventType & INPUT_START ) {
                this.reset();
                this._timer = setTimeoutContext( function() {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                }, options.time, this );
            } else if ( input.eventType & INPUT_END ) {
                return STATE_RECOGNIZED;
            }
            return STATE_FAILED;
        },
        reset: function() {
            clearTimeout( this._timer );
        },
        emit: function( input ) {
            if ( this.state !== STATE_RECOGNIZED ) {
                return;
            }
            if ( input && ( input.eventType & INPUT_END ) ) {
                this.manager.emit( this.options.event + 'up', input );
            } else {
                this._input.timeStamp = now();
                this.manager.emit( this.options.event, this._input );
            }
        }
    } );
    /**
     * Rotate
     * Recognized when two or more pointer are moving in a circular motion.
     * @constructor
     * @extends AttrRecognizer
     */
    function RotateRecognizer() {
        AttrRecognizer.apply( this, arguments );
    }
    inherit( RotateRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
            event: 'rotate',
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function() {
            return [ TOUCH_ACTION_NONE ];
        },
        attrTest: function( input ) {
            return this._super.attrTest.call( this, input ) && ( Math.abs( input.rotation ) > this.options.threshold || this.state & STATE_BEGAN );
        }
    } );
    /**
     * Swipe
     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function SwipeRecognizer() {
        AttrRecognizer.apply( this, arguments );
    }
    inherit( SwipeRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
            event: 'swipe',
            threshold: 10,
            velocity: 0.65,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
        },
        getTouchAction: function() {
            return PanRecognizer.prototype.getTouchAction.call( this );
        },
        attrTest: function( input ) {
            var direction = this.options.direction;
            var velocity;
            if ( direction & ( DIRECTION_HORIZONTAL | DIRECTION_VERTICAL ) ) {
                velocity = input.velocity;
            } else if ( direction & DIRECTION_HORIZONTAL ) {
                velocity = input.velocityX;
            } else if ( direction & DIRECTION_VERTICAL ) {
                velocity = input.velocityY;
            }
            return this._super.attrTest.call( this, input ) && direction & input.direction && input.distance > this.options.threshold && abs( velocity ) > this.options.velocity && input.eventType & INPUT_END;
        },
        emit: function( input ) {
            var direction = directionStr( input.direction );
            if ( direction ) {
                this.manager.emit( this.options.event + direction, input );
            }
            this.manager.emit( this.options.event, input );
        }
    } );
    /**
     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
     * between the given interval and position. The delay option can be used to recognize multi-taps without firing
     * a single tap.
     *
     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
     * multi-taps being recognized.
     * @constructor
     * @extends Recognizer
     */
    function TapRecognizer() {
        Recognizer.apply( this, arguments );
        // previous time and center,
        // used for tap counting
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
    }
    inherit( TapRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
            event: 'tap',
            pointers: 1,
            taps: 1,
            interval: 300, // max time between the multi-tap taps
            time: 250, // max time of the pointer to be down (like finger on the screen)
            threshold: 2, // a minimal movement is ok, but keep it low
            posThreshold: 10 // a multi-tap can be a bit off the initial position
        },
        getTouchAction: function() {
            return [ TOUCH_ACTION_MANIPULATION ];
        },
        process: function( input ) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;
            this.reset();
            if ( ( input.eventType & INPUT_START ) && ( this.count === 0 ) ) {
                return this.failTimeout();
            }
            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if ( validMovement && validTouchTime && validPointers ) {
                if ( input.eventType != INPUT_END ) {
                    return this.failTimeout();
                }
                var validInterval = this.pTime ? ( input.timeStamp - this.pTime < options.interval ) : true;
                var validMultiTap = !this.pCenter || getDistance( this.pCenter, input.center ) < options.posThreshold;
                this.pTime = input.timeStamp;
                this.pCenter = input.center;
                if ( !validMultiTap || !validInterval ) {
                    this.count = 1;
                } else {
                    this.count += 1;
                }
                this._input = input;
                // if tap count matches we have recognized it,
                // else it has began recognizing...
                var tapCount = this.count % options.taps;
                if ( tapCount === 0 ) {
                    // no failing requirements, immediately trigger the tap event
                    // or wait as long as the multitap interval to trigger
                    if ( !this.hasRequireFailures() ) {
                        return STATE_RECOGNIZED;
                    } else {
                        this._timer = setTimeoutContext( function() {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options.interval, this );
                        return STATE_BEGAN;
                    }
                }
            }
            return STATE_FAILED;
        },
        failTimeout: function() {
            this._timer = setTimeoutContext( function() {
                this.state = STATE_FAILED;
            }, this.options.interval, this );
            return STATE_FAILED;
        },
        reset: function() {
            clearTimeout( this._timer );
        },
        emit: function() {
            if ( this.state == STATE_RECOGNIZED ) {
                this._input.tapCount = this.count;
                this.manager.emit( this.options.event, this._input );
            }
        }
    } );
    /**
     * Simple way to create an manager with a default set of recognizers.
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Hammer( element, options ) {
            options = options || {};
            options.recognizers = ifUndefined( options.recognizers, Hammer.defaults.preset );
            return new Manager( element, options );
        }
        /**
         * @const {string}
         */
    Hammer.VERSION = '2.0.4';
    /**
     * default settings
     * @namespace
     */
    Hammer.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: false,
        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: TOUCH_ACTION_COMPUTE,
        /**
         * @type {Boolean}
         * @default true
         */
        enable: true,
        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,
        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,
        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [ RotateRecognizer, {
                enable: false
            } ],
        [ PinchRecognizer, {
                enable: false
            }, [ 'rotate' ] ],
        [ SwipeRecognizer, {
                direction: DIRECTION_HORIZONTAL
            } ],
        [ PanRecognizer, {
                direction: DIRECTION_HORIZONTAL
            }, [ 'swipe' ] ],
        [ TapRecognizer ],
        [ TapRecognizer, {
                event: 'doubletap',
                taps: 2
            }, [ 'tap' ] ],
        [ PressRecognizer ]
    ],
        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
            /**
             * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userSelect: 'none',
            /**
             * Disable the Windows Phone grippers when pressing an element.
             * @type {String}
             * @default 'none'
             */
            touchSelect: 'none',
            /**
             * Disables the default callout shown when you touch and hold a touch target.
             * On iOS, when you touch and hold a touch target such as a link, Safari displays
             * a callout containing information about the link. This property allows you to disable that callout.
             * @type {String}
             * @default 'none'
             */
            touchCallout: 'none',
            /**
             * Specifies whether zooming is enabled. Used by IE10>
             * @type {String}
             * @default 'none'
             */
            contentZooming: 'none',
            /**
             * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userDrag: 'none',
            /**
             * Overrides the highlight color shown when the user taps a link or a JavaScript
             * clickable element in iOS. This property obeys the alpha value, if specified.
             * @type {String}
             * @default 'rgba(0,0,0,0)'
             */
            tapHighlightColor: 'rgba(0,0,0,0)'
        }
    };
    var STOP = 1;
    var FORCED_STOP = 2;
    /**
     * Manager
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Manager( element, options ) {
        options = options || {};
        this.options = merge( options, Hammer.defaults );
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.element = element;
        this.input = createInputInstance( this );
        this.touchAction = new TouchAction( this, this.options.touchAction );
        toggleCssProps( this, true );
        each( options.recognizers, function( item ) {
            var recognizer = this.add( new( item[ 0 ] )( item[ 1 ] ) );
            item[ 2 ] && recognizer.recognizeWith( item[ 2 ] );
            item[ 3 ] && recognizer.requireFailure( item[ 3 ] );
        }, this );
    }
    Manager.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function( options ) {
            extend( this.options, options );
            // Options that need a little more setup
            if ( options.touchAction ) {
                this.touchAction.update();
            }
            if ( options.inputTarget ) {
                // Clean up existing event listeners and reinitialize
                this.input.destroy();
                this.input.target = options.inputTarget;
                this.input.init();
            }
            return this;
        },
        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function( force ) {
            this.session.stopped = force ? FORCED_STOP : STOP;
        },
        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function( inputData ) {
            var session = this.session;
            if ( session.stopped ) {
                return;
            }
            // run the touch-action polyfill
            this.touchAction.preventDefaults( inputData );
            var recognizer;
            var recognizers = this.recognizers;
            // this holds the recognizer that is being recognized.
            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
            // if no recognizer is detecting a thing, it is set to `null`
            var curRecognizer = session.curRecognizer;
            // reset when the last recognizer is recognized
            // or when we're in a new session
            if ( !curRecognizer || ( curRecognizer && curRecognizer.state & STATE_RECOGNIZED ) ) {
                curRecognizer = session.curRecognizer = null;
            }
            var i = 0;
            while ( i < recognizers.length ) {
                recognizer = recognizers[ i ];
                // find out if we are allowed try to recognize the input for this one.
                // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                //      that is being recognized.
                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                //      this can be setup with the `recognizeWith()` method on the recognizer.
                if ( session.stopped !== FORCED_STOP && ( // 1
                        !curRecognizer || recognizer == curRecognizer || // 2
                        recognizer.canRecognizeWith( curRecognizer ) ) ) { // 3
                    recognizer.recognize( inputData );
                } else {
                    recognizer.reset();
                }
                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                // current active recognizer. but only if we don't already have an active recognizer
                if ( !curRecognizer && recognizer.state & ( STATE_BEGAN | STATE_CHANGED | STATE_ENDED ) ) {
                    curRecognizer = session.curRecognizer = recognizer;
                }
                i++;
            }
        },
        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function( recognizer ) {
            if ( recognizer instanceof Recognizer ) {
                return recognizer;
            }
            var recognizers = this.recognizers;
            for ( var i = 0; i < recognizers.length; i++ ) {
                if ( recognizers[ i ].options.event == recognizer ) {
                    return recognizers[ i ];
                }
            }
            return null;
        },
        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function( recognizer ) {
            if ( invokeArrayArg( recognizer, 'add', this ) ) {
                return this;
            }
            // remove existing
            var existing = this.get( recognizer.options.event );
            if ( existing ) {
                this.remove( existing );
            }
            this.recognizers.push( recognizer );
            recognizer.manager = this;
            this.touchAction.update();
            return recognizer;
        },
        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function( recognizer ) {
            if ( invokeArrayArg( recognizer, 'remove', this ) ) {
                return this;
            }
            var recognizers = this.recognizers;
            recognizer = this.get( recognizer );
            recognizers.splice( inArray( recognizers, recognizer ), 1 );
            this.touchAction.update();
            return this;
        },
        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function( events, handler ) {
            var handlers = this.handlers;
            each( splitStr( events ), function( event ) {
                handlers[ event ] = handlers[ event ] || [];
                handlers[ event ].push( handler );
            } );
            return this;
        },
        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function( events, handler ) {
            var handlers = this.handlers;
            each( splitStr( events ), function( event ) {
                if ( !handler ) {
                    delete handlers[ event ];
                } else {
                    handlers[ event ].splice( inArray( handlers[ event ], handler ), 1 );
                }
            } );
            return this;
        },
        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function( event, data ) {
            // we also want to trigger dom events
            if ( this.options.domEvents ) {
                triggerDomEvent( event, data );
            }
            // no handlers, so skip it all
            var handlers = this.handlers[ event ] && this.handlers[ event ].slice();
            if ( !handlers || !handlers.length ) {
                return;
            }
            data.type = event;
            data.preventDefault = function() {
                data.srcEvent.preventDefault();
            };
            var i = 0;
            while ( i < handlers.length ) {
                handlers[ i ]( data );
                i++;
            }
        },
        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function() {
            this.element && toggleCssProps( this, false );
            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
        }
    };
    /**
     * add/remove the css properties as defined in manager.options.cssProps
     * @param {Manager} manager
     * @param {Boolean} add
     */
    function toggleCssProps( manager, add ) {
            var element = manager.element;
            each( manager.options.cssProps, function( value, name ) {
                element.style[ prefixed( element.style, name ) ] = add ? value : '';
            } );
        }
        /**
         * trigger dom event
         * @param {String} event
         * @param {Object} data
         */
    function triggerDomEvent( event, data ) {
        var gestureEvent = document.createEvent( 'Event' );
        gestureEvent.initEvent( event, true, true );
        gestureEvent.gesture = data;
        data.target.dispatchEvent( gestureEvent );
    }
    extend( Hammer, {
        INPUT_START: INPUT_START,
        INPUT_MOVE: INPUT_MOVE,
        INPUT_END: INPUT_END,
        INPUT_CANCEL: INPUT_CANCEL,
        STATE_POSSIBLE: STATE_POSSIBLE,
        STATE_BEGAN: STATE_BEGAN,
        STATE_CHANGED: STATE_CHANGED,
        STATE_ENDED: STATE_ENDED,
        STATE_RECOGNIZED: STATE_RECOGNIZED,
        STATE_CANCELLED: STATE_CANCELLED,
        STATE_FAILED: STATE_FAILED,
        DIRECTION_NONE: DIRECTION_NONE,
        DIRECTION_LEFT: DIRECTION_LEFT,
        DIRECTION_RIGHT: DIRECTION_RIGHT,
        DIRECTION_UP: DIRECTION_UP,
        DIRECTION_DOWN: DIRECTION_DOWN,
        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL: DIRECTION_VERTICAL,
        DIRECTION_ALL: DIRECTION_ALL,
        Manager: Manager,
        Input: Input,
        TouchAction: TouchAction,
        TouchInput: TouchInput,
        MouseInput: MouseInput,
        PointerEventInput: PointerEventInput,
        TouchMouseInput: TouchMouseInput,
        SingleTouchInput: SingleTouchInput,
        Recognizer: Recognizer,
        AttrRecognizer: AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each: each,
        merge: merge,
        extend: extend,
        inherit: inherit,
        bindFn: bindFn,
        prefixed: prefixed
    } );
    if ( typeof define == TYPE_FUNCTION && define.amd ) {
        define( function() {
            return Hammer;
        } );
    } else if ( typeof module != 'undefined' && module.exports ) {
        module.exports = Hammer;
    } else {
        window[ exportName ] = Hammer;
    }
} )( window, document, 'Hammer' );
/*!
 * Angular Material Design
 * https://github.com/angular/material
 * @license MIT
 * v0.6.1
 */
angular.module( 'ngMaterial', [ "ng", "ngAnimate", "ngAria", "material.core", "material.components.backdrop", "material.components.bottomSheet", "material.components.button", "material.components.card", "material.components.checkbox", "material.components.content", "material.components.dialog", "material.components.divider", "material.components.icon", "material.components.list", "material.components.progressCircular", "material.components.progressLinear", "material.components.radioButton", "material.components.sidenav", "material.components.slider", "material.components.sticky", "material.components.subheader", "material.components.swipe", "material.components.switch", "material.components.tabs", "material.components.textField", "material.components.toolbar", "material.components.toast", "material.components.tooltip", "material.components.whiteframe" ] );
( function() {
    'use strict';
    /**
     * Initialization function that validates environment
     * requirements.
     */
    angular.module( 'material.core', [] ).run( MdCoreInitialize ).config( MdCoreConfigure );

    function MdCoreInitialize() {
        if ( typeof Hammer === 'undefined' ) {
            throw new Error( 'ngMaterial requires HammerJS to be preloaded.' );
        }
    }

    function MdCoreConfigure( $provide ) {
        $provide.decorator( '$$rAF', [ '$delegate', '$rootScope', rAFDecorator ] );

        function rAFDecorator( $$rAF, $rootScope ) {
            /**
             * Use this to debounce events that come in often.
             * The debounced function will always use the *last* invocation before the
             * coming frame.
             *
             * For example, window resize events that fire many times a second:
             * If we set to use an raf-debounced callback on window resize, then
             * our callback will only be fired once per frame, with the last resize
             * event that happened before that frame.
             *
             * @param {function} callback function to debounce
             */
            $$rAF.debounce = function( cb ) {
                var queueArgs, alreadyQueued, queueCb, context;
                return function debounced() {
                    queueArgs = arguments;
                    context = this;
                    queueCb = cb;
                    if ( !alreadyQueued ) {
                        alreadyQueued = true;
                        $$rAF( function() {
                            queueCb.apply( context, queueArgs );
                            alreadyQueued = false;
                        } );
                    }
                };
            };
            return $$rAF;
        }
    }
    MdCoreConfigure.$inject = [ "$provide" ];
} )();
( function() {
    'use strict';
    angular.module( 'material.core' ).factory( '$mdConstant', MdConstantFactory );

    function MdConstantFactory( $$rAF, $sniffer ) {
        var webkit = /webkit/i.test( $sniffer.vendorPrefix );

        function vendorProperty( name ) {
            return webkit ? ( 'webkit' + name.charAt( 0 ).toUpperCase() + name.substring( 1 ) ) : name;
        }
        return {
            KEY_CODE: {
                ENTER: 13,
                ESCAPE: 27,
                SPACE: 32,
                LEFT_ARROW: 37,
                UP_ARROW: 38,
                RIGHT_ARROW: 39,
                DOWN_ARROW: 40
            },
            CSS: {
                /* Constants */
                TRANSITIONEND: 'transitionend' + ( webkit ? ' webkitTransitionEnd' : '' ),
                ANIMATIONEND: 'animationend' + ( webkit ? ' webkitAnimationEnd' : '' ),
                TRANSFORM: vendorProperty( 'transform' ),
                TRANSITION: vendorProperty( 'transition' ),
                TRANSITION_DURATION: vendorProperty( 'transitionDuration' ),
                ANIMATION_PLAY_STATE: vendorProperty( 'animationPlayState' ),
                ANIMATION_DURATION: vendorProperty( 'animationDuration' ),
                ANIMATION_NAME: vendorProperty( 'animationName' ),
                ANIMATION_TIMING: vendorProperty( 'animationTimingFunction' ),
                ANIMATION_DIRECTION: vendorProperty( 'animationDirection' )
            },
            MEDIA: {
                'sm': '(max-width: 600px)',
                'gt-sm': '(min-width: 600px)',
                'md': '(min-width: 600px) and (max-width: 960px)',
                'gt-md': '(min-width: 960px)',
                'lg': '(min-width: 960px) and (max-width: 1200px)',
                'gt-lg': '(min-width: 1200px)'
            }
        };
    }
    MdConstantFactory.$inject = [ "$$rAF", "$sniffer" ];
} )();
( function() {
    'use strict';
    /* 
     * This var has to be outside the angular factory, otherwise when
     * there are multiple material apps on the same page, each app
     * will create its own instance of this array and the app's IDs
     * will not be unique.
     */
    var nextUniqueId = [ '0', '0', '0' ];
    angular.module( 'material.core' ).factory( '$mdUtil', [ '$cacheFactory', function( $cacheFactory ) {
        var Util;
        return Util = {
            now: window.performance ? angular.bind( window.performance, window.performance.now ) : Date.now,
            /**
             * Publish the iterator facade to easily support iteration and accessors
             * @see iterator below
             */
            iterator: iterator,
            /**
             * @see cacheFactory below
             */
            cacheFactory: cacheFactory,
            // Returns a function, that, as long as it continues to be invoked, will not
            // be triggered. The function will be called after it stops being called for
            // N milliseconds. If `immediate` is passed, trigger the function on the
            // leading edge, instead of the trailing.
            debounce: function debounce( func, wait, immediate ) {
                var timeout;
                return function debounced() {
                    var context = this,
                        args = arguments;
                    clearTimeout( timeout );
                    timeout = setTimeout( function() {
                        timeout = null;
                        if ( !immediate ) func.apply( context, args );
                    }, wait );
                    if ( immediate && !timeout ) func.apply( context, args );
                };
            },
            // Returns a function that can only be triggered every `delay` milliseconds.
            // In other words, the function will not be called unless it has been more
            // than `delay` milliseconds since the last call.
            throttle: function throttle( func, delay ) {
                var recent;
                return function throttled() {
                    var context = this;
                    var args = arguments;
                    var now = Util.now();
                    if ( !recent || recent - now > delay ) {
                        func.apply( context, args );
                        recent = now;
                    }
                };
            },
            /**
             * nextUid, from angular.js.
             * A consistent way of creating unique IDs in angular. The ID is a sequence of alpha numeric
             * characters such as '012ABC'. The reason why we are not using simply a number counter is that
             * the number string gets longer over time, and it can also overflow, where as the nextId
             * will grow much slower, it is a string, and it will never overflow.
             *
             * @returns an unique alpha-numeric string
             */
            nextUid: function() {
                var index = nextUniqueId.length;
                var digit;
                while ( index ) {
                    index--;
                    digit = nextUniqueId[ index ].charCodeAt( 0 );
                    if ( digit == 57 /*'9'*/ ) {
                        nextUniqueId[ index ] = 'A';
                        return nextUniqueId.join( '' );
                    }
                    if ( digit == 90 /*'Z'*/ ) {
                        nextUniqueId[ index ] = '0';
                    } else {
                        nextUniqueId[ index ] = String.fromCharCode( digit + 1 );
                        return nextUniqueId.join( '' );
                    }
                }
                nextUniqueId.unshift( '0' );
                return nextUniqueId.join( '' );
            },
            // Stop watchers and events from firing on a scope without destroying it,
            // by disconnecting it from its parent and its siblings' linked lists.
            disconnectScope: function disconnectScope( scope ) {
                if ( !scope ) return;
                // we can't destroy the root scope or a scope that has been already destroyed
                if ( scope.$root === scope ) return;
                if ( scope.$$destroyed ) return;
                var parent = scope.$parent;
                scope.$$disconnected = true;
                // See Scope.$destroy
                if ( parent.$$childHead === scope ) parent.$$childHead = scope.$$nextSibling;
                if ( parent.$$childTail === scope ) parent.$$childTail = scope.$$prevSibling;
                if ( scope.$$prevSibling ) scope.$$prevSibling.$$nextSibling = scope.$$nextSibling;
                if ( scope.$$nextSibling ) scope.$$nextSibling.$$prevSibling = scope.$$prevSibling;
                scope.$$nextSibling = scope.$$prevSibling = null;
            },
            // Undo the effects of disconnectScope above.
            reconnectScope: function reconnectScope( scope ) {
                if ( !scope ) return;
                // we can't disconnect the root node or scope already disconnected
                if ( scope.$root === scope ) return;
                if ( !scope.$$disconnected ) return;
                var child = scope;
                var parent = child.$parent;
                child.$$disconnected = false;
                // See Scope.$new for this logic...
                child.$$prevSibling = parent.$$childTail;
                if ( parent.$$childHead ) {
                    parent.$$childTail.$$nextSibling = child;
                    parent.$$childTail = child;
                } else {
                    parent.$$childHead = parent.$$childTail = child;
                }
            }
        };
        /*
         * iterator is a list facade to easily support iteration and accessors
         *
         * @param items Array list which this iterator will enumerate
         * @param reloop Boolean enables iterator to consider the list as an endless reloop
         */
        function iterator( items, reloop ) {
                var trueFn = function() {
                    return true;
                };
                reloop = !!reloop;
                var _items = items || [];
                // Published API
                return {
                    items: getItems,
                    count: count,
                    inRange: inRange,
                    contains: contains,
                    indexOf: indexOf,
                    itemAt: itemAt,
                    findBy: findBy,
                    add: add,
                    remove: remove,
                    first: first,
                    last: last,
                    next: next,
                    previous: previous,
                    hasPrevious: hasPrevious,
                    hasNext: hasNext
                };
                /*
                 * Publish copy of the enumerable set
                 * @returns {Array|*}
                 */
                function getItems() {
                        return [].concat( _items );
                    }
                    /*
                     * Determine length of the list
                     * @returns {Array.length|*|number}
                     */
                function count() {
                        return _items.length;
                    }
                    /*
                     * Is the index specified valid
                     * @param index
                     * @returns {Array.length|*|number|boolean}
                     */
                function inRange( index ) {
                        return _items.length && ( index > -1 ) && ( index < _items.length );
                    }
                    /*
                     * Can the iterator proceed to the next item in the list; relative to
                     * the specified item.
                     *
                     * @param item
                     * @returns {Array.length|*|number|boolean}
                     */
                function hasNext( item ) {
                        return item ? inRange( indexOf( item ) + 1 ) : false;
                    }
                    /*
                     * Can the iterator proceed to the previous item in the list; relative to
                     * the specified item.
                     *
                     * @param item
                     * @returns {Array.length|*|number|boolean}
                     */
                function hasPrevious( item ) {
                        return item ? inRange( indexOf( item ) - 1 ) : false;
                    }
                    /*
                     * Get item at specified index/position
                     * @param index
                     * @returns {*}
                     */
                function itemAt( index ) {
                        return inRange( index ) ? _items[ index ] : null;
                    }
                    /*
                     * Find all elements matching the key/value pair
                     * otherwise return null
                     *
                     * @param val
                     * @param key
                     *
                     * @return array
                     */
                function findBy( key, val ) {
                        return _items.filter( function( item ) {
                            return item[ key ] === val;
                        } );
                    }
                    /*
                     * Add item to list
                     * @param item
                     * @param index
                     * @returns {*}
                     */
                function add( item, index ) {
                        if ( !item ) return -1;
                        if ( !angular.isNumber( index ) ) {
                            index = _items.length;
                        }
                        _items.splice( index, 0, item );
                        return indexOf( item );
                    }
                    /*
                     * Remove item from list...
                     * @param item
                     */
                function remove( item ) {
                        if ( contains( item ) ) {
                            _items.splice( indexOf( item ), 1 );
                        }
                    }
                    /*
                     * Get the zero-based index of the target item
                     * @param item
                     * @returns {*}
                     */
                function indexOf( item ) {
                        return _items.indexOf( item );
                    }
                    /*
                     * Boolean existence check
                     * @param item
                     * @returns {boolean}
                     */
                function contains( item ) {
                        return item && ( indexOf( item ) > -1 );
                    }
                    /*
                     * Find the next item. If reloop is true and at the end of the list, it will
                     * go back to the first item. If given ,the `validate` callback will be used
                     * determine whether the next item is valid. If not valid, it will try to find the
                     * next item again.
                     * @param item
                     * @param {optional} validate
                     * @returns {*}
                     */
                function next( item, validate ) {
                        validate = validate || trueFn;
                        if ( contains( item ) ) {
                            var index = indexOf( item ) + 1,
                                found = inRange( index ) ? _items[ index ] : ( reloop ? first() : null );
                            return validate( found ) ? found : next( found, validate );
                        }
                        return null;
                    }
                    /*
                     * Find the previous item. If reloop is true and at the beginning of the list, it will
                     * go back to the last item. If given ,the `validate` callback will be used
                     * determine whether the previous item is valid. If not valid, it will try to find the
                     * previous item again.
                     * @param item
                     * @param {optional} validate
                     * @returns {*}
                     */
                function previous( item, validate ) {
                        validate = validate || trueFn;
                        if ( contains( item ) ) {
                            var index = indexOf( item ) - 1,
                                found = inRange( index ) ? _items[ index ] : ( reloop ? last() : null );
                            return validate( found ) ? found : previous( found, validate );
                        }
                        return null;
                    }
                    /*
                     * Return first item in the list
                     * @returns {*}
                     */
                function first() {
                        return _items.length ? _items[ 0 ] : null;
                    }
                    /*
                     * Return last item in the list...
                     * @returns {*}
                     */
                function last() {
                    return _items.length ? _items[ _items.length - 1 ] : null;
                }
            }
            /*
             * Angular's $cacheFactory doesn't have a keys() method,
             * so we add one ourself.
             */
        function cacheFactory( id, options ) {
            var cache = $cacheFactory( id, options );
            var keys = {};
            cache._put = cache.put;
            cache.put = function( k, v ) {
                keys[ k ] = true;
                return cache._put( k, v );
            };
            cache._remove = cache.remove;
            cache.remove = function( k ) {
                delete keys[ k ];
                return cache._remove( k );
            };
            cache.keys = function() {
                return Object.keys( keys );
            };
            return cache;
        }
} ] );
    /* 
     * Since removing jQuery from the demos, some code that uses `element.focus()` is broken.
     *
     * We need to add `element.focus()`, because it's testable unlike `element[0].focus`.
     *
     * TODO(ajoslin): This should be added in a better place later.
     */
    angular.element.prototype.focus = angular.element.prototype.focus || function() {
        if ( this.length ) {
            this[ 0 ].focus();
        }
        return this;
    };
    angular.element.prototype.blur = angular.element.prototype.blur || function() {
        if ( this.length ) {
            this[ 0 ].blur();
        }
        return this;
    };
} )();
( function() {
    'use strict';
    angular.module( 'material.core' ).service( '$mdAria', AriaService );

    function AriaService( $$rAF, $log, $window ) {
        return {
            expect: expect,
            expectAsync: expectAsync,
            expectWithText: expectWithText
        };
        /**
         * Check if expected attribute has been specified on the target element or child
         * @param element
         * @param attrName
         * @param {optional} defaultValue What to set the attr to if no value is found
         */
        function expect( element, attrName, defaultValue ) {
            var node = element[ 0 ];
            if ( !node.hasAttribute( attrName ) && !childHasAttribute( node, attrName ) ) {
                defaultValue = angular.isString( defaultValue ) && defaultValue.trim() || '';
                if ( defaultValue.length ) {
                    element.attr( attrName, defaultValue );
                } else {
                    $log.warn( 'ARIA: Attribute "', attrName, '", required for accessibility, is missing on node:', node );
                }
            }
        }

        function expectAsync( element, attrName, defaultValueGetter ) {
            // Problem: when retrieving the element's contents synchronously to find the label,
            // the text may not be defined yet in the case of a binding.
            // There is a higher chance that a binding will be defined if we wait one frame.
            $$rAF( function() {
                expect( element, attrName, defaultValueGetter() );
            } );
        }

        function expectWithText( element, attrName ) {
            expectAsync( element, attrName, function() {
                return element.text().trim();
            } );
        }

        function childHasAttribute( node, attrName ) {
            var hasChildren = node.hasChildNodes(),
                hasAttr = false;

            function isHidden( el ) {
                var style = el.currentStyle ? el.currentStyle : $window.getComputedStyle( el );
                return ( style.display === 'none' );
            }
            if ( hasChildren ) {
                var children = node.childNodes;
                for ( var i = 0; i < children.length; i++ ) {
                    var child = children[ i ];
                    if ( child.nodeType === 1 && child.hasAttribute( attrName ) ) {
                        if ( !isHidden( child ) ) {
                            hasAttr = true;
                        }
                    }
                }
            }
            return hasAttr;
        }
    }
    AriaService.$inject = [ "$$rAF", "$log", "$window" ];
} )();
( function() {
    'use strict';
    angular.module( 'material.core' ).service( '$mdCompiler', mdCompilerService );

    function mdCompilerService( $q, $http, $injector, $compile, $controller, $templateCache ) {
        /*
         * @ngdoc service
         * @name $mdCompiler
         * @module material.core
         * @description
         * The $mdCompiler service is an abstraction of angular's compiler, that allows the developer
         * to easily compile an element with a templateUrl, controller, and locals.
         *
         * @usage
         * <hljs lang="js">
         * $mdCompiler.compile({
         *   templateUrl: 'modal.html',
         *   controller: 'ModalCtrl',
         *   locals: {
         *     modal: myModalInstance;
         *   }
         * }).then(function(compileData) {
         *   compileData.element; // modal.html's template in an element
         *   compileData.link(myScope); //attach controller & scope to element
         * });
         * </hljs>
         */
        /*
         * @ngdoc method
         * @name $mdCompiler#compile
         * @description A helper to compile an HTML template/templateUrl with a given controller,
         * locals, and scope.
         * @param {object} options An options object, with the following properties:
         *
         *    - `controller` - `{(string=|function()=}` Controller fn that should be associated with
         *      newly created scope or the name of a registered controller if passed as a string.
         *    - `controllerAs` - `{string=}` A controller alias name. If present the controller will be
         *      published to scope under the `controllerAs` name.
         *    - `template` - `{string=}` An html template as a string.
         *    - `templateUrl` - `{string=}` A path to an html template.
         *    - `transformTemplate` - `{function(template)=}` A function which transforms the template after
         *      it is loaded. It will be given the template string as a parameter, and should
         *      return a a new string representing the transformed template.
         *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should
         *      be injected into the controller. If any of these dependencies are promises, the compiler
         *      will wait for them all to be resolved, or if one is rejected before the controller is
         *      instantiated `compile()` will fail..
         *      * `key` - `{string}`: a name of a dependency to be injected into the controller.
         *      * `factory` - `{string|function}`: If `string` then it is an alias for a service.
         *        Otherwise if function, then it is injected and the return value is treated as the
         *        dependency. If the result is a promise, it is resolved before its value is
         *        injected into the controller.
         *
         * @returns {object=} promise A promise, which will be resolved with a `compileData` object.
         * `compileData` has the following properties:
         *
         *   - `element` - `{element}`: an uncompiled element matching the provided template.
         *   - `link` - `{function(scope)}`: A link function, which, when called, will compile
         *     the element and instantiate the provided controller (if given).
         *   - `locals` - `{object}`: The locals which will be passed into the controller once `link` is
         *     called. If `bindToController` is true, they will be coppied to the ctrl instead
         *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in
         */
        this.compile = function( options ) {
            var templateUrl = options.templateUrl;
            var template = options.template || '';
            var controller = options.controller;
            var controllerAs = options.controllerAs;
            var resolve = options.resolve || {};
            var locals = options.locals || {};
            var transformTemplate = options.transformTemplate || angular.identity;
            var bindToController = options.bindToController;
            // Take resolve values and invoke them.  
            // Resolves can either be a string (value: 'MyRegisteredAngularConst'),
            // or an invokable 'factory' of sorts: (value: function ValueGetter($dependency) {})
            angular.forEach( resolve, function( value, key ) {
                if ( angular.isString( value ) ) {
                    resolve[ key ] = $injector.get( value );
                } else {
                    resolve[ key ] = $injector.invoke( value );
                }
            } );
            //Add the locals, which are just straight values to inject
            //eg locals: { three: 3 }, will inject three into the controller
            angular.extend( resolve, locals );
            if ( templateUrl ) {
                resolve.$template = $http.get( templateUrl, {
                    cache: $templateCache
                } ).then( function( response ) {
                    return response.data;
                } );
            } else {
                resolve.$template = $q.when( template );
            }
            // Wait for all the resolves to finish if they are promises
            return $q.all( resolve ).then( function( locals ) {
                var template = transformTemplate( locals.$template );
                var element = angular.element( '<div>' ).html( template.trim() ).contents();
                var linkFn = $compile( element );
                //Return a linking function that can be used later when the element is ready
                return {
                    locals: locals,
                    element: element,
                    link: function link( scope ) {
                        locals.$scope = scope;
                        //Instantiate controller if it exists, because we have scope
                        if ( controller ) {
                            var ctrl = $controller( controller, locals );
                            if ( bindToController ) {
                                angular.extend( ctrl, locals );
                            }
                            //See angular-route source for this logic
                            element.data( '$ngControllerController', ctrl );
                            element.children().data( '$ngControllerController', ctrl );
                            if ( controllerAs ) {
                                scope[ controllerAs ] = ctrl;
                            }
                        }
                        return linkFn( scope );
                    }
                };
            } );
        };
    }
    mdCompilerService.$inject = [ "$q", "$http", "$injector", "$compile", "$controller", "$templateCache" ];
} )();
( function() {
    'use strict';
    angular.module( 'material.core' ).provider( '$$interimElement', InterimElementProvider );
    /*
     * @ngdoc service
     * @name $$interimElement
     * @module material.core
     *
     * @description
     *
     * Factory that contructs `$$interimElement.$service` services.
     * Used internally in material design for elements that appear on screen temporarily.
     * The service provides a promise-like API for interacting with the temporary
     * elements.
     *
     * ```js
     * app.service('$mdToast', function($$interimElement) {
     *   var $mdToast = $$interimElement(toastDefaultOptions);
     *   return $mdToast;
     * });
     * ```
     * @param {object=} defaultOptions Options used by default for the `show` method on the service.
     *
     * @returns {$$interimElement.$service}
     *
     */
    function InterimElementProvider() {
        createInterimElementProvider.$get = InterimElementFactory;
        InterimElementFactory.$inject = [ "$document", "$q", "$rootScope", "$timeout", "$rootElement", "$animate", "$mdCompiler", "$mdTheming" ];
        return createInterimElementProvider;
        /**
         * Returns a new provider which allows configuration of a new interimElement
         * service. Allows configuration of default options & methods for options,
         * as well as configuration of 'preset' methods (eg dialog.basic(): basic is a preset method)
         */
        function createInterimElementProvider( interimFactoryName ) {
                var EXPOSED_METHODS = [ 'onHide', 'onShow', 'onRemove' ];
                var providerConfig = {
                    presets: {}
                };
                var provider = {
                    setDefaults: setDefaults,
                    addPreset: addPreset,
                    $get: factory
                };
                /**
                 * all interim elements will come with the 'build' preset
                 */
                provider.addPreset( 'build', {
                    methods: [ 'controller', 'controllerAs', 'resolve',
        'template', 'templateUrl', 'themable', 'transformTemplate', 'parent' ]
                } );
                factory.$inject = [ "$$interimElement", "$animate", "$injector" ];
                return provider;
                /**
                 * Save the configured defaults to be used when the factory is instantiated
                 */
                function setDefaults( definition ) {
                        providerConfig.optionsFactory = definition.options;
                        providerConfig.methods = ( definition.methods || [] ).concat( EXPOSED_METHODS );
                        return provider;
                    }
                    /**
                     * Save the configured preset to be used when the factory is instantiated
                     */
                function addPreset( name, definition ) {
                        definition = definition || {};
                        definition.methods = definition.methods || [];
                        definition.options = definition.options || function() {
                            return {};
                        };
                        if ( /^cancel|hide|show$/.test( name ) ) {
                            throw new Error( "Preset '" + name + "' in " + interimFactoryName + " is reserved!" );
                        }
                        if ( definition.methods.indexOf( '_options' ) > -1 ) {
                            throw new Error( "Method '_options' in " + interimFactoryName + " is reserved!" );
                        }
                        providerConfig.presets[ name ] = {
                            methods: definition.methods.concat( EXPOSED_METHODS ),
                            optionsFactory: definition.options,
                            argOption: definition.argOption
                        };
                        return provider;
                    }
                    /**
                     * Create a factory that has the given methods & defaults implementing interimElement
                     */
                    /* @ngInject */
                function factory( $$interimElement, $animate, $injector ) {
                    var defaultMethods;
                    var defaultOptions;
                    var interimElementService = $$interimElement();
                    /*
                     * publicService is what the developer will be using.
                     * It has methods hide(), cancel(), show(), build(), and any other
                     * presets which were set during the config phase.
                     */
                    var publicService = {
                        hide: interimElementService.hide,
                        cancel: interimElementService.cancel,
                        show: showInterimElement
                    };
                    defaultMethods = providerConfig.methods || [];
                    // This must be invoked after the publicService is initialized
                    defaultOptions = invokeFactory( providerConfig.optionsFactory, {} );
                    angular.forEach( providerConfig.presets, function( definition, name ) {
                        var presetDefaults = invokeFactory( definition.optionsFactory, {} );
                        var presetMethods = ( definition.methods || [] ).concat( defaultMethods );
                        // Every interimElement built with a preset has a field called `$type`,
                        // which matches the name of the preset.
                        // Eg in preset 'confirm', options.$type === 'confirm'
                        angular.extend( presetDefaults, {
                            $type: name
                        } );
                        // This creates a preset class which has setter methods for every
                        // method given in the `.addPreset()` function, as well as every
                        // method given in the `.setDefaults()` function.
                        //
                        // @example
                        // .setDefaults({
                        //   methods: ['hasBackdrop', 'clickOutsideToClose', 'escapeToClose', 'targetEvent'],
                        //   options: dialogDefaultOptions
                        // })
                        // .addPreset('alert', {
                        //   methods: ['title', 'ok'],
                        //   options: alertDialogOptions
                        // })
                        //
                        // Set values will be passed to the options when interimElemnt.show() is called.
                        function Preset( opts ) {
                            this._options = angular.extend( {}, presetDefaults, opts );
                        }
                        angular.forEach( presetMethods, function( name ) {
                            Preset.prototype[ name ] = function( value ) {
                                this._options[ name ] = value;
                                return this;
                            };
                        } );
                        // eg $mdDialog.alert() will return a new alert preset
                        publicService[ name ] = function( arg ) {
                            // If argOption is supplied, eg `argOption: 'content'`, then we assume
                            // if the argument is not an options object then it is the `argOption` option.
                            //
                            // @example `$mdToast.simple('hello')` // sets options.content to hello
                            //                                     // because argOption === 'content'
                            if ( arguments.length && definition.argOption && !angular.isObject( arg ) && !angular.isArray( arg ) ) {
                                return ( new Preset() )[ definition.argOption ]( arg );
                            } else {
                                return new Preset( arg );
                            }
                        };
                    } );
                    return publicService;

                    function showInterimElement( opts ) {
                            // opts is either a preset which stores its options on an _options field,
                            // or just an object made up of options
                            if ( opts && opts._options ) opts = opts._options;
                            return interimElementService.show( angular.extend( {}, defaultOptions, opts ) );
                        }
                        /**
                         * Helper to call $injector.invoke with a local of the factory name for
                         * this provider.
                         * If an $mdDialog is providing options for a dialog and tries to inject
                         * $mdDialog, a circular dependency error will happen.
                         * We get around that by manually injecting $mdDialog as a local.
                         */
                    function invokeFactory( factory, defaultVal ) {
                        var locals = {};
                        locals[ interimFactoryName ] = publicService;
                        return $injector.invoke( factory || function() {
                            return defaultVal;
                        }, {}, locals );
                    }
                }
            }
            /* @ngInject */
        function InterimElementFactory( $document, $q, $rootScope, $timeout, $rootElement, $animate, $mdCompiler, $mdTheming ) {
            return function createInterimElementService() {
                /*
                 * @ngdoc service
                 * @name $$interimElement.$service
                 *
                 * @description
                 * A service used to control inserting and removing an element into the DOM.
                 *
                 */
                var stack = [];
                var service;
                return service = {
                    show: show,
                    hide: hide,
                    cancel: cancel
                };
                /*
                 * @ngdoc method
                 * @name $$interimElement.$service#show
                 * @kind function
                 *
                 * @description
                 * Adds the `$interimElement` to the DOM and returns a promise that will be resolved or rejected
                 * with hide or cancel, respectively.
                 *
                 * @param {*} options is hashMap of settings
                 * @returns a Promise
                 *
                 */
                function show( options ) {
                        if ( stack.length ) {
                            service.cancel();
                        }
                        var interimElement = new InterimElement( options );
                        stack.push( interimElement );
                        return interimElement.show().then( function() {
                            return interimElement.deferred.promise;
                        } );
                    }
                    /*
                     * @ngdoc method
                     * @name $$interimElement.$service#hide
                     * @kind function
                     *
                     * @description
                     * Removes the `$interimElement` from the DOM and resolves the promise returned from `show`
                     *
                     * @param {*} resolveParam Data to resolve the promise with
                     * @returns a Promise that will be resolved after the element has been removed.
                     *
                     */
                function hide( response ) {
                        var interimElement = stack.shift();
                        interimElement && interimElement.remove().then( function() {
                            interimElement.deferred.resolve( response );
                        } );
                        return interimElement ? interimElement.deferred.promise : $q.when( response );
                    }
                    /*
                     * @ngdoc method
                     * @name $$interimElement.$service#cancel
                     * @kind function
                     *
                     * @description
                     * Removes the `$interimElement` from the DOM and rejects the promise returned from `show`
                     *
                     * @param {*} reason Data to reject the promise with
                     * @returns Promise that will be rejected after the element has been removed.
                     *
                     */
                function cancel( reason ) {
                        var interimElement = stack.shift();
                        interimElement && interimElement.remove().then( function() {
                            interimElement.deferred.reject( reason );
                        } );
                        return interimElement ? interimElement.deferred.promise : $q.reject( reason );
                    }
                    /*
                     * Internal Interim Element Object
                     * Used internally to manage the DOM element and related data
                     */
                function InterimElement( options ) {
                    var self;
                    var hideTimeout, element;
                    options = options || {};
                    options = angular.extend( {
                        scope: options.scope || $rootScope.$new( options.isolateScope ),
                        onShow: function( scope, element, options ) {
                            return $animate.enter( element, options.parent );
                        },
                        onRemove: function( scope, element, options ) {
                            // Element could be undefined if a new element is shown before
                            // the old one finishes compiling.
                            return element && $animate.leave( element ) || $q.when();
                        }
                    }, options );
                    return self = {
                        options: options,
                        deferred: $q.defer(),
                        show: function() {
                            return $mdCompiler.compile( options ).then( function( compileData ) {
                                angular.extend( compileData.locals, self.options );
                                // Search for parent at insertion time, if not specified
                                if ( angular.isString( options.parent ) ) {
                                    options.parent = angular.element( $document[ 0 ].querySelector( options.parent ) );
                                } else if ( !options.parent ) {
                                    options.parent = $rootElement.find( 'body' );
                                    if ( !options.parent.length ) options.parent = $rootElement;
                                }
                                element = compileData.link( options.scope );
                                if ( options.themable ) $mdTheming( element );
                                var ret = options.onShow( options.scope, element, options );
                                return $q.when( ret ).then( function() {
                                    // Issue onComplete callback when the `show()` finishes
                                    ( options.onComplete || angular.noop )( options.scope, element, options );
                                    startHideTimeout();
                                } );

                                function startHideTimeout() {
                                    if ( options.hideDelay ) {
                                        hideTimeout = $timeout( service.cancel, options.hideDelay );
                                    }
                                }
                            } );
                        },
                        cancelTimeout: function() {
                            if ( hideTimeout ) {
                                $timeout.cancel( hideTimeout );
                                hideTimeout = undefined;
                            }
                        },
                        remove: function() {
                            self.cancelTimeout();
                            var ret = options.onRemove( options.scope, element, options );
                            return $q.when( ret ).then( function() {
                                options.scope.$destroy();
                            } );
                        }
                    };
                }
            };
        }
    }
} )();
( function() {
    'use strict';
    angular.module( 'material.core' ).factory( '$mdInkRipple', InkRippleService ).directive( 'mdInkRipple', InkRippleDirective ).directive( 'mdNoInk', attrNoDirective() ).directive( 'mdNoBar', attrNoDirective() ).directive( 'mdNoStretch', attrNoDirective() );

    function InkRippleDirective( $mdInkRipple ) {
        return {
            controller: angular.noop,
            link: function( scope, element, attr ) {
                if ( attr.hasOwnProperty( 'mdInkRippleCheckbox' ) ) {
                    $mdInkRipple.attachCheckboxBehavior( scope, element );
                } else {
                    $mdInkRipple.attachButtonBehavior( scope, element );
                }
            }
        };
    }
    InkRippleDirective.$inject = [ "$mdInkRipple" ];

    function InkRippleService( $window, $timeout ) {
        return {
            attachButtonBehavior: attachButtonBehavior,
            attachCheckboxBehavior: attachCheckboxBehavior,
            attachTabBehavior: attachTabBehavior,
            attach: attach
        };

        function attachButtonBehavior( scope, element, options ) {
            return attach( scope, element, angular.extend( {
                isFAB: element.hasClass( 'md-fab' ),
                isMenuItem: element.hasClass( 'md-menu-item' ),
                center: false,
                dimBackground: true
            }, options ) );
        }

        function attachCheckboxBehavior( scope, element, options ) {
            return attach( scope, element, angular.extend( {
                center: true,
                dimBackground: false
            }, options ) );
        }

        function attachTabBehavior( scope, element, options ) {
            return attach( scope, element, angular.extend( {
                center: false,
                dimBackground: true,
                outline: true
            }, options ) );
        }

        function attach( scope, element, options ) {
            if ( element.controller( 'mdNoInk' ) ) return angular.noop;
            options = angular.extend( {
                colorElement: element,
                mousedown: true,
                hover: true,
                focus: true,
                center: false,
                mousedownPauseTime: 150,
                dimBackground: false,
                outline: false,
                isFAB: false,
                isMenuItem: false
            }, options );
            var rippleContainer, rippleSize,
                controller = element.controller( 'mdInkRipple' ) || {},
                counter = 0,
                ripples = [],
                states = [],
                isActiveExpr = element.attr( 'md-highlight' ),
                isActive = false,
                isHeld = false,
                node = element[ 0 ],
                hammertime = new Hammer( node ),
                color = parseColor( element.attr( 'md-ink-ripple' ) ) || parseColor( $window.getComputedStyle( options.colorElement[ 0 ] ).color || 'rgb(0, 0, 0)' );
            options.mousedown && hammertime.on( 'hammer.input', onInput );
            controller.createRipple = createRipple;
            if ( isActiveExpr ) {
                scope.$watch( isActiveExpr, function watchActive( newValue ) {
                    isActive = newValue;
                    if ( isActive && !ripples.length ) {
                        $timeout( function() {
                            createRipple( 0, 0 );
                        }, 0, false );
                    }
                    angular.forEach( ripples, updateElement );
                } );
            }
            // Publish self-detach method if desired...
            return function detach() {
                hammertime.destroy();
                rippleContainer && rippleContainer.remove();
            };

            function parseColor( color ) {
                if ( !color ) return;
                if ( color.indexOf( 'rgba' ) === 0 ) return color;
                if ( color.indexOf( 'rgb' ) === 0 ) return rgbToRGBA( color );
                if ( color.indexOf( '#' ) === 0 ) return hexToRGBA( color );
                /**
                 * Converts a hex value to an rgba string
                 *
                 * @param {string} hex value (3 or 6 digits) to be converted
                 *
                 * @returns {string} rgba color with 0.1 alpha
                 */
                function hexToRGBA( color ) {
                        var hex = color.charAt( 0 ) === '#' ? color.substr( 1 ) : color,
                            dig = hex.length / 3,
                            red = hex.substr( 0, dig ),
                            grn = hex.substr( dig, dig ),
                            blu = hex.substr( dig * 2 );
                        if ( dig === 1 ) {
                            red += red;
                            grn += grn;
                            blu += blu;
                        }
                        return 'rgba(' + parseInt( red, 16 ) + ',' + parseInt( grn, 16 ) + ',' + parseInt( blu, 16 ) + ',0.1)';
                    }
                    /**
                     * Converts rgb value to rgba string
                     *
                     * @param {string} rgb color string
                     *
                     * @returns {string} rgba color with 0.1 alpha
                     */
                function rgbToRGBA( color ) {
                    return color.replace( ')', ', 0.1)' ).replace( '(', 'a(' )
                }
            }

            function removeElement( elem, wait ) {
                ripples.splice( ripples.indexOf( elem ), 1 );
                if ( ripples.length === 0 ) {
                    rippleContainer && rippleContainer.css( {
                        backgroundColor: ''
                    } );
                }
                $timeout( function() {
                    elem.remove();
                }, wait, false );
            }

            function updateElement( elem ) {
                    var index = ripples.indexOf( elem ),
                        state = states[ index ] || {},
                        elemIsActive = ripples.length > 1 ? false : isActive,
                        elemIsHeld = ripples.length > 1 ? false : isHeld;
                    if ( elemIsActive || state.animating || elemIsHeld ) {
                        elem.addClass( 'md-ripple-visible' );
                    } else if ( elem ) {
                        elem.removeClass( 'md-ripple-visible' );
                        if ( options.outline ) {
                            elem.css( {
                                width: rippleSize + 'px',
                                height: rippleSize + 'px',
                                marginLeft: ( rippleSize * -1 ) + 'px',
                                marginTop: ( rippleSize * -1 ) + 'px'
                            } );
                        }
                        removeElement( elem, options.outline ? 450 : 650 );
                    }
                }
                /**
                 * Creates a ripple at the provided coordinates
                 *
                 * @param {number} left cursor position
                 * @param {number} top cursor position
                 *
                 * @returns {angular.element} the generated ripple element
                 */
            function createRipple( left, top ) {
                    color = parseColor( element.attr( 'md-ink-ripple' ) ) || parseColor( $window.getComputedStyle( options.colorElement[ 0 ] ).color || 'rgb(0, 0, 0)' );
                    var container = getRippleContainer(),
                        size = getRippleSize( left, top ),
                        css = getRippleCss( size, left, top ),
                        elem = getRippleElement( css ),
                        index = ripples.indexOf( elem ),
                        state = states[ index ] || {};
                    rippleSize = size;
                    state.animating = true;
                    $timeout( function() {
                        if ( options.dimBackground ) {
                            container.css( {
                                backgroundColor: color
                            } );
                        }
                        elem.addClass( 'md-ripple-placed md-ripple-scaled' );
                        if ( options.outline ) {
                            elem.css( {
                                borderWidth: ( size * 0.5 ) + 'px',
                                marginLeft: ( size * -0.5 ) + 'px',
                                marginTop: ( size * -0.5 ) + 'px'
                            } );
                        } else {
                            elem.css( {
                                left: '50%',
                                top: '50%'
                            } );
                        }
                        updateElement( elem );
                        $timeout( function() {
                            state.animating = false;
                            updateElement( elem );
                        }, ( options.outline ? 450 : 225 ), false );
                    }, 0, false );
                    return elem;
                    /**
                     * Creates the ripple element with the provided css
                     *
                     * @param {object} css properties to be applied
                     *
                     * @returns {angular.element} the generated ripple element
                     */
                    function getRippleElement( css ) {
                            var elem = angular.element( '<div class="md-ripple" data-counter="' + counter++ +'">' );
                            ripples.unshift( elem );
                            states.unshift( {
                                animating: true
                            } );
                            container.append( elem );
                            css && elem.css( css );
                            return elem;
                        }
                        /**
                         * Calculate the ripple size
                         *
                         * @returns {number} calculated ripple diameter
                         */
                    function getRippleSize( left, top ) {
                            var width = container.prop( 'offsetWidth' ),
                                height = container.prop( 'offsetHeight' ),
                                multiplier, size, rect;
                            if ( options.isMenuItem ) {
                                size = Math.sqrt( Math.pow( width, 2 ) + Math.pow( height, 2 ) );
                            } else if ( options.outline ) {
                                rect = node.getBoundingClientRect();
                                left -= rect.left;
                                top -= rect.top;
                                width = Math.max( left, width - left );
                                height = Math.max( top, height - top );
                                size = 2 * Math.sqrt( Math.pow( width, 2 ) + Math.pow( height, 2 ) );
                            } else {
                                multiplier = options.isFAB ? 1.1 : 0.8;
                                size = Math.max( width, height ) * multiplier;
                            }
                            return size;
                        }
                        /**
                         * Generates the ripple css
                         *
                         * @param {number} the diameter of the ripple
                         * @param {number} the left cursor offset
                         * @param {number} the top cursor offset
                         *
                         * @returns {{backgroundColor: *, width: string, height: string, marginLeft: string, marginTop: string}}
                         */
                    function getRippleCss( size, left, top ) {
                            var rect,
                                css = {
                                    backgroundColor: rgbaToRGB( color ),
                                    borderColor: rgbaToRGB( color ),
                                    width: size + 'px',
                                    height: size + 'px'
                                };
                            if ( options.outline ) {
                                css.width = 0;
                                css.height = 0;
                            } else {
                                css.marginLeft = css.marginTop = ( size * -0.5 ) + 'px';
                            }
                            if ( options.center ) {
                                css.left = css.top = '50%';
                            } else {
                                rect = node.getBoundingClientRect();
                                css.left = Math.round( ( left - rect.left ) / container.prop( 'offsetWidth' ) * 100 ) + '%';
                                css.top = Math.round( ( top - rect.top ) / container.prop( 'offsetHeight' ) * 100 ) + '%';
                            }
                            return css;
                            /**
                             * Converts rgba string to rgb, removing the alpha value
                             *
                             * @param {string} rgba color
                             *
                             * @returns {string} rgb color
                             */
                            function rgbaToRGB( color ) {
                                return color.replace( 'rgba', 'rgb' ).replace( /,[^\)\,]+\)/, ')' );
                            }
                        }
                        /**
                         * Gets the current ripple container
                         * If there is no ripple container, it creates one and returns it
                         *
                         * @returns {angular.element} ripple container element
                         */
                    function getRippleContainer() {
                        if ( rippleContainer ) return rippleContainer;
                        var container = rippleContainer = angular.element( '<div class="md-ripple-container">' );
                        element.append( container );
                        return container;
                    }
                }
                /**
                 * Handles user input start and stop events
                 *
                 * @param {event} event fired by hammer.js
                 */
            function onInput( ev ) {
                var ripple, index;
                if ( ev.eventType === Hammer.INPUT_START && ev.isFirst && isRippleAllowed() ) {
                    ripple = createRipple( ev.center.x, ev.center.y );
                    isHeld = true;
                } else if ( ev.eventType === Hammer.INPUT_END && ev.isFinal ) {
                    isHeld = false;
                    index = ripples.length - 1;
                    ripple = ripples[ index ];
                    $timeout( function() {
                        updateElement( ripple );
                    }, 0, false );
                }
                /**
                 * Determines if the ripple is allowed
                 *
                 * @returns {boolean} true if the ripple is allowed, false if not
                 */
                function isRippleAllowed() {
                    var parent = node.parentNode;
                    return !node.hasAttribute( 'disabled' ) && !( parent && parent.hasAttribute( 'disabled' ) );
                }
            }
        }
    }
    InkRippleService.$inject = [ "$window", "$timeout" ];
    /**
     * noink/nobar/nostretch directive: make any element that has one of
     * these attributes be given a controller, so that other directives can
     * `require:` these and see if there is a `no<xxx>` parent attribute.
     *
     * @usage
     * <hljs lang="html">
     * <parent md-no-ink>
     *   <child detect-no>
     *   </child>
     * </parent>
     * </hljs>
     *
     * <hljs lang="js">
     * myApp.directive('detectNo', function() {
     *   return {
     *     require: ['^?mdNoInk', ^?mdNoBar'],
     *     link: function(scope, element, attr, ctrls) {
     *       var noinkCtrl = ctrls[0];
     *       var nobarCtrl = ctrls[1];
     *       if (noInkCtrl) {
     *         alert("the md-no-ink flag has been specified on an ancestor!");
     *       }
     *       if (nobarCtrl) {
     *         alert("the md-no-bar flag has been specified on an ancestor!");
     *       }
     *     }
     *   };
     * });
     * </hljs>
     */
    function attrNoDirective() {
        return function() {
            return {
                controller: angular.noop
            };
        };
    }
} )();
( function() {
    'use strict';
    angular.module( 'material.core' ).directive( 'mdTheme', ThemingDirective ).directive( 'mdThemable', ThemableDirective ).provider( '$mdTheming', ThemingProvider );
    /**
     * @ngdoc provider
     * @name $mdThemingProvider
     * @module material.core
     *
     * @description Provider to configure the `$mdTheming` service.
     */
    /**
     * @ngdoc method
     * @name $mdThemingProvider#setDefaultTheme
     * @param {string} themeName Default theme name to be applied to elements. Default value is `default`.
     */
    /**
     * @ngdoc method
     * @name $mdThemingProvider#alwaysWatchTheme
     * @param {boolean} watch Whether or not to always watch themes for changes and re-apply
     * classes when they change. Default is `false`. Enabling can reduce performance.
     */
    function ThemingProvider() {
        var defaultTheme = 'default';
        var alwaysWatchTheme = false;
        return {
            setDefaultTheme: function( theme ) {
                defaultTheme = theme;
            },
            alwaysWatchTheme: function( alwaysWatch ) {
                alwaysWatchTheme = alwaysWatch;
            },
            $get: [ '$rootScope', ThemingService ]
        };
        /**
         * @ngdoc service
         * @name $mdTheming
         *
         * @description
         *
         * Service that makes an element apply theming related classes to itself.
         *
         * ```js
         * app.directive('myFancyDirective', function($mdTheming) {
         *   return {
         *     restrict: 'e',
         *     link: function(scope, el, attrs) {
         *       $mdTheming(el);
         *     }
         *   };
         * });
         * ```
         * @param {el=} element to apply theming to
         */
        function ThemingService( $rootScope ) {
            applyTheme.inherit = function( el, parent ) {
                var ctrl = parent.controller( 'mdTheme' );
                var attrThemeValue = el.attr( 'md-theme-watch' );
                if ( ( alwaysWatchTheme || angular.isDefined( attrThemeValue ) ) && attrThemeValue != 'false' ) {
                    var deregisterWatch = $rootScope.$watch( function() {
                        return ctrl && ctrl.$mdTheme || defaultTheme;
                    }, changeTheme );
                    el.on( '$destroy', deregisterWatch );
                } else {
                    var theme = ctrl && ctrl.$mdTheme || defaultTheme;
                    changeTheme( theme );
                }

                function changeTheme( theme ) {
                    var oldTheme = el.data( '$mdThemeName' );
                    if ( oldTheme ) el.removeClass( 'md-' + oldTheme + '-theme' );
                    el.addClass( 'md-' + theme + '-theme' );
                    el.data( '$mdThemeName', theme );
                }
            };
            return applyTheme;

            function applyTheme( scope, el ) {
                // Allow us to be invoked via a linking function signature.
                if ( el === undefined ) {
                    el = scope;
                    scope = undefined;
                }
                if ( scope === undefined ) {
                    scope = $rootScope;
                }
                applyTheme.inherit( el, el );
            }
        }
    }

    function ThemingDirective( $interpolate ) {
        return {
            priority: 100,
            link: {
                pre: function( scope, el, attrs ) {
                    var ctrl = {
                        $setTheme: function( theme ) {
                            ctrl.$mdTheme = theme;
                        }
                    };
                    el.data( '$mdThemeController', ctrl );
                    ctrl.$setTheme( $interpolate( attrs.mdTheme )( scope ) );
                    attrs.$observe( 'mdTheme', ctrl.$setTheme );
                }
            }
        };
    }
    ThemingDirective.$inject = [ "$interpolate" ];

    function ThemableDirective( $mdTheming ) {
        return $mdTheming;
    }
    ThemableDirective.$inject = [ "$mdTheming" ];
} )();
( function() {
    'use strict';
    /*
     * @ngdoc module
     * @name material.components.backdrop
     * @description Backdrop
     */
    /**
     * @ngdoc directive
     * @name mdBackdrop
     * @module material.components.backdrop
     *
     * @restrict E
     *
     * @description
     * `<md-backdrop>` is a backdrop element used by other coponents, such as dialog and bottom sheet.
     * Apply class `opaque` to make the backdrop use the theme backdrop color.
     *
     */
    angular.module( 'material.components.backdrop', [
  'material.core'
] ).directive( 'mdBackdrop', BackdropDirective );

    function BackdropDirective( $mdTheming ) {
        return $mdTheming;
    }
    BackdropDirective.$inject = [ "$mdTheming" ];
} )();
( function() {
    'use strict';
    /**
     * @ngdoc module
     * @name material.components.bottomSheet
     * @description
     * BottomSheet
     */
    angular.module( 'material.components.bottomSheet', [
  'material.core',
  'material.components.backdrop'
] ).directive( 'mdBottomSheet', MdBottomSheetDirective ).provider( '$mdBottomSheet', MdBottomSheetProvider );

    function MdBottomSheetDirective() {
            return {
                restrict: 'E'
            };
        }
        /**
         * @ngdoc service
         * @name $mdBottomSheet
         * @module material.components.bottomSheet
         *
         * @description
         * `$mdBottomSheet` opens a bottom sheet over the app and provides a simple promise API.
         *
         * ### Restrictions
         *
         * - The bottom sheet's template must have an outer `<md-bottom-sheet>` element.
         * - Add the `md-grid` class to the bottom sheet for a grid layout.
         * - Add the `md-list` class to the bottom sheet for a list layout.
         *
         * @usage
         * <hljs lang="html">
         * <div ng-controller="MyController">
         *   <md-button ng-click="openBottomSheet()">
         *     Open a Bottom Sheet!
         *   </md-button>
         * </div>
         * </hljs>
         * <hljs lang="js">
         * var app = angular.module('app', ['ngMaterial']);
         * app.controller('MyController', function($scope, $mdBottomSheet) {
         *   $scope.openBottomSheet = function() {
         *     $mdBottomSheet.show({
         *       template: '<md-bottom-sheet>Hello!</md-bottom-sheet>'
         *     });
         *   };
         * });
         * </hljs>
         */
        /**
         * @ngdoc method
         * @name $mdBottomSheet#show
         *
         * @description
         * Show a bottom sheet with the specified options.
         *
         * @param {object} options An options object, with the following properties:
         *
         *   - `templateUrl` - `{string=}`: The url of an html template file that will
         *   be used as the content of the bottom sheet. Restrictions: the template must
         *   have an outer `md-bottom-sheet` element.
         *   - `template` - `{string=}`: Same as templateUrl, except this is an actual
         *   template string.
         *   - `controller` - `{string=}`: The controller to associate with this bottom sheet.
         *   - `locals` - `{string=}`: An object containing key/value pairs. The keys will
         *   be used as names of values to inject into the controller. For example,
         *   `locals: {three: 3}` would inject `three` into the controller with the value
         *   of 3.
         *   - `targetEvent` - `{DOMClickEvent=}`: A click's event object. When passed in as an option,
         *   the location of the click will be used as the starting point for the opening animation
         *   of the the dialog.
         *   - `resolve` - `{object=}`: Similar to locals, except it takes promises as values
         *   and the bottom sheet will not open until the promises resolve.
         *   - `controllerAs` - `{string=}`: An alias to assign the controller to on the scope.
         *
         * @returns {promise} A promise that can be resolved with `$mdBottomSheet.hide()` or
         * rejected with `$mdBottomSheet.cancel()`.
         */
        /**
         * @ngdoc method
         * @name $mdBottomSheet#hide
         *
         * @description
         * Hide the existing bottom sheet and resolve the promise returned from
         * `$mdBottomSheet.show()`.
         *
         * @param {*=} response An argument for the resolved promise.
         *
         */
        /**
         * @ngdoc method
         * @name $mdBottomSheet#cancel
         *
         * @description
         * Hide the existing bottom sheet and reject the promise returned from
         * `$mdBottomSheet.show()`.
         *
         * @param {*=} response An argument for the rejected promise.
         *
         */
    function MdBottomSheetProvider( $$interimElementProvider ) {
        bottomSheetDefaults.$inject = [ "$animate", "$mdConstant", "$timeout", "$$rAF", "$compile", "$mdTheming", "$mdBottomSheet", "$rootElement" ];
        return $$interimElementProvider( '$mdBottomSheet' ).setDefaults( {
            options: bottomSheetDefaults
        } );
        /* @ngInject */
        function bottomSheetDefaults( $animate, $mdConstant, $timeout, $$rAF, $compile, $mdTheming, $mdBottomSheet, $rootElement ) {
            var backdrop;
            return {
                themable: true,
                targetEvent: null,
                onShow: onShow,
                onRemove: onRemove,
                escapeToClose: true
            };

            function onShow( scope, element, options ) {
                // Add a backdrop that will close on click
                backdrop = $compile( '<md-backdrop class="md-opaque md-bottom-sheet-backdrop">' )( scope );
                backdrop.on( 'click touchstart', function() {
                    $timeout( $mdBottomSheet.cancel );
                } );
                $mdTheming.inherit( backdrop, options.parent );
                $animate.enter( backdrop, options.parent, null );
                var bottomSheet = new BottomSheet( element );
                options.bottomSheet = bottomSheet;
                // Give up focus on calling item
                options.targetEvent && angular.element( options.targetEvent.target ).blur();
                $mdTheming.inherit( bottomSheet.element, options.parent );
                return $animate.enter( bottomSheet.element, options.parent ).then( function() {
                    var focusable = angular.element( element[ 0 ].querySelector( 'button' ) || element[ 0 ].querySelector( 'a' ) || element[ 0 ].querySelector( '[ng-click]' ) );
                    focusable.focus();
                    if ( options.escapeToClose ) {
                        options.rootElementKeyupCallback = function( e ) {
                            if ( e.keyCode === $mdConstant.KEY_CODE.ESCAPE ) {
                                $timeout( $mdBottomSheet.cancel );
                            }
                        };
                        $rootElement.on( 'keyup', options.rootElementKeyupCallback );
                    }
                } );
            }

            function onRemove( scope, element, options ) {
                    var bottomSheet = options.bottomSheet;
                    $animate.leave( backdrop );
                    return $animate.leave( bottomSheet.element ).then( function() {
                        bottomSheet.cleanup();
                        // Restore focus
                        options.targetEvent && angular.element( options.targetEvent.target ).focus();
                    } );
                }
                /**
                 * BottomSheet class to apply bottom-sheet behavior to an element
                 */
            function BottomSheet( element ) {
                var MAX_OFFSET = 80; // amount past the bottom of the element that we can drag down, this is same as in _bottomSheet.scss
                var WIGGLE_AMOUNT = 20; // point where it starts to get "harder" to drag
                var CLOSING_VELOCITY = 10; // how fast we need to flick down to close the sheet
                var startY, lastY, velocity, transitionDelay, startTarget;
                // coercion incase $mdCompiler returns multiple elements
                element = element.eq( 0 );
                element.on( 'touchstart', onTouchStart ).on( 'touchmove', onTouchMove ).on( 'touchend', onTouchEnd );
                return {
                    element: element,
                    cleanup: function cleanup() {
                        element.off( 'touchstart', onTouchStart ).off( 'touchmove', onTouchMove ).off( 'touchend', onTouchEnd );
                    }
                };

                function onTouchStart( e ) {
                    e.preventDefault();
                    startTarget = e.target;
                    startY = getY( e );
                    // Disable transitions on transform so that it feels fast
                    transitionDelay = element.css( $mdConstant.CSS.TRANSITION_DURATION );
                    element.css( $mdConstant.CSS.TRANSITION_DURATION, '0s' );
                }

                function onTouchEnd( e ) {
                    // Re-enable the transitions on transforms
                    element.css( $mdConstant.CSS.TRANSITION_DURATION, transitionDelay );
                    var currentY = getY( e );
                    // If we didn't scroll much, and we didn't change targets, assume its a click
                    if ( Math.abs( currentY - startY ) < 5 && e.target == startTarget ) {
                        angular.element( e.target ).triggerHandler( 'click' );
                    } else {
                        // If they went fast enough, trigger a close.
                        if ( velocity > CLOSING_VELOCITY ) {
                            $timeout( $mdBottomSheet.cancel );
                            // Otherwise, untransform so that we go back to our normal position
                        } else {
                            setTransformY( undefined );
                        }
                    }
                }

                function onTouchMove( e ) {
                        var currentY = getY( e );
                        var delta = currentY - startY;
                        velocity = currentY - lastY;
                        lastY = currentY;
                        // Do some conversion on delta to get a friction-like effect
                        delta = adjustedDelta( delta );
                        setTransformY( delta + MAX_OFFSET );
                    }
                    /**
                     * Helper function to find the Y aspect of various touch events.
                     **/
                function getY( e ) {
                        var touch = e.touches && e.touches.length ? e.touches[ 0 ] : e.changedTouches[ 0 ];
                        return touch.clientY;
                    }
                    /**
                     * Transform the element along the y-axis
                     **/
                function setTransformY( amt ) {
                        if ( amt === null || amt === undefined ) {
                            element.css( $mdConstant.CSS.TRANSFORM, '' );
                        } else {
                            element.css( $mdConstant.CSS.TRANSFORM, 'translate3d(0, ' + amt + 'px, 0)' );
                        }
                    }
                    // Returns a new value for delta that will never exceed MAX_OFFSET_AMOUNT
                    // Will get harder to exceed it as you get closer to it
                function adjustedDelta( delta ) {
                    if ( delta < 0 && delta < -MAX_OFFSET + WIGGLE_AMOUNT ) {
                        delta = -delta;
                        var base = MAX_OFFSET - WIGGLE_AMOUNT;
                        delta = Math.max( -MAX_OFFSET, -Math.min( MAX_OFFSET - 5, base + ( WIGGLE_AMOUNT * ( delta - base ) ) / MAX_OFFSET ) - delta / 50 );
                    }
                    return delta;
                }
            }
        }
    }
    MdBottomSheetProvider.$inject = [ "$$interimElementProvider" ];
} )();
( function() {
    'use strict';
    /**
     * @ngdoc module
     * @name material.components.button
     * @description
     *
     * Button
     */
    angular.module( 'material.components.button', [
  'material.core'
] ).directive( 'mdButton', MdButtonDirective );
    /**
     * @ngdoc directive
     * @name mdButton
     * @module material.components.button
     *
     * @restrict E
     *
     * @description
     * `<md-button>` is a button directive with optional ink ripples (default enabled).
     *
     * If you supply a `href` or `ng-href` attribute, it will become an `<a>` element. Otherwise, it will
     * become a `<button>` element.
     *
     * @param {boolean=} md-no-ink If present, disable ripple ink effects.
     * @param {expression=} ng-disabled En/Disable based on the expression
     * @param {string=} aria-label Adds alternative text to button for accessibility, useful for icon buttons.
     * If no default text is found, a warning will be logged.
     *
     * @usage
     * <hljs lang="html">
     *  <md-button>
     *    Button
     *  </md-button>
     *  <md-button href="http://google.com" class="md-button-colored">
     *    I'm a link
     *  </md-button>
     *  <md-button ng-disabled="true" class="md-colored">
     *    I'm a disabled button
     *  </md-button>
     * </hljs>
     */
    function MdButtonDirective( $mdInkRipple, $mdTheming, $mdAria ) {
        return {
            restrict: 'E',
            replace: true,
            transclude: true,
            template: getTemplate,
            link: postLink
        };

        function isAnchor( attr ) {
            return angular.isDefined( attr.href ) || angular.isDefined( attr.ngHref );
        }

        function getTemplate( element, attr ) {
            if ( isAnchor( attr ) ) {
                return '<a class="md-button" ng-transclude></a>';
            } else {
                return '<button class="md-button" ng-transclude></button>';
            }
        }

        function postLink( scope, element, attr ) {
            var node = element[ 0 ];
            $mdTheming( element );
            $mdInkRipple.attachButtonBehavior( scope, element );
            var elementHasText = node.textContent.trim();
            if ( !elementHasText ) {
                $mdAria.expect( element, 'aria-label' );
            }
            // For anchor elements, we have to set tabindex manually when the 
            // element is disabled
            if ( isAnchor( attr ) ) {
                scope.$watch( attr.ngDisabled, function( isDisabled ) {
                    element.attr( 'tabindex', isDisabled ? -1 : 0 );
                } );
            }
        }
    }
    MdButtonDirective.$inject = [ "$mdInkRipple", "$mdTheming", "$mdAria" ];
} )();
( function() {
    'use strict';
    /**
     * @ngdoc module
     * @name material.components.card
     *
     * @description
     * Card components.
     */
    angular.module( 'material.components.card', [
  'material.core'
] ).directive( 'mdCard', mdCardDirective );
    /**
     * @ngdoc directive
     * @name mdCard
     * @module material.components.card
     *
     * @restrict E
     *
     * @description
     * The `<md-card>` directive is a container element used within `<md-content>` containers.
     *
     * Cards have constant width and variable heights; where the maximum height is limited to what can
     * fit within a single view on a platform, but it can temporarily expand as needed
     *
     * @usage
     * <hljs lang="html">
     * <md-card>
     *  <img src="img/washedout.png" class="md-card-image">
     *  <h2>Paracosm</h2>
     *  <p>
     *    The titles of Washed Out's breakthrough song and the first single from Paracosm share the * two most important words in Ernest Greene's musical language: feel it. It's a simple request, as well...
     *  </p>
     * </md-card>
     * </hljs>
     *
     */
    function mdCardDirective( $mdTheming ) {
        return {
            restrict: 'E',
            link: function( $scope, $element, $attr ) {
                $mdTheming( $element );
            }
        };
    }
    mdCardDirective.$inject = [ "$mdTheming" ];
} )();
( function() {
    'use strict';
    /**
     * @ngdoc module
     * @name material.components.checkbox
     * @description Checkbox module!
     */
    angular.module( 'material.components.checkbox', [
  'material.core'
] ).directive( 'mdCheckbox', MdCheckboxDirective );
    /**
     * @ngdoc directive
     * @name mdCheckbox
     * @module material.components.checkbox
     * @restrict E
     *
     * @description
     * The checkbox directive is used like the normal [angular checkbox](https://docs.angularjs.org/api/ng/input/input%5Bcheckbox%5D).
     *
     * @param {string} ng-model Assignable angular expression to data-bind to.
     * @param {string=} name Property name of the form under which the control is published.
     * @param {expression=} ng-true-value The value to which the expression should be set when selected.
     * @param {expression=} ng-false-value The value to which the expression should be set when not selected.
     * @param {string=} ng-change Angular expression to be executed when input changes due to user interaction with the input element.
     * @param {boolean=} md-no-ink Use of attribute indicates use of ripple ink effects
     * @param {string=} aria-label Adds label to checkbox for accessibility.
     * Defaults to checkbox's text. If no default text is found, a warning will be logged.
     *
     * @usage
     * <hljs lang="html">
     * <md-checkbox ng-model="isChecked" aria-label="Finished?">
     *   Finished ?
     * </md-checkbox>
     *
     * <md-checkbox md-no-ink ng-model="hasInk" aria-label="No Ink Effects">
     *   No Ink Effects
     * </md-checkbox>
     *
     * <md-checkbox ng-disabled="true" ng-model="isDisabled" aria-label="Disabled">
     *   Disabled
     * </md-checkbox>
     *
     * </hljs>
     *
     */
    function MdCheckboxDirective( inputDirective, $mdInkRipple, $mdAria, $mdConstant, $mdTheming ) {
        inputDirective = inputDirective[ 0 ];
        var CHECKED_CSS = 'md-checked';
        return {
            restrict: 'E',
            transclude: true,
            require: '?ngModel',
            template: '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox>' + '<div class="md-icon"></div>' + '</div>' + '<div ng-transclude class="md-label"></div>',
            compile: compile
        };
        // **********************************************************
        // Private Methods
        // **********************************************************
        function compile( tElement, tAttrs ) {
            tAttrs.type = 'checkbox';
            tAttrs.tabIndex = 0;
            tElement.attr( 'role', tAttrs.type );
            return function postLink( scope, element, attr, ngModelCtrl ) {
                var checked = false;
                $mdTheming( element );
                // Create a mock ngModel if the user doesn't provide one
                ngModelCtrl = ngModelCtrl || {
                    $setViewValue: function( value ) {
                        this.$viewValue = value;
                    },
                    $parsers: [],
                    $formatters: []
                };
                $mdAria.expectWithText( tElement, 'aria-label' );
                // Reuse the original input[type=checkbox] directive from Angular core.
                // This is a bit hacky as we need our own event listener and own render
                // function.
                inputDirective.link.pre( scope, {
                    on: angular.noop,
                    0: {}
                }, attr, [ ngModelCtrl ] );
                element.on( 'click', listener );
                element.on( 'keypress', keypressHandler );
                ngModelCtrl.$render = render;

                function keypressHandler( ev ) {
                    if ( ev.which === $mdConstant.KEY_CODE.SPACE ) {
                        ev.preventDefault();
                        listener( ev );
                    }
                }

                function listener( ev ) {
                    if ( element[ 0 ].hasAttribute( 'disabled' ) ) return;
                    scope.$apply( function() {
                        checked = !checked;
                        ngModelCtrl.$setViewValue( checked, ev && ev.type );
                        ngModelCtrl.$render();
                    } );
                }

                function render() {
                    checked = ngModelCtrl.$viewValue;
                    if ( checked ) {
                        element.addClass( CHECKED_CSS );
                    } else {
                        element.removeClass( CHECKED_CSS );
                    }
                }
            };
        }
    }
    MdCheckboxDirective.$inject = [ "inputDirective", "$mdInkRipple", "$mdAria", "$mdConstant", "$mdTheming" ];
} )();
( function() {
    'use strict';
    /**
     * @ngdoc module
     * @name material.components.content
     *
     * @description
     * Scrollable content
     */
    angular.module( 'material.components.content', [
  'material.core'
] ).directive( 'mdContent', mdContentDirective );
    /**
     * @ngdoc directive
     * @name mdContent
     * @module material.components.content
     *
     * @restrict E
     *
     * @description
     * The `<md-content>` directive is a container element useful for scrollable content
     *
     * ### Restrictions
     *
     * - Add the `md-padding` class to make the content padded.
     *
     * @usage
     * <hljs lang="html">
     *  <md-content class="md-padding">
     *      Lorem ipsum dolor sit amet, ne quod novum mei.
     *  </md-content>
     * </hljs>
     *
     */
    function mdContentDirective( $mdTheming ) {
        return {
            restrict: 'E',
            controller: [ '$scope', '$element', ContentController ],
            link: function( $scope, $element, $attr ) {
                $mdTheming( $element );
                $scope.$broadcast( '$mdContentLoaded', $element );
            }
        };

        function ContentController( $scope, $element ) {
            this.$scope = $scope;
            this.$element = $element;
        }
    }
    mdContentDirective.$inject = [ "$mdTheming" ];
} )();
( function() {
    'use strict';
    /**
     * @ngdoc module
     * @name material.components.dialog
     */
    angular.module( 'material.components.dialog', [
  'material.core',
  'material.components.backdrop'
] ).directive( 'mdDialog', MdDialogDirective ).provider( '$mdDialog', MdDialogProvider );

    function MdDialogDirective( $$rAF, $mdTheming ) {
        return {
            restrict: 'E',
            link: function( scope, element, attr ) {
                $mdTheming( element );
                $$rAF( function() {
                    var content = element[ 0 ].querySelector( 'md-content' );
                    if ( content && content.scrollHeight > content.clientHeight ) {
                        element.addClass( 'md-content-overflow' );
                    }
                } );
            }
        };
    }
    MdDialogDirective.$inject = [ "$$rAF", "$mdTheming" ];
    /**
     * @ngdoc service
     * @name $mdDialog
     * @module material.components.dialog
     *
     * @description
     * `$mdDialog` opens a dialog over the app and provides a simple promise API.
     *
     * ### Restrictions
     *
     * - The dialog is always given an isolate scope.
     * - The dialog's template must have an outer `<md-dialog>` element.
     *   Inside, use an `<md-content>` element for the dialog's content, and use
     *   an element with class `md-actions` for the dialog's actions.
     *
     * @usage
     * ##### HTML
     *
     * <hljs lang="html">
     * <div  ng-app="demoApp" ng-controller="EmployeeController">
     *   <md-button ng-click="showAlert()" class="md-raised md-warn">
     *     Employee Alert!
     *   </md-button>
     *   <md-button ng-click="closeAlert()" ng-disabled="!hasAlert()" class="md-raised">
     *     Close Alert
     *   </md-button>
     *   <md-button ng-click="showGreeting($event)" class="md-raised md-primary" >
     *     Greet Employee
     *   </md-button>
     * </div>
     * </hljs>
     *
     * ##### JavaScript
     *
     * <hljs lang="js">
     * (function(angular, undefined){
     *   "use strict";
     *
     *   angular
     *     .module('demoApp', ['ngMaterial'])
     *     .controller('EmployeeController', EmployeeEditor)
     *     .controller('GreetingController', GreetingController);
     *
     *   // Fictitious Employee Editor to show how to use simple and complex dialogs.
     *
     *   function EmployeeEditor($scope, $mdDialog) {
     *     var alert;
     *
     *     $scope.showAlert = showAlert;
     *     $scope.closeAlert = closeAlert;
     *     $scope.showGreeting = showCustomGreeting;
     *
     *     $scope.hasAlert = function() { return !!alert };
     *     $scope.userName = $scope.userName || 'Bobby';
     *
     *     // Dialog #1 - Show simple alert dialog and cache
     *     // reference to dialog instance
     *
     *     function showAlert() {
     *       alert = $mdDialog.alert()
     *         .title('Attention, ' + $scope.userName)
     *         .content('This is an example of how easy dialogs can be!')
     *         .ok('Close');
     *
     *       $mdDialog
     *           .show( alert )
     *           .finally(function() {
     *             alert = undefined;
     *           });
     *     }
     *
     *     // Close the specified dialog instance and resolve with 'finished' flag
     *     // Normally this is not needed, just use '$mdDialog.hide()' to close
     *     // the most recent dialog popup.
     *
     *     function closeAlert() {
     *       $mdDialog.hide( alert, "finished" );
     *       alert = undefined;
     *     }
     *
     *     // Dialog #2 - Demonstrate more complex dialogs construction and popup.
     *
     *     function showCustomGreeting($event) {
     *         $mdDialog.show({
     *           targetEvent: $event,
     *           template:
     *             '<md-dialog>' +
     *
     *             '  <md-content>Hello {{ employee }}!</md-content>' +
     *
     *             '  <div class="md-actions">' +
     *             '    <md-button ng-click="closeDialog()">' +
     *             '      Close Greeting' +
     *
     *             '    </md-button>' +
     *             '  </div>' +
     *             '</md-dialog>',
     *           controller: 'GreetingController',
     *           onComplete: afterShowAnimation,
     *           locals: { employee: $scope.userName }
     *         });
     *
     *         // When the 'enter' animation finishes...
     *
     *         function afterShowAnimation(scope, element, options) {
     *            // post-show code here: DOM element focus, etc.
     *         }
     *     }
     *   }
     *
     *   // Greeting controller used with the more complex 'showCustomGreeting()' custom dialog
     *
     *   function GreetingController($scope, $mdDialog, employee) {
     *     // Assigned from construction <code>locals</code> options...
     *     $scope.employee = employee;
     *
     *     $scope.closeDialog = function() {
     *       // Easily hides most recent dialog shown...
     *       // no specific instance reference is needed.
     *       $mdDialog.hide();
     *     };
     *   }
     *
     * })(angular);
     * </hljs>
     */
    /**
     * @ngdoc method
     * @name $mdDialog#alert
     *
     * @description
     * Builds a preconfigured dialog with the specified message.
     *
     * @returns {obj} an `$mdDialogPreset` with the chainable configuration methods:
     *
     * - $mdDialogPreset#title(string) - sets title to string
     * - $mdDialogPreset#content(string) - sets content / message to string
     * - $mdDialogPreset#ok(string) - sets okay button text to string
     *
     */
    /**
     * @ngdoc method
     * @name $mdDialog#confirm
     *
     * @description
     * Builds a preconfigured dialog with the specified message. You can call show and the promise returned
     * will be resolved only if the user clicks the confirm action on the dialog.
     *
     * @returns {obj} an `$mdDialogPreset` with the chainable configuration methods:
     *
     * Additionally, it supports the following methods:
     *
     * - $mdDialogPreset#title(string) - sets title to string
     * - $mdDialogPreset#content(string) - sets content / message to string
     * - $mdDialogPreset#ok(string) - sets okay button text to string
     * - $mdDialogPreset#cancel(string) - sets cancel button text to string
     *
     */
    /**
     * @ngdoc method
     * @name $mdDialog#show
     *
     * @description
     * Show a dialog with the specified options.
     *
     * @param {object} optionsOrPreset Either provide an `$mdToastPreset` returned from `alert()`,
     * `confirm()`, and `build()`, or an options object with the following properties:
     *   - `templateUrl` - `{string=}`: The url of a template that will be used as the content
     *   of the dialog.
     *   - `template` - `{string=}`: Same as templateUrl, except this is an actual template string.
     *   - `targetEvent` - `{DOMClickEvent=}`: A click's event object. When passed in as an option,
     *     the location of the click will be used as the starting point for the opening animation
     *     of the the dialog.
     *   - `hasBackdrop` - `{boolean=}`: Whether there should be an opaque backdrop behind the dialog.
     *     Default true.
     *   - `clickOutsideToClose` - `{boolean=}`: Whether the user can click outside the dialog to
     *     close it. Default true.
     *   - `escapeToClose` - `{boolean=}`: Whether the user can press escape to close the dialog.
     *     Default true.
     *   - `controller` - `{string=}`: The controller to associate with the dialog. The controller
     *     will be injected with the local `$hideDialog`, which is a function used to hide the dialog.
     *   - `locals` - `{object=}`: An object containing key/value pairs. The keys will be used as names
     *     of values to inject into the controller. For example, `locals: {three: 3}` would inject
     *     `three` into the controller, with the value 3. If `bindToController` is true, they will be
     *     coppied to the controller instead.
     *   - `bindToController` - `bool`: bind the locals to the controller, instead of passing them in
     *   - `resolve` - `{object=}`: Similar to locals, except it takes promises as values, and the
     *     toast will not open until all of the promises resolve.
     *   - `controllerAs` - `{string=}`: An alias to assign the controller to on the scope.
     *   - `parent` - `{element=}`: The element to append the dialog to. Defaults to appending
     *     to the root element of the application.
     *   - `onComplete` `{function=}`: Callback function used to announce when the show() action is
     *     finished.
     *
     * @returns {promise} A promise that can be resolved with `$mdDialog.hide()` or
     * rejected with `mdDialog.cancel()`.
     */
    /**
     * @ngdoc method
     * @name $mdDialog#hide
     *
     * @description
     * Hide an existing dialog and resolve the promise returned from `$mdDialog.show()`.
     *
     * @param {*=} response An argument for the resolved promise.
     */
    /**
     * @ngdoc method
     * @name $mdDialog#cancel
     *
     * @description
     * Hide an existing dialog and reject the promise returned from `$mdDialog.show()`.
     *
     * @param {*=} response An argument for the rejected promise.
     */
    function MdDialogProvider( $$interimElementProvider ) {
        var alertDialogMethods = [ 'title', 'content', 'ariaLabel', 'ok' ];
        advancedDialogOptions.$inject = [ "$mdDialog" ];
        dialogDefaultOptions.$inject = [ "$timeout", "$rootElement", "$compile", "$animate", "$mdAria", "$document", "$mdUtil", "$mdConstant", "$mdTheming", "$$rAF", "$q", "$mdDialog" ];
        return $$interimElementProvider( '$mdDialog' ).setDefaults( {
            methods: [ 'hasBackdrop', 'clickOutsideToClose', 'escapeToClose', 'targetEvent' ],
            options: dialogDefaultOptions
        } ).addPreset( 'alert', {
            methods: [ 'title', 'content', 'ariaLabel', 'ok' ],
            options: advancedDialogOptions
        } ).addPreset( 'confirm', {
            methods: [ 'title', 'content', 'ariaLabel', 'ok', 'cancel' ],
            options: advancedDialogOptions
        } );
        /* @ngInject */
        function advancedDialogOptions( $mdDialog ) {
                return {
                    template: [
        '<md-dialog aria-label="{{dialog.label}}">',
          '<md-content>',
            '<h2>{{ dialog.title }}</h2>',
            '<p>{{ dialog.content }}</p>',
          '</md-content>',
          '<div class="md-actions">',
            '<md-button ng-if="dialog.$type == \'confirm\'" ng-click="dialog.abort()">',
              '{{ dialog.cancel }}',
            '</md-button>',
            '<md-button ng-click="dialog.hide()" class="md-primary">',
              '{{ dialog.ok }}',
            '</md-button>',
          '</div>',
        '</md-dialog>'
      ].join( '' ),
                    controller: function mdDialogCtrl() {
                        this.hide = function() {
                            $mdDialog.hide( true );
                        };
                        this.abort = function() {
                            $mdDialog.cancel();
                        };
                    },
                    controllerAs: 'dialog',
                    bindToController: true
                };
            }
            /* @ngInject */
        function dialogDefaultOptions( $timeout, $rootElement, $compile, $animate, $mdAria, $document, $mdUtil, $mdConstant, $mdTheming, $$rAF, $q, $mdDialog ) {
            return {
                hasBackdrop: true,
                isolateScope: true,
                onShow: onShow,
                onRemove: onRemove,
                clickOutsideToClose: true,
                escapeToClose: true,
                targetEvent: null,
                transformTemplate: function( template ) {
                    return '<div class="md-dialog-container">' + template + '</div>';
                }
            };
            // On show method for dialogs
            function onShow( scope, element, options ) {
                    // Incase the user provides a raw dom element, always wrap it in jqLite
                    options.parent = angular.element( options.parent );
                    options.popInTarget = angular.element( ( options.targetEvent || {} ).target );
                    var closeButton = findCloseButton();
                    configureAria( element.find( 'md-dialog' ) );
                    if ( options.hasBackdrop ) {
                        options.backdrop = angular.element( '<md-backdrop class="md-dialog-backdrop md-opaque">' );
                        $mdTheming.inherit( options.backdrop, options.parent );
                        $animate.enter( options.backdrop, options.parent );
                    }
                    return dialogPopIn( element, options.parent, options.popInTarget.length && options.popInTarget ).then( function() {
                        if ( options.escapeToClose ) {
                            options.rootElementKeyupCallback = function( e ) {
                                if ( e.keyCode === $mdConstant.KEY_CODE.ESCAPE ) {
                                    $timeout( $mdDialog.cancel );
                                }
                            };
                            $rootElement.on( 'keyup', options.rootElementKeyupCallback );
                        }
                        if ( options.clickOutsideToClose ) {
                            options.dialogClickOutsideCallback = function( e ) {
                                // Only close if we click the flex container outside the backdrop
                                if ( e.target === element[ 0 ] ) {
                                    $timeout( $mdDialog.cancel );
                                }
                            };
                            element.on( 'click', options.dialogClickOutsideCallback );
                        }
                        closeButton.focus();
                    } );

                    function findCloseButton() {
                        //If no element with class dialog-close, try to find the last
                        //button child in md-actions and assume it is a close button
                        var closeButton = element[ 0 ].querySelector( '.dialog-close' );
                        if ( !closeButton ) {
                            var actionButtons = element[ 0 ].querySelectorAll( '.md-actions button' );
                            closeButton = actionButtons[ actionButtons.length - 1 ];
                        }
                        return angular.element( closeButton );
                    }
                }
                // On remove function for all dialogs
            function onRemove( scope, element, options ) {
                    if ( options.backdrop ) {
                        $animate.leave( options.backdrop );
                    }
                    if ( options.escapeToClose ) {
                        $rootElement.off( 'keyup', options.rootElementKeyupCallback );
                    }
                    if ( options.clickOutsideToClose ) {
                        element.off( 'click', options.dialogClickOutsideCallback );
                    }
                    return dialogPopOut( element, options.parent, options.popInTarget.length && options.popInTarget ).then( function() {
                        options.scope.$destroy();
                        element.remove();
                        options.popInTarget && options.popInTarget.focus();
                    } );
                }
                /**
                 * Inject ARIA-specific attributes appropriate for Dialogs
                 */
            function configureAria( element ) {
                element.attr( {
                    'role': 'dialog'
                } );
                var dialogContent = element.find( 'md-content' );
                if ( dialogContent.length === 0 ) {
                    dialogContent = element;
                }
                $mdAria.expectAsync( element, 'aria-label', function() {
                    var words = dialogContent.text().split( /\s+/ );
                    if ( words.length > 3 ) words = words.slice( 0, 3 ).concat( '...' );
                    return words.join( ' ' );
                } );
            }

            function dialogPopIn( container, parentElement, clickElement ) {
                var dialogEl = container.find( 'md-dialog' );
                parentElement.append( container );
                transformToClickElement( dialogEl, clickElement );
                $$rAF( function() {
                    dialogEl.addClass( 'transition-in' ).css( $mdConstant.CSS.TRANSFORM, '' );
                } );
                return dialogTransitionEnd( dialogEl );
            }

            function dialogPopOut( container, parentElement, clickElement ) {
                var dialogEl = container.find( 'md-dialog' );
                dialogEl.addClass( 'transition-out' ).removeClass( 'transition-in' );
                transformToClickElement( dialogEl, clickElement );
                return dialogTransitionEnd( dialogEl );
            }

            function transformToClickElement( dialogEl, clickElement ) {
                if ( clickElement ) {
                    var clickRect = clickElement[ 0 ].getBoundingClientRect();
                    var dialogRect = dialogEl[ 0 ].getBoundingClientRect();
                    var scaleX = Math.min( 0.5, clickRect.width / dialogRect.width );
                    var scaleY = Math.min( 0.5, clickRect.height / dialogRect.height );
                    dialogEl.css( $mdConstant.CSS.TRANSFORM, 'translate3d(' + ( -dialogRect.left + clickRect.left + clickRect.width / 2 - dialogRect.width / 2 ) + 'px,' + ( -dialogRect.top + clickRect.top + clickRect.height / 2 - dialogRect.height / 2 ) + 'px,' + '0) scale(' + scaleX + ',' + scaleY + ')' );
                }
            }

            function dialogTransitionEnd( dialogEl ) {
                var deferred = $q.defer();
                dialogEl.on( $mdConstant.CSS.TRANSITIONEND, finished );

                function finished( ev ) {
                    //Make sure this transitionend didn't bubble up from a child
                    if ( ev.target === dialogEl[ 0 ] ) {
                        dialogEl.off( $mdConstant.CSS.TRANSITIONEND, finished );
                        deferred.resolve();
                    }
                }
                return deferred.promise;
            }
        }
    }
    MdDialogProvider.$inject = [ "$$interimElementProvider" ];
} )();
( function() {
    'use strict';
    /**
     * @ngdoc module
     * @name material.components.divider
     * @description Divider module!
     */
    angular.module( 'material.components.divider', [
  'material.core'
] ).directive( 'mdDivider', MdDividerDirective );

    function MdDividerController() {}
        /**
         * @ngdoc directive
         * @name mdDivider
         * @module material.components.divider
         * @restrict E
         *
         * @description
         * Dividers group and separate content within lists and page layouts using strong visual and spatial distinctions. This divider is a thin rule, lightweight enough to not distract the user from content.
         *
         * @param {boolean=} md-inset Add this attribute to activate the inset divider style.
         * @usage
         * <hljs lang="html">
         * <md-divider></md-divider>
         *
         * <md-divider md-inset></md-divider>
         * </hljs>
         *
         */
    function MdDividerDirective( $mdTheming ) {
        return {
            restrict: 'E',
            link: $mdTheming,
            controller: [ MdDividerController ]
        };
    }
    MdDividerDirective.$inject = [ "$mdTheming" ];
} )();
( function() {
    'use strict';
    /*
     * @ngdoc module
     * @name material.components.icon
     * @description
     * Icon
     */
    angular.module( 'material.components.icon', [
  'material.core'
] ).directive( 'mdIcon', mdIconDirective );
    /*
     * @ngdoc directive
     * @name mdIcon
     * @module material.components.icon
     *
     * @restrict E
     *
     * @description
     * The `<md-icon>` directive is an element useful for SVG icons
     *
     * @usage
     * <hljs lang="html">
     *  <md-icon icon="/img/icons/ic_access_time_24px.svg">
     *  </md-icon>
     * </hljs>
     *
     */
    function mdIconDirective() {
        return {
            restrict: 'E',
            template: '<object class="md-icon"></object>',
            compile: function( element, attr ) {
                var object = angular.element( element[ 0 ].children[ 0 ] );
                if ( angular.isDefined( attr.icon ) ) {
                    object.attr( 'data', attr.icon );
                }
            }
        };
    }
} )();
( function() {
    'use strict';
    /**
     * @ngdoc module
     * @name material.components.list
     * @description
     * List module
     */
    angular.module( 'material.components.list', [
  'material.core'
] ).directive( 'mdList', mdListDirective ).directive( 'mdItem', mdItemDirective );
    /**
     * @ngdoc directive
     * @name mdList
     * @module material.components.list
     *
     * @restrict E
     *
     * @description
     * The `<md-list>` directive is a list container for 1..n `<md-item>` tags.
     *
     * @usage
     * <hljs lang="html">
     * <md-list>
     *   <md-item ng-repeat="item in todos">
     *     <md-item-content>
     *       <div class="md-tile-left">
     *         <img ng-src="{{item.face}}" class="face" alt="{{item.who}}">
     *       </div>
     *       <div class="md-tile-content">
     *         <h3>{{item.what}}</h3>
     *         <h4>{{item.who}}</h4>
     *         <p>
     *           {{item.notes}}
     *         </p>
     *       </div>
     *     </md-item-content>
     *   </md-item>
     * </md-list>
     * </hljs>
     *
     */
    function mdListDirective() {
            return {
                restrict: 'E',
                link: function( $scope, $element, $attr ) {
                    $element.attr( {
                        'role': 'list'
                    } );
                }
            };
        }
        /**
         * @ngdoc directive
         * @name mdItem
         * @module material.components.list
         *
         * @restrict E
         *
         * @description
         * The `<md-item>` directive is a container intended for row items in a `<md-list>` container.
         *
         * @usage
         * <hljs lang="html">
         *  <md-list>
         *    <md-item>
         *            Item content in list
         *    </md-item>
         *  </md-list>
         * </hljs>
         *
         */
    function mdItemDirective() {
        return {
            restrict: 'E',
            link: function( $scope, $element, $attr ) {
                $element.attr( {
                    'role': 'listitem'
                } );
            }
        };
    }
} )();
( function() {
    'use strict';
    /**
     * @ngdoc module
     * @name material.components.progressCircular
     * @description Circular Progress module!
     */
    angular.module( 'material.components.progressCircular', [
  'material.core'
] ).directive( 'mdProgressCircular', MdProgressCircularDirective );
    /**
     * @ngdoc directive
     * @name mdProgressCircular
     * @module material.components.progressCircular
     * @restrict E
     *
     * @description
     * The circular progress directive is used to make loading content in your app as delightful and painless as possible by minimizing the amount of visual change a user sees before they can view and interact with content.
     *
     * For operations where the percentage of the operation completed can be determined, use a determinate indicator. They give users a quick sense of how long an operation will take.
     *
     * For operations where the user is asked to wait a moment while something finishes up, and its not necessary to expose what's happening behind the scenes and how long it will take, use an indeterminate indicator.
     *
     * @param {string} md-mode Select from one of two modes: determinate and indeterminate.
     * @param {number=} value In determinate mode, this number represents the percentage of the circular progress. Default: 0
     * @param {number=} md-diameter This specifies the diamter of the circular progress. Default: 48
     *
     * @usage
     * <hljs lang="html">
     * <md-progress-circular md-mode="determinate" value="..."></md-progress-circular>
     *
     * <md-progress-circular md-mode="determinate" ng-value="..."></md-progress-circular>
     *
     * <md-progress-circular md-mode="determinate" value="..." diameter="100"></md-progress-circular>
     *
     * <md-progress-circular md-mode="indeterminate"></md-progress-circular>
     * </hljs>
     */
    function MdProgressCircularDirective( $$rAF, $mdConstant, $mdTheming ) {
        var fillRotations = new Array( 101 ),
            fixRotations = new Array( 101 );
        for ( var i = 0; i < 101; i++ ) {
            var percent = i / 100;
            var rotation = Math.floor( percent * 180 );
            fillRotations[ i ] = 'rotate(' + rotation.toString() + 'deg)';
            fixRotations[ i ] = 'rotate(' + ( rotation * 2 ).toString() + 'deg)';
        }
        return {
            restrict: 'E',
            template: '<div class="md-spinner-wrapper">' + '<div class="md-inner">' + '<div class="md-gap"></div>' + '<div class="md-left">' + '<div class="md-half-circle"></div>' + '</div>' + '<div class="md-right">' + '<div class="md-half-circle"></div>' + '</div>' + '</div>' + '</div>',
            compile: compile
        };

        function compile( tElement, tAttrs, transclude ) {
            tElement.attr( 'aria-valuemin', 0 );
            tElement.attr( 'aria-valuemax', 100 );
            tElement.attr( 'role', 'progressbar' );
            return postLink;
        }

        function postLink( scope, element, attr ) {
            $mdTheming( element );
            var circle = element[ 0 ],
                fill = circle.querySelectorAll( '.md-fill, .md-mask.md-full' ),
                fix = circle.querySelectorAll( '.md-fill.md-fix' ),
                i, clamped, fillRotation, fixRotation;
            var diameter = attr.mdDiameter || 48;
            var scale = diameter / 48;
            circle.style[ $mdConstant.CSS.TRANSFORM ] = 'scale(' + scale.toString() + ')';
            attr.$observe( 'value', function( value ) {
                clamped = clamp( value );
                fillRotation = fillRotations[ clamped ];
                fixRotation = fixRotations[ clamped ];
                element.attr( 'aria-valuenow', clamped );
                for ( i = 0; i < fill.length; i++ ) {
                    fill[ i ].style[ $mdConstant.CSS.TRANSFORM ] = fillRotation;
                }
                for ( i = 0; i < fix.length; i++ ) {
                    fix[ i ].style[ $mdConstant.CSS.TRANSFORM ] = fixRotation;
                }
            } );
        }

        function clamp( value ) {
            if ( value > 100 ) {
                return 100;
            }
            if ( value < 0 ) {
                return 0;
            }
            return Math.ceil( value || 0 );
        }
    }
    MdProgressCircularDirective.$inject = [ "$$rAF", "$mdConstant", "$mdTheming" ];
} )();
( function() {
    'use strict';
    /**
     * @ngdoc module
     * @name material.components.progressLinear
     * @description Linear Progress module!
     */
    angular.module( 'material.components.progressLinear', [
  'material.core'
] ).directive( 'mdProgressLinear', MdProgressLinearDirective );
    /**
     * @ngdoc directive
     * @name mdProgressLinear
     * @module material.components.progressLinear
     * @restrict E
     *
     * @description
     * The linear progress directive is used to make loading content in your app as delightful and painless as possible by minimizing the amount of visual change a user sees before they can view and interact with content. Each operation should only be represented by one activity indicatorfor example, one refresh operation should not display both a refresh bar and an activity circle.
     *
     * For operations where the percentage of the operation completed can be determined, use a determinate indicator. They give users a quick sense of how long an operation will take.
     *
     * For operations where the user is asked to wait a moment while something finishes up, and its not necessary to expose what's happening behind the scenes and how long it will take, use an indeterminate indicator.
     *
     * @param {string} md-mode Select from one of four modes: determinate, indeterminate, buffer or query.
     * @param {number=} value In determinate and buffer modes, this number represents the percentage of the primary progress bar. Default: 0
     * @param {number=} md-buffer-value In the buffer mode, this number represents the precentage of the secondary progress bar. Default: 0
     *
     * @usage
     * <hljs lang="html">
     * <md-progress-linear md-mode="determinate" value="..."></md-progress-linear>
     *
     * <md-progress-linear md-mode="determinate" ng-value="..."></md-progress-linear>
     *
     * <md-progress-linear md-mode="indeterminate"></md-progress-linear>
     *
     * <md-progress-linear md-mode="buffer" value="..." md-buffer-value="..."></md-progress-linear>
     *
     * <md-progress-linear md-mode="query"></md-progress-linear>
     * </hljs>
     */
    function MdProgressLinearDirective( $$rAF, $mdConstant, $mdTheming ) {
        return {
            restrict: 'E',
            template: '<div class="md-container">' + '<div class="md-dashed"></div>' + '<div class="md-bar md-bar1"></div>' + '<div class="md-bar md-bar2"></div>' + '</div>',
            compile: compile
        };

        function compile( tElement, tAttrs, transclude ) {
            tElement.attr( 'aria-valuemin', 0 );
            tElement.attr( 'aria-valuemax', 100 );
            tElement.attr( 'role', 'progressbar' );
            return postLink;
        }

        function postLink( scope, element, attr ) {
            $mdTheming( element );
            var bar1Style = element[ 0 ].querySelector( '.md-bar1' ).style,
                bar2Style = element[ 0 ].querySelector( '.md-bar2' ).style,
                container = angular.element( element[ 0 ].querySelector( '.md-container' ) );
            attr.$observe( 'value', function( value ) {
                if ( attr.mdMode == 'query' ) {
                    return;
                }
                var clamped = clamp( value );
                element.attr( 'aria-valuenow', clamped );
                bar2Style[ $mdConstant.CSS.TRANSFORM ] = transforms[ clamped ];
            } );
            attr.$observe( 'mdBufferValue', function( value ) {
                bar1Style[ $mdConstant.CSS.TRANSFORM ] = transforms[ clamp( value ) ];
            } );
            $$rAF( function() {
                container.addClass( 'md-ready' );
            } );
        }

        function clamp( value ) {
            if ( value > 100 ) {
                return 100;
            }
            if ( value < 0 ) {
                return 0;
            }
            return Math.ceil( value || 0 );
        }
    }
    MdProgressLinearDirective.$inject = [ "$$rAF", "$mdConstant", "$mdTheming" ];
    // **********************************************************
    // Private Methods
    // **********************************************************
    var transforms = ( function() {
        var values = new Array( 101 );
        for ( var i = 0; i < 101; i++ ) {
            values[ i ] = makeTransform( i );
        }
        return values;

        function makeTransform( value ) {
            var scale = value / 100;
            var translateX = ( value - 100 ) / 2;
            return 'translateX(' + translateX.toString() + '%) scale(' + scale.toString() + ', 1)';
        }
    } )();
} )();
( function() {
    'use strict';
    /**
     * @ngdoc module
     * @name material.components.radioButton
     * @description radioButton module!
     */
    angular.module( 'material.components.radioButton', [
  'material.core'
] ).directive( 'mdRadioGroup', mdRadioGroupDirective ).directive( 'mdRadioButton', mdRadioButtonDirective );
    /**
     * @ngdoc directive
     * @module material.components.radioButton
     * @name mdRadioGroup
     *
     * @restrict E
     *
     * @description
     * The `<md-radio-group>` directive identifies a grouping
     * container for the 1..n grouped radio buttons; specified using nested
     * `<md-radio-button>` tags.
     *
     * Note: `<md-radio-group>` and `<md-radio-button>` handle tabindex differently
     * than the native `<input type='radio'>` controls. Whereas the native controls
     * force the user to tab through all the radio buttons, `<md-radio-group>`
     * is focusable, and by default the `<md-radio-button>`s are not.
     *
     * @param {string} ng-model Assignable angular expression to data-bind to.
     * @param {boolean=} md-no-ink Use of attribute indicates flag to disable ink ripple effects.
     *
     * @usage
     * <hljs lang="html">
     * <md-radio-group ng-model="selected">
     *
     *   <md-radio-button
     *        ng-repeat="d in colorOptions"
     *        ng-value="d.value" aria-label="{{ d.label }}">
     *
     *          {{ d.label }}
     *
     *   </md-radio-button>
     *
     * </md-radio-group>
     * </hljs>
     *
     */
    function mdRadioGroupDirective( $mdUtil, $mdConstant, $mdTheming ) {
        RadioGroupController.prototype = createRadioGroupControllerProto();
        return {
            restrict: 'E',
            controller: [ '$element', RadioGroupController ],
            require: [ 'mdRadioGroup', '?ngModel' ],
            link: linkRadioGroup
        };

        function linkRadioGroup( scope, element, attr, ctrls ) {
            $mdTheming( element );
            var rgCtrl = ctrls[ 0 ],
                ngModelCtrl = ctrls[ 1 ] || {
                    $setViewValue: angular.noop
                };

            function keydownListener( ev ) {
                if ( ev.keyCode === $mdConstant.KEY_CODE.LEFT_ARROW || ev.keyCode === $mdConstant.KEY_CODE.UP_ARROW ) {
                    ev.preventDefault();
                    rgCtrl.selectPrevious();
                } else if ( ev.keyCode === $mdConstant.KEY_CODE.RIGHT_ARROW || ev.keyCode === $mdConstant.KEY_CODE.DOWN_ARROW ) {
                    ev.preventDefault();
                    rgCtrl.selectNext();
                }
            }
            rgCtrl.init( ngModelCtrl );
            element.attr( {
                'role': 'radiogroup',
                'tabIndex': element.attr( 'tabindex' ) || '0'
            } ).on( 'keydown', keydownListener );
        }

        function RadioGroupController( $element ) {
            this._radioButtonRenderFns = [];
            this.$element = $element;
        }

        function createRadioGroupControllerProto() {
                return {
                    init: function( ngModelCtrl ) {
                        this._ngModelCtrl = ngModelCtrl;
                        this._ngModelCtrl.$render = angular.bind( this, this.render );
                    },
                    add: function( rbRender ) {
                        this._radioButtonRenderFns.push( rbRender );
                    },
                    remove: function( rbRender ) {
                        var index = this._radioButtonRenderFns.indexOf( rbRender );
                        if ( index !== -1 ) {
                            this._radioButtonRenderFns.splice( index, 1 );
                        }
                    },
                    render: function() {
                        this._radioButtonRenderFns.forEach( function( rbRender ) {
                            rbRender();
                        } );
                    },
                    setViewValue: function( value, eventType ) {
                        this._ngModelCtrl.$setViewValue( value, eventType );
                        // update the other radio buttons as well
                        this.render();
                    },
                    getViewValue: function() {
                        return this._ngModelCtrl.$viewValue;
                    },
                    selectNext: function() {
                        return changeSelectedButton( this.$element, 1 );
                    },
                    selectPrevious: function() {
                        return changeSelectedButton( this.$element, -1 );
                    },
                    setActiveDescendant: function( radioId ) {
                        this.$element.attr( 'aria-activedescendant', radioId );
                    }
                };
            }
            /**
             * Change the radio group's selected button by a given increment.
             * If no button is selected, select the first button.
             */
        function changeSelectedButton( parent, increment ) {
            // Coerce all child radio buttons into an array, then wrap then in an iterator
            var buttons = $mdUtil.iterator( Array.prototype.slice.call( parent[ 0 ].querySelectorAll( 'md-radio-button' ) ), true );
            if ( buttons.count() ) {
                var selected = parent[ 0 ].querySelector( 'md-radio-button.md-checked' );
                var target = buttons[ increment < 0 ? 'previous' : 'next' ]( selected ) || buttons.first();
                // Activate radioButton's click listener (triggerHandler won't create a real click event)
                angular.element( target ).triggerHandler( 'click' );
            }
        }
    }
    mdRadioGroupDirective.$inject = [ "$mdUtil", "$mdConstant", "$mdTheming" ];
    /**
     * @ngdoc directive
     * @module material.components.radioButton
     * @name mdRadioButton
     *
     * @restrict E
     *
     * @description
     * The `<md-radio-button>`directive is the child directive required to be used within `<md-radio-group>` elements.
     *
     * While similar to the `<input type="radio" ng-model="" value="">` directive,
     * the `<md-radio-button>` directive provides ink effects, ARIA support, and
     * supports use within named radio groups.
     *
     * @param {string} ngModel Assignable angular expression to data-bind to.
     * @param {string=} ngChange Angular expression to be executed when input changes due to user
     *    interaction with the input element.
     * @param {string} ngValue Angular expression which sets the value to which the expression should
     *    be set when selected.*
     * @param {string} value The value to which the expression should be set when selected.
     * @param {string=} name Property name of the form under which the control is published.
     * @param {string=} ariaLabel Adds label to radio button for accessibility.
     * Defaults to radio button's text. If no default text is found, a warning will be logged.
     *
     * @usage
     * <hljs lang="html">
     *
     * <md-radio-button value="1" aria-label="Label 1">
     *   Label 1
     * </md-radio-button>
     *
     * <md-radio-button ng-model="color" ng-value="specialValue" aria-label="Green">
     *   Green
     * </md-radio-button>
     *
     * </hljs>
     *
     */
    function mdRadioButtonDirective( $mdAria, $mdUtil, $mdTheming ) {
        var CHECKED_CSS = 'md-checked';
        return {
            restrict: 'E',
            require: '^mdRadioGroup',
            transclude: true,
            template: '<div class="md-container" md-ink-ripple md-ink-ripple-checkbox>' + '<div class="md-off"></div>' + '<div class="md-on"></div>' + '</div>' + '<div ng-transclude class="md-label"></div>',
            link: link
        };

        function link( scope, element, attr, rgCtrl ) {
            var lastChecked;
            $mdTheming( element );
            configureAria( element, scope );
            rgCtrl.add( render );
            attr.$observe( 'value', render );
            element.on( 'click', listener ).on( '$destroy', function() {
                rgCtrl.remove( render );
            } );

            function listener( ev ) {
                if ( element[ 0 ].hasAttribute( 'disabled' ) ) return;
                scope.$apply( function() {
                    rgCtrl.setViewValue( attr.value, ev && ev.type );
                } );
            }

            function render() {
                    var checked = ( rgCtrl.getViewValue() === attr.value );
                    if ( checked === lastChecked ) {
                        return;
                    }
                    lastChecked = checked;
                    element.attr( 'aria-checked', checked );
                    if ( checked ) {
                        element.addClass( CHECKED_CSS );
                        rgCtrl.setActiveDescendant( element.attr( 'id' ) );
                    } else {
                        element.removeClass( CHECKED_CSS );
                    }
                }
                /**
                 * Inject ARIA-specific attributes appropriate for each radio button
                 */
            function configureAria( element, scope ) {
                scope.ariaId = buildAriaID();
                element.attr( {
                    'id': scope.ariaId,
                    'role': 'radio',
                    'aria-checked': 'false'
                } );
                $mdAria.expectWithText( element, 'aria-label' );
                /**
                 * Build a unique ID for each radio button that will be used with aria-activedescendant.
                 * Preserve existing ID if already specified.
                 * @returns {*|string}
                 */
                function buildAriaID() {
                    return attr.id || ( 'radio' + "_" + $mdUtil.nextUid() );
                }
            }
        }
    }
    mdRadioButtonDirective.$inject = [ "$mdAria", "$mdUtil", "$mdTheming" ];
} )();
( function() {
    'use strict';
    /**
     * @ngdoc module
     * @name material.components.sidenav
     *
     * @description
     * A Sidenav QP component.
     */
    angular.module( 'material.components.sidenav', [
  'material.core',
  'material.components.backdrop'
] ).factory( '$mdSidenav', mdSidenavService ).directive( 'mdSidenav', mdSidenavDirective ).controller( '$mdSidenavController', mdSidenavController ).factory( '$mdMedia', mdMediaFactory ).factory( '$mdComponentRegistry', mdComponentRegistry );
    /*
     * @private
     * @ngdoc object
     * @name mdSidenavController
     * @module material.components.sidenav
     *
     * @description
     * The controller for mdSidenav components.
     */
    function mdSidenavController( $scope, $element, $attrs, $timeout, $mdSidenav, $mdComponentRegistry ) {
        var self = this;
        self.destroy = $mdComponentRegistry.register( self, $attrs.mdComponentId );
        self.isOpen = function() {
            return !!$scope.isOpen;
        };
        self.toggle = function() {
            $scope.isOpen = !$scope.isOpen;
        };
        self.open = function() {
            $scope.isOpen = true;
        };
        self.close = function() {
            $scope.isOpen = false;
        };
    }
    mdSidenavController.$inject = [ "$scope", "$element", "$attrs", "$timeout", "$mdSidenav", "$mdComponentRegistry" ];
    /*
     * @private
     * @ngdoc service
     * @name $mdSidenav
     * @module material.components.sidenav
     *
     * @description
     * $mdSidenav makes it easy to interact with multiple sidenavs
     * in an app.
     *
     * @usage
     *
     * ```javascript
     * // Toggle the given sidenav
     * $mdSidenav(componentId).toggle();
     *
     * // Open the given sidenav
     * $mdSidenav(componentId).open();
     *
     * // Close the given sidenav
     * $mdSidenav(componentId).close();
     * ```
     */
    function mdSidenavService( $mdComponentRegistry ) {
        return function( handle ) {
            var instance = $mdComponentRegistry.get( handle );
            if ( !instance ) {
                $mdComponentRegistry.notFoundError( handle );
            }
            return {
                isOpen: function() {
                    return instance && instance.isOpen();
                },
                toggle: function() {
                    instance && instance.toggle();
                },
                open: function() {
                    instance && instance.open();
                },
                close: function() {
                    instance && instance.close();
                }
            };
        };
    }
    mdSidenavService.$inject = [ "$mdComponentRegistry" ];
    /**
     * @ngdoc directive
     * @name mdSidenav
     * @module material.components.sidenav
     * @restrict E
     *
     * @description
     *
     * A Sidenav component that can be opened and closed programatically.
     *
     * By default, upon opening it will slide out on top of the main content area.
     *
     * @usage
     * <hljs lang="html">
     * <div layout="row" ng-controller="MyController">
     *   <md-sidenav md-component-id="left" class="md-sidenav-left">
     *     Left Nav!
     *   </md-sidenav>
     *
     *   <md-content>
     *     Center Content
     *     <md-button ng-click="openLeftMenu()">
     *       Open Left Menu
     *     </md-button>
     *   </md-content>
     *
     *   <md-sidenav md-component-id="right"
     *     md-is-locked-open="$media('min-width: 333px')"
     *     class="md-sidenav-right">
     *     Right Nav!
     *   </md-sidenav>
     * </div>
     * </hljs>
     *
     * <hljs lang="js">
     * var app = angular.module('myApp', ['ngMaterial']);
     * app.controller('MyController', function($scope, $mdSidenav) {
     *   $scope.openLeftMenu = function() {
     *     $mdSidenav('left').toggle();
     *   };
     * });
     * </hljs>
     *
     * @param {expression=} md-is-open A model bound to whether the sidenav is opened.
     * @param {string=} md-component-id componentId to use with $mdSidenav service.
     * @param {expression=} md-is-locked-open When this expression evalutes to true,
     * the sidenav 'locks open': it falls into the content's flow instead
     * of appearing over it. This overrides the `is-open` attribute.
     *
     * A $media() function is exposed to the is-locked-open attribute, which
     * can be given a media query or one of the `sm`, `gt-sm`, `md`, `gt-md`, `lg` or `gt-lg` presets.
     * Examples:
     *
     *   - `<md-sidenav md-is-locked-open="shouldLockOpen"></md-sidenav>`
     *   - `<md-sidenav md-is-locked-open="$media('min-width: 1000px')"></md-sidenav>`
     *   - `<md-sidenav md-is-locked-open="$media('sm')"></md-sidenav>` (locks open on small screens)
     */
    function mdSidenavDirective( $timeout, $animate, $parse, $mdMedia, $mdConstant, $compile, $mdTheming ) {
        return {
            restrict: 'E',
            scope: {
                isOpen: '=?mdIsOpen'
            },
            controller: '$mdSidenavController',
            compile: function( element ) {
                element.addClass( 'md-closed' );
                element.attr( 'tabIndex', '-1' );
                return postLink;
            }
        };

        function postLink( scope, element, attr, sidenavCtrl ) {
            var isLockedOpenParsed = $parse( attr.mdIsLockedOpen );
            var backdrop = $compile( '<md-backdrop class="md-sidenav-backdrop md-opaque ng-enter">' )( scope );
            $mdTheming.inherit( backdrop, element );
            element.on( '$destroy', sidenavCtrl.destroy );
            scope.$watch( 'isOpen', setOpen );
            scope.$watch( function() {
                return isLockedOpenParsed( scope.$parent, {
                    $media: $mdMedia
                } );
            }, function( isLocked ) {
                element.toggleClass( 'md-locked-open', !!isLocked );
                backdrop.toggleClass( 'md-locked-open', !!isLocked );
            } );
            /**
             * Toggle the SideNav view and attach/detach listeners
             * @param isOpen
             */
            function setOpen( isOpen ) {
                    var parent = element.parent();
                    parent[ isOpen ? 'on' : 'off' ]( 'keydown', onKeyDown );
                    $animate[ isOpen ? 'enter' : 'leave' ]( backdrop, parent );
                    backdrop[ isOpen ? 'on' : 'off' ]( 'click', close );
                    $animate[ isOpen ? 'removeClass' : 'addClass' ]( element, 'md-closed' ).then( function() {
                        // If we opened, and haven't closed again before the animation finished
                        if ( scope.isOpen ) {
                            element.focus();
                        }
                    } );
                }
                /**
                 * Auto-close sideNav when the `escape` key is pressed.
                 * @param evt
                 */
            function onKeyDown( ev ) {
                    if ( ev.keyCode === $mdConstant.KEY_CODE.ESCAPE ) {
                        close();
                        ev.preventDefault();
                        ev.stopPropagation();
                    }
                }
                /**
                 * With backdrop `clicks` or `escape` key-press, immediately
                 * apply the CSS close transition... Then notify the controller
                 * to close() and perform its own actions.
                 */
            function close() {
                $timeout( function() {
                    sidenavCtrl.close();
                } );
            }
        }
    }
    mdSidenavDirective.$inject = [ "$timeout", "$animate", "$parse", "$mdMedia", "$mdConstant", "$compile", "$mdTheming" ];
    /**
     * Exposes a function on the '$mdMedia' service which will return true or false,
     * whether the given media query matches. Re-evaluates on resize. Allows presets
     * for 'sm', 'md', 'lg'.
     *
     * @example $mdMedia('sm') == true if device-width <= sm
     * @example $mdMedia('(min-width: 1200px)') == true if device-width >= 1200px
     * @example $mdMedia('max-width: 300px') == true if device-width <= 300px (sanitizes input, adding parens)
     */
    function mdMediaFactory( $window, $mdUtil, $timeout, $mdConstant ) {
        var cache = $mdUtil.cacheFactory( '$mdMedia', {
            capacity: 15
        } );
        angular.element( $window ).on( 'resize', updateAll );
        return $mdMedia;

        function $mdMedia( query ) {
            query = validate( query );
            var result;
            if ( !angular.isDefined( result = cache.get( query ) ) ) {
                return add( query );
            }
            return result;
        }

        function validate( query ) {
            return $mdConstant.MEDIA[ query ] || ( query.charAt( 0 ) != '(' ? ( '(' + query + ')' ) : query );
        }

        function add( query ) {
            return cache.put( query, !!$window.matchMedia( query ).matches );
        }

        function updateAll() {
            var keys = cache.keys();
            if ( keys.length ) {
                for ( var i = 0, ii = keys.length; i < ii; i++ ) {
                    cache.put( keys[ i ], !!$window.matchMedia( keys[ i ] ).matches );
                }
                // trigger a $digest()
                $timeout( angular.noop );
            }
        }
    }
    mdMediaFactory.$inject = [ "$window", "$mdUtil", "$timeout", "$mdConstant" ];

    function mdComponentRegistry( $log ) {
        var instances = [];
        return {
            /**
             * Used to print an error when an instance for a handle isn't found.
             */
            notFoundError: function( handle ) {
                $log.error( 'No instance found for handle', handle );
            },
            /**
             * Return all registered instances as an array.
             */
            getInstances: function() {
                return instances;
            },
            /**
             * Get a registered instance.
             * @param handle the String handle to look up for a registered instance.
             */
            get: function( handle ) {
                var i, j, instance;
                for ( i = 0, j = instances.length; i < j; i++ ) {
                    instance = instances[ i ];
                    if ( instance.$$mdHandle === handle ) {
                        return instance;
                    }
                }
                return null;
            },
            /**
             * Register an instance.
             * @param instance the instance to register
             * @param handle the handle to identify the instance under.
             */
            register: function( instance, handle ) {
                instance.$$mdHandle = handle;
                instances.push( instance );
                return function deregister() {
                    var index = instances.indexOf( instance );
                    if ( index !== -1 ) {
                        instances.splice( index, 1 );
                    }
                };
            }
        };
    }
    mdComponentRegistry.$inject = [ "$log" ];
} )();
( function() {
    'use strict';
    /**
     * @ngdoc module
     * @name material.components.slider
     */
    angular.module( 'material.components.slider', [
  'material.core'
] ).directive( 'mdSlider', SliderDirective );
    /**
     * @ngdoc directive
     * @name mdSlider
     * @module material.components.slider
     * @restrict E
     * @description
     * The `<md-slider>` component allows the user to choose from a range of
     * values.
     *
     * It has two modes: 'normal' mode, where the user slides between a wide range
     * of values, and 'discrete' mode, where the user slides between only a few
     * select values.
     *
     * To enable discrete mode, add the `md-discrete` attribute to a slider,
     * and use the `step` attribute to change the distance between
     * values the user is allowed to pick.
     *
     * @usage
     * <h4>Normal Mode</h4>
     * <hljs lang="html">
     * <md-slider ng-model="myValue" min="5" max="500">
     * </md-slider>
     * </hljs>
     * <h4>Discrete Mode</h4>
     * <hljs lang="html">
     * <md-slider md-discrete ng-model="myDiscreteValue" step="10" min="10" max="130">
     * </md-slider>
     * </hljs>
     *
     * @param {boolean=} md-discrete Whether to enable discrete mode.
     * @param {number=} step The distance between values the user is allowed to pick. Default 1.
     * @param {number=} min The minimum value the user is allowed to pick. Default 0.
     * @param {number=} max The maximum value the user is allowed to pick. Default 100.
     */
    function SliderDirective( $mdTheming ) {
        return {
            scope: {},
            require: [ '?ngModel', 'mdSlider' ],
            controller: SliderController,
            template: '<div class="md-track-container">' + '<div class="md-track"></div>' + '<div class="md-track md-track-fill"></div>' + '<div class="md-track-ticks"></div>' + '</div>' + '<div class="md-thumb-container">' + '<div class="md-thumb"></div>' + '<div class="md-focus-thumb"></div>' + '<div class="md-focus-ring"></div>' + '<div class="md-sign">' + '<span class="md-thumb-text"></span>' + '</div>' + '<div class="md-disabled-thumb"></div>' + '</div>',
            link: postLink
        };

        function postLink( scope, element, attr, ctrls ) {
            $mdTheming( element );
            var ngModelCtrl = ctrls[ 0 ] || {
                // Mock ngModelController if it doesn't exist to give us
                // the minimum functionality needed
                $setViewValue: function( val ) {
                    this.$viewValue = val;
                    this.$viewChangeListeners.forEach( function( cb ) {
                        cb();
                    } );
                },
                $parsers: [],
                $formatters: [],
                $viewChangeListeners: []
            };
            var sliderCtrl = ctrls[ 1 ];
            sliderCtrl.init( ngModelCtrl );
        }
    }
    SliderDirective.$inject = [ "$mdTheming" ];
    /**
     * We use a controller for all the logic so that we can expose a few
     * things to unit tests
     */
    function SliderController( $scope, $element, $attrs, $$rAF, $window, $mdAria, $mdUtil, $mdConstant ) {
        this.init = function init( ngModelCtrl ) {
            var thumb = angular.element( $element[ 0 ].querySelector( '.md-thumb' ) );
            var thumbText = angular.element( $element[ 0 ].querySelector( '.md-thumb-text' ) );
            var thumbContainer = thumb.parent();
            var trackContainer = angular.element( $element[ 0 ].querySelector( '.md-track-container' ) );
            var activeTrack = angular.element( $element[ 0 ].querySelector( '.md-track-fill' ) );
            var tickContainer = angular.element( $element[ 0 ].querySelector( '.md-track-ticks' ) );
            var throttledRefreshDimensions = $mdUtil.throttle( refreshSliderDimensions, 5000 );
            // Default values, overridable by $attrss
            $attrs.min ? $attrs.$observe( 'min', updateMin ) : updateMin( 0 );
            $attrs.max ? $attrs.$observe( 'max', updateMax ) : updateMax( 100 );
            $attrs.step ? $attrs.$observe( 'step', updateStep ) : updateStep( 1 );
            // We have to manually stop the $watch on ngDisabled because it exists
            // on the parent $scope, and won't be automatically destroyed when
            // the component is destroyed.
            var stopDisabledWatch = angular.noop;
            if ( $attrs.ngDisabled ) {
                stopDisabledWatch = $scope.$parent.$watch( $attrs.ngDisabled, updateAriaDisabled );
            }
            $mdAria.expect( $element, 'aria-label' );
            $element.attr( 'tabIndex', 0 );
            $element.attr( 'role', 'slider' );
            $element.on( 'keydown', keydownListener );
            var hammertime = new Hammer( $element[ 0 ], {
                recognizers: [
        [ Hammer.Pan, {
                        direction: Hammer.DIRECTION_HORIZONTAL
                    } ]
      ]
            } );
            hammertime.on( 'hammer.input', onInput );
            hammertime.on( 'panstart', onPanStart );
            hammertime.on( 'pan', onPan );
            hammertime.on( 'panend', onPanEnd );
            // On resize, recalculate the slider's dimensions and re-render
            function updateAll() {
                refreshSliderDimensions();
                ngModelRender();
                redrawTicks();
            }
            setTimeout( updateAll );
            var debouncedUpdateAll = $$rAF.debounce( updateAll );
            angular.element( $window ).on( 'resize', debouncedUpdateAll );
            $scope.$on( '$destroy', function() {
                angular.element( $window ).off( 'resize', debouncedUpdateAll );
                hammertime.destroy();
                stopDisabledWatch();
            } );
            ngModelCtrl.$render = ngModelRender;
            ngModelCtrl.$viewChangeListeners.push( ngModelRender );
            ngModelCtrl.$formatters.push( minMaxValidator );
            ngModelCtrl.$formatters.push( stepValidator );
            /**
             * Attributes
             */
            var min;
            var max;
            var step;

            function updateMin( value ) {
                min = parseFloat( value );
                $element.attr( 'aria-valuemin', value );
                updateAll();
            }

            function updateMax( value ) {
                max = parseFloat( value );
                $element.attr( 'aria-valuemax', value );
                updateAll();
            }

            function updateStep( value ) {
                step = parseFloat( value );
                redrawTicks();
            }

            function updateAriaDisabled( isDisabled ) {
                    $element.attr( 'aria-disabled', !!isDisabled );
                }
                // Draw the ticks with canvas.
                // The alternative to drawing ticks with canvas is to draw one $element for each tick,
                // which could quickly become a performance bottleneck.
            var tickCanvas, tickCtx;

            function redrawTicks() {
                    if ( !angular.isDefined( $attrs.mdDiscrete ) ) return;
                    var numSteps = Math.floor( ( max - min ) / step );
                    if ( !tickCanvas ) {
                        tickCanvas = angular.element( '<canvas style="position:absolute;">' );
                        tickCtx = tickCanvas[ 0 ].getContext( '2d' );
                        tickCtx.fillStyle = 'black';
                        tickContainer.append( tickCanvas );
                    }
                    var dimensions = getSliderDimensions();
                    tickCanvas[ 0 ].width = dimensions.width;
                    tickCanvas[ 0 ].height = dimensions.height;
                    var distance;
                    for ( var i = 0; i <= numSteps; i++ ) {
                        distance = Math.floor( dimensions.width * ( i / numSteps ) );
                        tickCtx.fillRect( distance - 1, 0, 2, dimensions.height );
                    }
                }
                /**
                 * Refreshing Dimensions
                 */
            var sliderDimensions = {};
            refreshSliderDimensions();

            function refreshSliderDimensions() {
                sliderDimensions = trackContainer[ 0 ].getBoundingClientRect();
            }

            function getSliderDimensions() {
                    throttledRefreshDimensions();
                    return sliderDimensions;
                }
                /**
                 * left/right arrow listener
                 */
            function keydownListener( ev ) {
                    if ( $element[ 0 ].hasAttribute( 'disabled' ) ) {
                        return;
                    }
                    var changeAmount;
                    if ( ev.keyCode === $mdConstant.KEY_CODE.LEFT_ARROW ) {
                        changeAmount = -step;
                    } else if ( ev.keyCode === $mdConstant.KEY_CODE.RIGHT_ARROW ) {
                        changeAmount = step;
                    }
                    if ( changeAmount ) {
                        if ( ev.metaKey || ev.ctrlKey || ev.altKey ) {
                            changeAmount *= 4;
                        }
                        ev.preventDefault();
                        ev.stopPropagation();
                        $scope.$evalAsync( function() {
                            setModelValue( ngModelCtrl.$viewValue + changeAmount );
                        } );
                    }
                }
                /**
                 * ngModel setters and validators
                 */
            function setModelValue( value ) {
                ngModelCtrl.$setViewValue( minMaxValidator( stepValidator( value ) ) );
            }

            function ngModelRender() {
                if ( isNaN( ngModelCtrl.$viewValue ) ) {
                    ngModelCtrl.$viewValue = ngModelCtrl.$modelValue;
                }
                var percent = ( ngModelCtrl.$viewValue - min ) / ( max - min );
                $scope.modelValue = ngModelCtrl.$viewValue;
                $element.attr( 'aria-valuenow', ngModelCtrl.$viewValue );
                setSliderPercent( percent );
                thumbText.text( ngModelCtrl.$viewValue );
            }

            function minMaxValidator( value ) {
                if ( angular.isNumber( value ) ) {
                    return Math.max( min, Math.min( max, value ) );
                }
            }

            function stepValidator( value ) {
                    if ( angular.isNumber( value ) ) {
                        return Math.round( value / step ) * step;
                    }
                }
                /**
                 * @param percent 0-1
                 */
            function setSliderPercent( percent ) {
                    activeTrack.css( 'width', ( percent * 100 ) + '%' );
                    thumbContainer.css( $mdConstant.CSS.TRANSFORM, 'translate3d(' + getSliderDimensions().width * percent + 'px,0,0)' );
                    $element.toggleClass( 'md-min', percent === 0 );
                }
                /**
                 * Slide listeners
                 */
            var isSliding = false;
            var isDiscrete = angular.isDefined( $attrs.mdDiscrete );

            function onInput( ev ) {
                if ( !isSliding && ev.eventType === Hammer.INPUT_START && !$element[ 0 ].hasAttribute( 'disabled' ) ) {
                    isSliding = true;
                    $element.addClass( 'active' );
                    $element[ 0 ].focus();
                    refreshSliderDimensions();
                    onPan( ev );
                    ev.srcEvent.stopPropagation();
                } else if ( isSliding && ev.eventType === Hammer.INPUT_END ) {
                    if ( isSliding && isDiscrete ) onPanEnd( ev );
                    isSliding = false;
                    $element.removeClass( 'panning active' );
                }
            }

            function onPanStart() {
                if ( !isSliding ) return;
                $element.addClass( 'panning' );
            }

            function onPan( ev ) {
                if ( !isSliding ) return;
                // While panning discrete, update only the
                // visual positioning but not the model value.
                if ( isDiscrete ) adjustThumbPosition( ev.center.x );
                else doSlide( ev.center.x );
                ev.preventDefault();
                ev.srcEvent.stopPropagation();
            }

            function onPanEnd( ev ) {
                    if ( isDiscrete && !$element[ 0 ].hasAttribute( 'disabled' ) ) {
                        // Convert exact to closest discrete value.
                        // Slide animate the thumb... and then update the model value.
                        var exactVal = percentToValue( positionToPercent( ev.center.x ) );
                        var closestVal = minMaxValidator( stepValidator( exactVal ) );
                        setSliderPercent( valueToPercent( closestVal ) );
                        $$rAF( function() {
                            setModelValue( closestVal );
                        } );
                        ev.preventDefault();
                        ev.srcEvent.stopPropagation();
                    }
                }
                /**
                 * Expose for testing
                 */
            this._onInput = onInput;
            this._onPanStart = onPanStart;
            this._onPan = onPan;
            /**
             * Slide the UI by changing the model value
             * @param x
             */
            function doSlide( x ) {
                    $scope.$evalAsync( function() {
                        setModelValue( percentToValue( positionToPercent( x ) ) );
                    } );
                }
                /**
                 * Slide the UI without changing the model (while dragging/panning)
                 * @param x
                 */
            function adjustThumbPosition( x ) {
                    var exactVal = percentToValue( positionToPercent( x ) );
                    var closestVal = minMaxValidator( stepValidator( exactVal ) );
                    setSliderPercent( positionToPercent( x ) );
                    thumbText.text( closestVal );
                }
                /**
                 * Convert horizontal position on slider to percentage value of offset from beginning...
                 * @param x
                 * @returns {number}
                 */
            function positionToPercent( x ) {
                    return Math.max( 0, Math.min( 1, ( x - sliderDimensions.left ) / ( sliderDimensions.width ) ) );
                }
                /**
                 * Convert percentage offset on slide to equivalent model value
                 * @param percent
                 * @returns {*}
                 */
            function percentToValue( percent ) {
                return ( min + percent * ( max - min ) );
            }

            function valueToPercent( val ) {
                return ( val - min ) / ( max - min );
            }
        };
    }
    SliderController.$inject = [ "$scope", "$element", "$attrs", "$$rAF", "$window", "$mdAria", "$mdUtil", "$mdConstant" ];
} )();
( function() {
    'use strict';
    /*
     * @ngdoc module
     * @name material.components.sticky
     * @description
     *
     * Sticky effects for md
     */
    angular.module( 'material.components.sticky', [
  'material.core',
  'material.components.content'
] ).factory( '$mdSticky', MdSticky );
    /*
     * @ngdoc service
     * @name $mdSticky
     * @module material.components.sticky
     *
     * @description
     * The `$mdSticky`service provides a mixin to make elements sticky.
     *
     * @returns A `$mdSticky` function that takes three arguments:
     *   - `scope`
     *   - `element`: The element that will be 'sticky'
     *   - `elementClone`: A clone of the element, that will be shown
     *     when the user starts scrolling past the original element.
     *     If not provided, it will use the result of `element.clone()`.
     */
    function MdSticky( $document, $mdConstant, $compile, $$rAF, $mdUtil ) {
        var browserStickySupport = checkStickySupport();
        /**
         * Registers an element as sticky, used internally by directives to register themselves
         */
        return function registerStickyElement( scope, element, stickyClone ) {
            var contentCtrl = element.controller( 'mdContent' );
            if ( !contentCtrl ) return;
            if ( browserStickySupport ) {
                element.css( {
                    position: browserStickySupport,
                    top: 0,
                    'z-index': 2
                } );
            } else {
                var $$sticky = contentCtrl.$element.data( '$$sticky' );
                if ( !$$sticky ) {
                    $$sticky = setupSticky( contentCtrl );
                    contentCtrl.$element.data( '$$sticky', $$sticky );
                }
                var deregister = $$sticky.add( element, stickyClone || element.clone() );
                scope.$on( '$destroy', deregister );
            }
        };

        function setupSticky( contentCtrl ) {
                var contentEl = contentCtrl.$element;
                // Refresh elements is very expensive, so we use the debounced
                // version when possible.
                var debouncedRefreshElements = $$rAF.debounce( refreshElements );
                // setupAugmentedScrollEvents gives us `$scrollstart` and `$scroll`,
                // more reliable than `scroll` on android.
                setupAugmentedScrollEvents( contentEl );
                contentEl.on( '$scrollstart', debouncedRefreshElements );
                contentEl.on( '$scroll', onScroll );
                var self;
                return self = {
                    prev: null,
                    current: null, //the currently stickied item
                    next: null,
                    items: [],
                    add: add,
                    refreshElements: refreshElements
                };
                /***************
                 * Public
                 ***************/
                // Add an element and its sticky clone to this content's sticky collection
                function add( element, stickyClone ) {
                    stickyClone.addClass( 'md-sticky-clone' );
                    var item = {
                        element: element,
                        clone: stickyClone
                    };
                    self.items.push( item );
                    contentEl.parent().prepend( item.clone );
                    debouncedRefreshElements();
                    return function remove() {
                        self.items.forEach( function( item, index ) {
                            if ( item.element[ 0 ] === element[ 0 ] ) {
                                self.items.splice( index, 1 );
                                item.clone.remove();
                            }
                        } );
                        debouncedRefreshElements();
                    };
                }

                function refreshElements() {
                        // Sort our collection of elements by their current position in the DOM.
                        // We need to do this because our elements' order of being added may not
                        // be the same as their order of display.
                        self.items.forEach( refreshPosition );
                        self.items = self.items.sort( function( a, b ) {
                            return a.top < b.top ? -1 : 1;
                        } );
                        // Find which item in the list should be active, 
                        // based upon the content's current scroll position
                        var item;
                        var currentScrollTop = contentEl.prop( 'scrollTop' );
                        for ( var i = self.items.length - 1; i >= 0; i-- ) {
                            if ( currentScrollTop > self.items[ i ].top ) {
                                item = self.items[ i ];
                                break;
                            }
                        }
                        setCurrentItem( item );
                    }
                    /***************
                     * Private
                     ***************/
                    // Find the `top` of an item relative to the content element,
                    // and also the height.
                function refreshPosition( item ) {
                        // Find the top of an item by adding to the offsetHeight until we reach the 
                        // content element.
                        var current = item.element[ 0 ];
                        item.top = 0;
                        item.left = 0;
                        while ( current && current !== contentEl[ 0 ] ) {
                            item.top += current.offsetTop;
                            item.left += current.offsetLeft;
                            current = current.offsetParent;
                        }
                        item.height = item.element.prop( 'offsetHeight' );
                        item.clone.css( 'margin-left', item.left + 'px' );
                    }
                    // As we scroll, push in and select the correct sticky element.
                function onScroll() {
                    var scrollTop = contentEl.prop( 'scrollTop' );
                    var isScrollingDown = scrollTop > ( onScroll.prevScrollTop || 0 );
                    onScroll.prevScrollTop = scrollTop;
                    // At the top?
                    if ( scrollTop === 0 ) {
                        setCurrentItem( null );
                        // Going to next item?
                    } else if ( isScrollingDown && self.next ) {
                        if ( self.next.top - scrollTop <= 0 ) {
                            // Sticky the next item if we've scrolled past its position.
                            setCurrentItem( self.next );
                        } else if ( self.current ) {
                            // Push the current item up when we're almost at the next item.
                            if ( self.next.top - scrollTop <= self.next.height ) {
                                translate( self.current, self.next.top - self.next.height - scrollTop );
                            } else {
                                translate( self.current, null );
                            }
                        }
                        // Scrolling up with a current sticky item?
                    } else if ( !isScrollingDown && self.current ) {
                        if ( scrollTop < self.current.top ) {
                            // Sticky the previous item if we've scrolled up past
                            // the original position of the currently stickied item.
                            setCurrentItem( self.prev );
                        }
                        // Scrolling up, and just bumping into the item above (just set to current)?
                        // If we have a next item bumping into the current item, translate
                        // the current item up from the top as it scrolls into view.
                        if ( self.current && self.next ) {
                            if ( scrollTop >= self.next.top - self.current.height ) {
                                translate( self.current, self.next.top - scrollTop - self.current.height );
                            } else {
                                translate( self.current, null );
                            }
                        }
                    }
                }

                function setCurrentItem( item ) {
                    if ( self.current === item ) return;
                    // Deactivate currently active item
                    if ( self.current ) {
                        translate( self.current, null );
                        setStickyState( self.current, null );
                    }
                    // Activate new item if given
                    if ( item ) {
                        setStickyState( item, 'active' );
                    }
                    self.current = item;
                    var index = self.items.indexOf( item );
                    // If index === -1, index + 1 = 0. It works out.
                    self.next = self.items[ index + 1 ];
                    self.prev = self.items[ index - 1 ];
                    setStickyState( self.next, 'next' );
                    setStickyState( self.prev, 'prev' );
                }

                function setStickyState( item, state ) {
                    if ( !item || item.state === state ) return;
                    if ( item.state ) {
                        item.clone.attr( 'sticky-prev-state', item.state );
                        item.element.attr( 'sticky-prev-state', item.state );
                    }
                    item.clone.attr( 'sticky-state', state );
                    item.element.attr( 'sticky-state', state );
                    item.state = state;
                }

                function translate( item, amount ) {
                    if ( !item ) return;
                    if ( amount === null || amount === undefined ) {
                        if ( item.translateY ) {
                            item.translateY = null;
                            item.clone.css( $mdConstant.CSS.TRANSFORM, '' );
                        }
                    } else {
                        item.translateY = amount;
                        item.clone.css( $mdConstant.CSS.TRANSFORM, 'translate3d(' + item.left + 'px,' + amount + 'px,0)' );
                    }
                }
            }
            // Function to check for browser sticky support
        function checkStickySupport( $el ) {
                var stickyProp;
                var testEl = angular.element( '<div>' );
                $document[ 0 ].body.appendChild( testEl[ 0 ] );
                var stickyProps = [ 'sticky', '-webkit-sticky' ];
                for ( var i = 0; i < stickyProps.length; ++i ) {
                    testEl.css( {
                        position: stickyProps[ i ],
                        top: 0,
                        'z-index': 2
                    } );
                    if ( testEl.css( 'position' ) == stickyProps[ i ] ) {
                        stickyProp = stickyProps[ i ];
                        break;
                    }
                }
                testEl.remove();
                return stickyProp;
            }
            // Android 4.4 don't accurately give scroll events.
            // To fix this problem, we setup a fake scroll event. We say:
            // > If a scroll or touchmove event has happened in the last DELAY milliseconds, 
            //   then send a `$scroll` event every animationFrame.
            // Additionally, we add $scrollstart and $scrollend events.
        function setupAugmentedScrollEvents( element ) {
            var SCROLL_END_DELAY = 200;
            var isScrolling;
            var lastScrollTime;
            element.on( 'scroll touchmove', function() {
                if ( !isScrolling ) {
                    isScrolling = true;
                    $$rAF( loopScrollEvent );
                    element.triggerHandler( '$scrollstart' );
                }
                element.triggerHandler( '$scroll' );
                lastScrollTime = +$mdUtil.now();
            } );

            function loopScrollEvent() {
                if ( +$mdUtil.now() - lastScrollTime > SCROLL_END_DELAY ) {
                    isScrolling = false;
                    element.triggerHandler( '$scrollend' );
                } else {
                    element.triggerHandler( '$scroll' );
                    $$rAF( loopScrollEvent );
                }
            }
        }
    }
    MdSticky.$inject = [ "$document", "$mdConstant", "$compile", "$$rAF", "$mdUtil" ];
} )();
( function() {
    'use strict';
    /**
     * @ngdoc module
     * @name material.components.subheader
     * @description
     * SubHeader module
     *
     *  Subheaders are special list tiles that delineate distinct sections of a
     *  list or grid list and are typically related to the current filtering or
     *  sorting criteria. Subheader tiles are either displayed inline with tiles or
     *  can be associated with content, for example, in an adjacent column.
     *
     *  Upon scrolling, subheaders remain pinned to the top of the screen and remain
     *  pinned until pushed on or off screen by the next subheader. @see [Material
     *  Design Specifications](https://www.google.com/design/spec/components/subheaders.html)
     *
     *  > To improve the visual grouping of content, use the system color for your subheaders.
     *
     */
    angular.module( 'material.components.subheader', [
  'material.core',
  'material.components.sticky'
] ).directive( 'mdSubheader', MdSubheaderDirective );
    /**
     * @ngdoc directive
     * @name mdSubheader
     * @module material.components.subheader
     *
     * @restrict E
     *
     * @description
     * The `<md-subheader>` directive is a subheader for a section
     *
     * @usage
     * <hljs lang="html">
     * <md-subheader>Online Friends</md-subheader>
     * </hljs>
     */
    function MdSubheaderDirective( $mdSticky, $compile, $mdTheming ) {
        return {
            restrict: 'E',
            replace: true,
            transclude: true,
            template: '<h2 class="md-subheader">' + '<span class="md-subheader-content"></span>' + '</h2>',
            compile: function( element, attr, transclude ) {
                var outerHTML = element[ 0 ].outerHTML;
                return function postLink( scope, element, attr ) {
                    $mdTheming( element );

                    function getContent( el ) {
                            return angular.element( el[ 0 ].querySelector( '.md-subheader-content' ) );
                        }
                        // Transclude the user-given contents of the subheader
                        // the conventional way.
                    transclude( scope, function( clone ) {
                        getContent( element ).append( clone );
                    } );
                    // Create another clone, that uses the outer and inner contents
                    // of the element, that will be 'stickied' as the user scrolls.
                    transclude( scope, function( clone ) {
                        var stickyClone = $compile( angular.element( outerHTML ) )( scope );
                        $mdTheming( stickyClone );
                        getContent( stickyClone ).append( clone );
                        $mdSticky( scope, element, stickyClone );
                    } );
                };
            }
        };
    }
    MdSubheaderDirective.$inject = [ "$mdSticky", "$compile", "$mdTheming" ];
} )();
( function() {
    'use strict';
    /**
     * @ngdoc module
     * @name material.components.swipe
     * @description Swipe module!
     */
    angular.module( 'material.components.swipe', [] ).factory( '$mdSwipe', MdSwipeFactory ).directive( 'mdSwipeLeft', MdSwipeLeftDirective ).directive( 'mdSwipeRight', MdSwipeRightDirective );
    /*
     * @ngdoc service
     * @module material.components.swipe
     * @name $mdSwipe
     * @description
     * This service allows directives to easily attach swipe and pan listeners to
     * the specified element.
     */
    function MdSwipeFactory() {
            // match expected API functionality
            var attachNoop = function() {
                return angular.noop;
            };
            /**
             * SwipeService constructor pre-captures scope and customized event types
             *
             * @param scope
             * @param eventTypes
             * @returns {*}
             * @constructor
             */
            return function SwipeService( scope, eventTypes ) {
                if ( !eventTypes ) eventTypes = "swipeleft swiperight";
                // publish configureFor() method for specific element instance
                return function configureFor( element, onSwipeCallback, attachLater ) {
                    var hammertime = new Hammer( element[ 0 ], {
                        recognizers: addRecognizers( [], eventTypes )
                    } );
                    // Attach swipe listeners now
                    if ( !attachLater ) attachSwipe();
                    // auto-disconnect during destroy
                    scope.$on( '$destroy', function() {
                        hammertime.destroy();
                    } );
                    return attachSwipe;
                    // **********************
                    // Internal methods
                    // **********************
                    /**
                     * Delegate swipe event to callback function
                     * and ensure $digest is triggered.
                     *
                     * @param ev HammerEvent
                     */
                    function swipeHandler( ev ) {
                            // Prevent triggering parent hammer listeners
                            ev.srcEvent.stopPropagation();
                            if ( angular.isFunction( onSwipeCallback ) ) {
                                scope.$apply( function() {
                                    onSwipeCallback( ev );
                                } );
                            }
                        }
                        /**
                         * Enable listeners and return detach() fn
                         */
                    function attachSwipe() {
                            hammertime.on( eventTypes, swipeHandler );
                            return function detachSwipe() {
                                hammertime.off( eventTypes );
                            };
                        }
                        /**
                         * Add optional recognizers such as panleft, panright
                         */
                    function addRecognizers( list, events ) {
                        var hasPanning = ( events.indexOf( "pan" ) > -1 );
                        var hasSwipe = ( events.indexOf( "swipe" ) > -1 );
                        if ( hasPanning ) {
                            list.push( [ Hammer.Pan, {
                                direction: Hammer.DIRECTION_HORIZONTAL
                            } ] );
                        }
                        if ( hasSwipe ) {
                            list.push( [ Hammer.Swipe, {
                                direction: Hammer.DIRECTION_HORIZONTAL
                            } ] );
                        }
                        return list;
                    }
                };
            };
        }
        /**
         * @ngdoc directive
         * @module material.components.swipe
         * @name mdSwipeLeft
         *
         * @restrict A
         *
         * @description
         * The `<div  md-swipe-left="expression">` directive identifies an element on which
         * HammerJS horizontal swipe left and pan left support will be active. The swipe/pan action
         * can result in custom activity trigger by evaluating `expression`.
         *
         * @param {boolean=} mdNoPan Use of attribute indicates flag to disable detection of `panleft` activity
         *
         * @usage
         * <hljs lang="html">
         *
         * <div class="animate-switch-container"
         *      ng-switch on="data.selectedIndex"
         *      md-swipe-left="data.selectedIndex+=1;"
         *      md-swipe-right="data.selectedIndex-=1;" >
         *
         * </div>
         * </hljs>
         *
         */
    function MdSwipeLeftDirective( $parse, $mdSwipe ) {
        return {
            restrict: 'A',
            link: swipePostLink( $parse, $mdSwipe, "SwipeLeft" )
        };
    }
    MdSwipeLeftDirective.$inject = [ "$parse", "$mdSwipe" ];
    /**
     * @ngdoc directive
     * @module material.components.swipe
     * @name mdSwipeRight
     *
     * @restrict A
     *
     * @description
     * The `<div  md-swipe-right="expression">` directive identifies functionality
     * that attaches HammerJS horizontal swipe right and pan right support to an element. The swipe/pan action
     * can result in activity trigger by evaluating `expression`
     *
     * @param {boolean=} mdNoPan Use of attribute indicates flag to disable detection of `panright` activity
     *
     * @usage
     * <hljs lang="html">
     *
     * <div class="animate-switch-container"
     *      ng-switch on="data.selectedIndex"
     *      md-swipe-left="data.selectedIndex+=1;"
     *      md-swipe-right="data.selectedIndex-=1;" >
     *
     * </div>
     * </hljs>
     *
     */
    function MdSwipeRightDirective( $parse, $mdSwipe ) {
        return {
            restrict: 'A',
            link: swipePostLink( $parse, $mdSwipe, "SwipeRight" )
        };
    }
    MdSwipeRightDirective.$inject = [ "$parse", "$mdSwipe" ];
    /**
     * Factory to build PostLink function specific to Swipe or Pan direction
     *
     * @param $parse
     * @param $mdSwipe
     * @param name
     * @returns {Function}
     */
    function swipePostLink( $parse, $mdSwipe, name ) {
        return function( scope, element, attrs ) {
            var direction = name.toLowerCase();
            var directiveName = "md" + name;
            var parentGetter = $parse( attrs[ directiveName ] ) || angular.noop;
            var configureSwipe = $mdSwipe( scope, direction );
            var requestSwipe = function( locals ) {
                // build function to request scope-specific swipe response
                parentGetter( scope, locals );
            };
            configureSwipe( element, function onHandleSwipe( ev ) {
                if ( ev.type == direction ) {
                    requestSwipe();
                }
            } );
        };
    }
} )();
( function() {
    'use strict';
    /**
     * @private
     * @ngdoc module
     * @name material.components.switch
     */
    angular.module( 'material.components.switch', [
  'material.core',
  'material.components.checkbox',
  'material.components.radioButton'
] ).directive( 'mdSwitch', MdSwitch );
    /**
     * @private
     * @ngdoc directive
     * @module material.components.switch
     * @name mdSwitch
     * @restrict E
     *
     * The switch directive is used very much like the normal [angular checkbox](https://docs.angularjs.org/api/ng/input/input%5Bcheckbox%5D).
     *
     * @param {string} ng-model Assignable angular expression to data-bind to.
     * @param {string=} name Property name of the form under which the control is published.
     * @param {expression=} ng-true-value The value to which the expression should be set when selected.
     * @param {expression=} ng-false-value The value to which the expression should be set when not selected.
     * @param {string=} ng-change Angular expression to be executed when input changes due to user interaction with the input element.
     * @param {boolean=} md-no-ink Use of attribute indicates use of ripple ink effects.
     * @param {string=} aria-label Publish the button label used by screen-readers for accessibility. Defaults to the switch's text.
     *
     * @usage
     * <hljs lang="html">
     * <md-switch ng-model="isActive" aria-label="Finished?">
     *   Finished ?
     * </md-switch>
     *
     * <md-switch md-no-ink ng-model="hasInk" aria-label="No Ink Effects">
     *   No Ink Effects
     * </md-switch>
     *
     * <md-switch ng-disabled="true" ng-model="isDisabled" aria-label="Disabled">
     *   Disabled
     * </md-switch>
     *
     * </hljs>
     */
    function MdSwitch( mdCheckboxDirective, mdRadioButtonDirective, $mdTheming ) {
        var checkboxDirective = mdCheckboxDirective[ 0 ];
        var radioButtonDirective = mdRadioButtonDirective[ 0 ];
        return {
            restrict: 'E',
            transclude: true,
            template: '<div class="md-switch-bar"></div>' + '<div class="md-switch-thumb">' + radioButtonDirective.template + '</div>',
            require: '?ngModel',
            compile: compile
        };

        function compile( element, attr ) {
            var thumb = angular.element( element[ 0 ].querySelector( '.md-switch-thumb' ) );
            var checkboxLink = checkboxDirective.compile( thumb, attr );
            return function( scope, element, attr, ngModelCtrl ) {
                $mdTheming( element );
                return checkboxLink( scope, thumb, attr, ngModelCtrl );
            };
        }
    }
    MdSwitch.$inject = [ "mdCheckboxDirective", "mdRadioButtonDirective", "$mdTheming" ];
} )();
( function() {
    'use strict';
    /**
     * @ngdoc module
     * @name material.components.tabs
     * @description
     *
     *  Tabs, created with the `<md-tabs>` directive provide *tabbed* navigation with different styles.
     *  The Tabs component consists of clickable tabs that are aligned horizontally side-by-side.
     *
     *  Features include support for:
     *
     *  - static or dynamic tabs,
     *  - responsive designs,
     *  - accessibility support (ARIA),
     *  - tab pagination,
     *  - external or internal tab content,
     *  - focus indicators and arrow-key navigations,
     *  - programmatic lookup and access to tab controllers, and
     *  - dynamic transitions through different tab contents.
     *
     */
    /*
     * @see js folder for tabs implementation
     */
    angular.module( 'material.components.tabs', [
  'material.core'
] );
} )();
( function() {
    'use strict';
    /**
     * @ngdoc module
     * @name material.components.textField
     * @description
     * Form
     */
    angular.module( 'material.components.textField', [
  'material.core'
] ).directive( 'mdInputGroup', mdInputGroupDirective ).directive( 'mdInput', mdInputDirective ).directive( 'mdTextFloat', mdTextFloatDirective );
    /**
     * @ngdoc directive
     * @name mdTextFloat
     * @module material.components.textField
     *
     * @restrict E
     *
     * @description
     * Use the `<md-text-float>` directive to quickly construct `Floating Label` text fields
     *
     * @param {string} ng-model Model expression used for two-way data binding with the input value.
     * @param {string} label String value or expression that specifies the input text field label/hint.
     * @param {string=} type Optional value to define the type of input field. Defaults to string.
     * @param {string=} md-fid Optional attribute used for accessibility link pairing between the Label and Input elements
     *
     * @usage
     * <hljs lang="html">
     * <md-text-float label="LastName" ng-model="user.lastName" > </md-text-float>
     *
     * <!-- Specify a read-only input field by using the `disabled` attribute -->
     * <md-text-float label="Company"  ng-model="user.company" ng-disabled="true" > </md-text-float>
     *
     * <!-- Specify an input type if desired. -->
     * <md-text-float label="eMail"    ng-model="user.email" type="email" ></md-text-float>
     * </hljs>
     */
    function mdTextFloatDirective( $mdTheming, $mdUtil, $parse ) {
        return {
            restrict: 'E',
            replace: true,
            scope: {
                fid: '@?mdFid',
                label: '@?',
                value: '=ngModel'
            },
            compile: function( element, attr ) {
                if ( angular.isUndefined( attr.mdFid ) ) {
                    attr.mdFid = $mdUtil.nextUid();
                }
                return {
                    pre: function( scope, element, attrs ) {
                        var disabledParsed = $parse( attrs.ngDisabled );
                        scope.isDisabled = function() {
                            return disabledParsed( scope.$parent );
                        };
                        scope.inputType = attrs.type || "text";
                    },
                    post: $mdTheming
                };
            },
            template: '<md-input-group tabindex="-1">' + ' <label for="{{fid}}" >{{label}}</label>' + ' <md-input id="{{fid}}" ng-disabled="isDisabled()" ng-model="value" type="{{inputType}}"></md-input>' + '</md-input-group>'
        };
    }
    mdTextFloatDirective.$inject = [ "$mdTheming", "$mdUtil", "$parse" ];
    /*
     * @private
     *
     * @ngdoc directive
     * @name mdInputGroup
     * @module material.components.textField
     * @restrict E
     * @description
     * Use the `<md-input-group>` directive as the grouping parent of a `<md-input>` element.
     *
     * @usage
     * <hljs lang="html">
     * <md-input-group ng-disabled="isDisabled">
     *   <label for="{{fid}}">{{someLabel}}</label>
     *   <md-input id="{{fid}}" type="text" ng-model="someText"></md-input>
     * </md-input-group>
     * </hljs>
     */
    function mdInputGroupDirective() {
            return {
                restrict: 'CE',
                controller: [ '$element', function( $element ) {
                    this.setFocused = function( isFocused ) {
                        $element.toggleClass( 'md-input-focused', !!isFocused );
                    };
                    this.setHasValue = function( hasValue ) {
                        $element.toggleClass( 'md-input-has-value', hasValue );
                    };
    } ]
            };
        }
        /*
         * @private
         *
         * @ngdoc directive
         * @name mdInput
         * @module material.components.textField
         *
         * @restrict E
         *
         * @description
         * Use the `<md-input>` directive as elements within a `<md-input-group>` container
         *
         * @usage
         * <hljs lang="html">
         * <md-input-group ng-disabled="user.isLocked">
         *   <label for="i1">FirstName</label>
         *   <md-input id="i1" ng-model="user.firstName"></md-input>
         * </md-input-group>
         * </hljs>
         */
    function mdInputDirective( $mdUtil ) {
        return {
            restrict: 'E',
            replace: true,
            template: '<input >',
            require: [ '^?mdInputGroup', '?ngModel' ],
            link: function( scope, element, attr, ctrls ) {
                if ( !ctrls[ 0 ] ) return;
                var inputGroupCtrl = ctrls[ 0 ];
                var ngModelCtrl = ctrls[ 1 ];
                scope.$watch( scope.isDisabled, function( isDisabled ) {
                    element.attr( 'aria-disabled', !!isDisabled );
                    element.attr( 'tabindex', !!isDisabled );
                } );
                element.attr( 'type', attr.type || element.parent().attr( 'type' ) || "text" );
                // When the input value changes, check if it "has" a value, and
                // set the appropriate class on the input group
                if ( ngModelCtrl ) {
                    //Add a $formatter so we don't use up the render function
                    ngModelCtrl.$formatters.push( function( value ) {
                        inputGroupCtrl.setHasValue( isNotEmpty( value ) );
                        return value;
                    } );
                }
                element.on( 'input', function() {
                    inputGroupCtrl.setHasValue( isNotEmpty() );
                } ).on( 'focus', function( e ) {
                    // When the input focuses, add the focused class to the group
                    inputGroupCtrl.setFocused( true );
                } ).on( 'blur', function( e ) {
                    // When the input blurs, remove the focused class from the group
                    inputGroupCtrl.setFocused( false );
                    inputGroupCtrl.setHasValue( isNotEmpty() );
                } );
                scope.$on( '$destroy', function() {
                    inputGroupCtrl.setFocused( false );
                    inputGroupCtrl.setHasValue( false );
                } );

                function isNotEmpty( value ) {
                    value = angular.isUndefined( value ) ? element.val() : value;
                    return ( angular.isDefined( value ) && ( value !== null ) && ( value.toString().trim() !== "" ) );
                }
            }
        };
    }
    mdInputDirective.$inject = [ "$mdUtil" ];
} )();
( function() {
    'use strict';
    /**
     * @ngdoc module
     * @name material.components.toolbar
     */
    angular.module( 'material.components.toolbar', [
  'material.core',
  'material.components.content'
] ).directive( 'mdToolbar', mdToolbarDirective );
    /**
     * @ngdoc directive
     * @name mdToolbar
     * @module material.components.toolbar
     * @restrict E
     * @description
     * `md-toolbar` is used to place a toolbar in your app.
     *
     * Toolbars are usually used above a content area to display the title of the
     * current page, and show relevant action buttons for that page.
     *
     * You can change the height of the toolbar by adding either the
     * `md-medium-tall` or `md-tall` class to the toolbar.
     *
     * @usage
     * <hljs lang="html">
     * <div layout="column" layout-fill>
     *   <md-toolbar>
     *
     *     <div class="md-toolbar-tools">
     *       <span>My App's Title</span>
     *
     *       <!-- fill up the space between left and right area -->
     *       <span flex></span>
     *
     *       <md-button>
     *         Right Bar Button
     *       </md-button>
     *     </div>
     *
     *   </md-toolbar>
     *   <md-content>
     *     Hello!
     *   </md-content>
     * </div>
     * </hljs>
     *
     * @param {boolean=} md-scroll-shrink Whether the header should shrink away as
     * the user scrolls down, and reveal itself as the user scrolls up.
     * Note: for scrollShrink to work, the toolbar must be a sibling of a
     * `md-content` element, placed before it. See the scroll shrink demo.
     *
     *
     * @param {number=} md-shrink-speed-factor How much to change the speed of the toolbar's
     * shrinking by. For example, if 0.25 is given then the toolbar will shrink
     * at one fourth the rate at which the user scrolls down. Default 0.5.
     */
    function mdToolbarDirective( $$rAF, $mdConstant, $mdUtil, $mdTheming ) {
        return {
            restrict: 'E',
            controller: angular.noop,
            link: function( scope, element, attr ) {
                $mdTheming( element );
                if ( angular.isDefined( attr.mdScrollShrink ) ) {
                    setupScrollShrink();
                }

                function setupScrollShrink() {
                    // Current "y" position of scroll
                    var y = 0;
                    // Store the last scroll top position
                    var prevScrollTop = 0;
                    var shrinkSpeedFactor = attr.mdShrinkSpeedFactor || 0.5;
                    var toolbarHeight;
                    var contentElement;
                    var debouncedContentScroll = $$rAF.debounce( onContentScroll );
                    var debouncedUpdateHeight = $mdUtil.debounce( updateToolbarHeight, 5 * 1000 );
                    // Wait for $mdContentLoaded event from mdContent directive.
                    // If the mdContent element is a sibling of our toolbar, hook it up
                    // to scroll events.
                    scope.$on( '$mdContentLoaded', onMdContentLoad );

                    function onMdContentLoad( $event, newContentEl ) {
                        // Toolbar and content must be siblings
                        if ( element.parent()[ 0 ] === newContentEl.parent()[ 0 ] ) {
                            // unhook old content event listener if exists
                            if ( contentElement ) {
                                contentElement.off( 'scroll', debouncedContentScroll );
                            }
                            newContentEl.on( 'scroll', debouncedContentScroll );
                            newContentEl.attr( 'scroll-shrink', 'true' );
                            contentElement = newContentEl;
                            $$rAF( updateToolbarHeight );
                        }
                    }

                    function updateToolbarHeight() {
                        toolbarHeight = element.prop( 'offsetHeight' );
                        // Add a negative margin-top the size of the toolbar to the content el.
                        // The content will start transformed down the toolbarHeight amount,
                        // so everything looks normal.
                        //
                        // As the user scrolls down, the content will be transformed up slowly
                        // to put the content underneath where the toolbar was.
                        contentElement.css( 'margin-top', ( -toolbarHeight * shrinkSpeedFactor ) + 'px' );
                        onContentScroll();
                    }

                    function onContentScroll( e ) {
                        var scrollTop = e ? e.target.scrollTop : prevScrollTop;
                        debouncedUpdateHeight();
                        y = Math.min( toolbarHeight / shrinkSpeedFactor, Math.max( 0, y + scrollTop - prevScrollTop ) );
                        element.css( $mdConstant.CSS.TRANSFORM, 'translate3d(0,' + ( -y * shrinkSpeedFactor ) + 'px,0)' );
                        contentElement.css( $mdConstant.CSS.TRANSFORM, 'translate3d(0,' + ( ( toolbarHeight - y ) * shrinkSpeedFactor ) + 'px,0)' );
                        prevScrollTop = scrollTop;
                    }
                }
            }
        };
    }
    mdToolbarDirective.$inject = [ "$$rAF", "$mdConstant", "$mdUtil", "$mdTheming" ];
} )();
( function() {
    'use strict';
    /**
     * @ngdoc module
     * @name material.components.toast
     * @description
     * Toast
     */
    angular.module( 'material.components.toast', [
  'material.core',
  'material.components.swipe',
  'material.components.button'
] ).directive( 'mdToast', MdToastDirective ).provider( '$mdToast', MdToastProvider );

    function MdToastDirective() {
            return {
                restrict: 'E'
            };
        }
        /**
         * @ngdoc service
         * @name $mdToast
         * @module material.components.toast
         *
         * @description
         * `$mdToast` is a service to butild a toast nofication on any position
         * on the screen with an optional duration, and provides a simple promise API.
         *
         *
         * ### Restrictions on custom toasts
         * - The toast's template must have an outer `<md-toast>` element.
         * - For a toast action, use element with class `md-action`.
         * - Add the class `md-capsule` for curved corners.
         *
         * @usage
         * <hljs lang="html">
         * <div ng-controller="MyController">
         *   <md-button ng-click="openToast()">
         *     Open a Toast!
         *   </md-button>
         * </div>
         * </hljs>
         *
         * <hljs lang="js">
         * var app = angular.module('app', ['ngMaterial']);
         * app.controller('MyController', function($scope, $mdToast) {
         *   $scope.openToast = function($event) {
         *     $mdToast.show($mdToast.simple().content('Hello!'));
         *   };
         * });
         * </hljs>
         */
        /**
         * @ngdoc method
         * @name $mdToast#simple
         *
         * @description
         * Builds a preconfigured toast.
         *
         * @returns {obj} a `$mdToastPreset` with the chainable configuration methods:
         *
         * - $mdToastPreset#content(string) - sets toast content to string
         * - $mdToastPreset#action(string) - adds an action button, which resolves the promise returned from `show()` if clicked.
         * - $mdToastPreset#highlightAction(boolean) - sets action button to be highlighted
         * - $mdToastPreset#capsule(boolean) - adds 'md-capsule' class to the toast (curved corners)
         */
        /**
         * @ngdoc method
         * @name $mdToast#build
         *
         * @description
         * Creates a custom `$mdToastPreset` that you can configure.
         *
         * @returns {obj} a `$mdToastPreset` with the chainable configuration methods for shows' options (see below).
         */
        /**
         * @ngdoc method
         * @name $mdToast#show
         *
         * @description Shows the toast.
         *
         * @param {object} optionsOrPreset Either provide an `$mdToastPreset` returned from `simple()`
         * and `build()`, or an options object with the following properties:
         *
         *   - `templateUrl` - `{string=}`: The url of an html template file that will
         *     be used as the content of the toast. Restrictions: the template must
         *     have an outer `md-toast` element.
         *   - `template` - `{string=}`: Same as templateUrl, except this is an actual
         *     template string.
         *   - `hideDelay` - `{number=}`: How many milliseconds the toast should stay
         *     active before automatically closing.  Set to 0 or false to have the toast stay open until
         *     closed manually. Default: 3000.
         *   - `position` - `{string=}`: Where to place the toast. Available: any combination
         *     of 'bottom', 'left', 'top', 'right', 'fit'. Default: 'bottom left'.
         *   - `controller` - `{string=}`: The controller to associate with this toast.
         *     The controller will be injected the local `$hideToast`, which is a function
         *     used to hide the toast.
         *   - `locals` - `{string=}`: An object containing key/value pairs. The keys will
         *     be used as names of values to inject into the controller. For example,
         *     `locals: {three: 3}` would inject `three` into the controller with the value
         *     of 3.
         *   - `resolve` - `{object=}`: Similar to locals, except it takes promises as values
         *     and the toast will not open until the promises resolve.
         *   - `controllerAs` - `{string=}`: An alias to assign the controller to on the scope.
         *
         * @returns {promise} A promise that can be resolved with `$mdToast.hide()` or
         * rejected with `$mdToast.cancel()`.
         */
        /**
         * @ngdoc method
         * @name $mdToast#hide
         *
         * @description
         * Hide an existing toast and resolve the promise returned from `$mdToast.show()`.
         *
         * @param {*=} response An argument for the resolved promise.
         *
         */
        /**
         * @ngdoc method
         * @name $mdToast#cancel
         *
         * @description
         * Hide the existing toast and reject the promise returned from
         * `$mdToast.show()`.
         *
         * @param {*=} response An argument for the rejected promise.
         *
         */
    function MdToastProvider( $$interimElementProvider ) {
        toastDefaultOptions.$inject = [ "$timeout", "$animate", "$mdSwipe", "$mdTheming", "$mdToast" ];
        return $$interimElementProvider( '$mdToast' ).setDefaults( {
            methods: [ 'position', 'hideDelay', 'capsule' ],
            options: toastDefaultOptions
        } ).addPreset( 'simple', {
            argOption: 'content',
            methods: [ 'content', 'action', 'highlightAction' ],
            options: /* @ngInject */ [ "$mdToast", function( $mdToast ) {
                return {
                    template: [
            '<md-toast ng-class="{\'md-capsule\': toast.capsule}">',
              '<span flex>{{ toast.content }}</span>',
              '<md-button ng-if="toast.action" ng-click="toast.resolve()" ng-class="{\'md-action\': toast.highlightAction}">',
                '{{toast.action}}',
              '</md-button>',
            '</md-toast>'
          ].join( '' ),
                    controller: function mdToastCtrl() {
                        this.resolve = function() {
                            $mdToast.hide();
                        };
                    },
                    controllerAs: 'toast',
                    bindToController: true
                };
      } ]
        } );
        /* @ngInject */
        function toastDefaultOptions( $timeout, $animate, $mdSwipe, $mdTheming, $mdToast ) {
            return {
                onShow: onShow,
                onRemove: onRemove,
                position: 'bottom left',
                themable: true,
                hideDelay: 3000
            };

            function onShow( scope, element, options ) {
                // 'top left' -> 'md-top md-left'
                element.addClass( options.position.split( ' ' ).map( function( pos ) {
                    return 'md-' + pos;
                } ).join( ' ' ) );
                options.parent.addClass( toastOpenClass( options.position ) );
                var configureSwipe = $mdSwipe( scope, 'swipeleft swiperight' );
                options.detachSwipe = configureSwipe( element, function( ev ) {
                    //Add swipeleft/swiperight class to element so it can animate correctly
                    element.addClass( 'md-' + ev.type );
                    $timeout( $mdToast.cancel );
                } );
                return $animate.enter( element, options.parent );
            }

            function onRemove( scope, element, options ) {
                options.detachSwipe();
                options.parent.removeClass( toastOpenClass( options.position ) );
                return $animate.leave( element );
            }

            function toastOpenClass( position ) {
                return 'md-toast-open-' + ( position.indexOf( 'top' ) > -1 ? 'top' : 'bottom' );
            }
        }
    }
    MdToastProvider.$inject = [ "$$interimElementProvider" ];
} )();
( function() {
    'use strict';
    /**
     * @ngdoc module
     * @name material.components.tooltip
     */
    angular.module( 'material.components.tooltip', [
  'material.core'
] ).directive( 'mdTooltip', MdTooltipDirective );
    /**
     * @ngdoc directive
     * @name mdTooltip
     * @module material.components.tooltip
     * @description
     * Tooltips are used to describe elements that are interactive and primarily graphical (not textual).
     *
     * Place a `<md-tooltip>` as a child of the element it describes.
     *
     * A tooltip will activate when the user focuses, hovers over, or touches the parent.
     *
     * @usage
     * <hljs lang="html">
     * <md-icon icon="/img/icons/ic_play_arrow_24px.svg">
     *   <md-tooltip>
     *     Play Music
     *   </md-tooltip>
     * </md-icon>
     * </hljs>
     *
     * @param {expression=} md-visible Boolean bound to whether the tooltip is
     * currently visible.
     */
    function MdTooltipDirective( $timeout, $window, $$rAF, $document, $mdUtil, $mdTheming ) {
        var TOOLTIP_SHOW_DELAY = 400;
        var TOOLTIP_WINDOW_EDGE_SPACE = 8;
        // We have to append tooltips to the body, because we use
        // getBoundingClientRect() to find where to append the tooltip.
        var tooltipParent = angular.element( document.body );
        return {
            restrict: 'E',
            transclude: true,
            require: '^?mdContent',
            template: '<div class="md-background"></div>' + '<div class="md-content" ng-transclude></div>',
            scope: {
                visible: '=?mdVisible'
            },
            link: postLink
        };

        function postLink( scope, element, attr, contentCtrl ) {
            $mdTheming( element );
            var parent = element.parent();
            // We will re-attach tooltip when visible
            element.detach();
            element.attr( 'role', 'tooltip' );
            element.attr( 'id', attr.id || ( 'tooltip_' + $mdUtil.nextUid() ) );
            parent.on( 'focus mouseenter touchstart', function() {
                setVisible( true );
            } );
            parent.on( 'blur mouseleave touchend touchcancel', function() {
                // Don't hide the tooltip if the parent is still focused.
                if ( $document.activeElement === parent[ 0 ] ) return;
                setVisible( false );
            } );
            scope.$watch( 'visible', function( isVisible ) {
                if ( isVisible ) showTooltip();
                else hideTooltip();
            } );
            var debouncedOnResize = $$rAF.debounce( function windowResize() {
                // Reposition on resize
                if ( scope.visible ) positionTooltip();
            } );
            angular.element( $window ).on( 'resize', debouncedOnResize );
            // Be sure to completely cleanup the element on destroy
            scope.$on( '$destroy', function() {
                scope.visible = false;
                element.remove();
                angular.element( $window ).off( 'resize', debouncedOnResize );
            } );
            // *******
            // Methods
            // *******
            // If setting visible to true, debounce to TOOLTIP_SHOW_DELAY ms
            // If setting visible to false and no timeout is active, instantly hide the tooltip.
            function setVisible( value ) {
                setVisible.value = !!value;
                if ( !setVisible.queued ) {
                    if ( value ) {
                        setVisible.queued = true;
                        $timeout( function() {
                            scope.visible = setVisible.value;
                            setVisible.queued = false;
                        }, TOOLTIP_SHOW_DELAY );
                    } else {
                        $timeout( function() {
                            scope.visible = false;
                        } );
                    }
                }
            }

            function showTooltip() {
                // Insert the element before positioning it, so we can get position
                // (tooltip is hidden by default)
                element.removeClass( 'md-hide' );
                parent.attr( 'aria-describedby', element.attr( 'id' ) );
                tooltipParent.append( element );
                // Wait until the element has been in the dom for two frames before
                // fading it in.
                // Additionally, we position the tooltip twice to avoid positioning bugs
                //positionTooltip();
                $$rAF( function() {
                    $$rAF( function() {
                        positionTooltip();
                        if ( !scope.visible ) return;
                        element.addClass( 'md-show' );
                    } );
                } );
            }

            function hideTooltip() {
                element.removeClass( 'md-show' ).addClass( 'md-hide' );
                parent.removeAttr( 'aria-describedby' );
                $timeout( function() {
                    if ( scope.visible ) return;
                    element.detach();
                }, 200, false );
            }

            function positionTooltip() {
                var tipRect = element[ 0 ].getBoundingClientRect();
                var parentRect = parent[ 0 ].getBoundingClientRect();
                if ( contentCtrl ) {
                    parentRect.top += contentCtrl.$element.prop( 'scrollTop' );
                    parentRect.left += contentCtrl.$element.prop( 'scrollLeft' );
                }
                // Default to bottom position if possible
                var tipDirection = 'bottom';
                var newPosition = {
                    left: parentRect.left + parentRect.width / 2 - tipRect.width / 2,
                    top: parentRect.top + parentRect.height
                };
                // If element bleeds over left/right of the window, place it on the edge of the window.
                newPosition.left = Math.min( newPosition.left, $window.innerWidth - tipRect.width - TOOLTIP_WINDOW_EDGE_SPACE );
                newPosition.left = Math.max( newPosition.left, TOOLTIP_WINDOW_EDGE_SPACE );
                // If element bleeds over the bottom of the window, place it above the parent.
                if ( newPosition.top + tipRect.height > $window.innerHeight ) {
                    newPosition.top = parentRect.top - tipRect.height;
                    tipDirection = 'top';
                }
                element.css( {
                    top: newPosition.top + 'px',
                    left: newPosition.left + 'px'
                } );
                // Tell the CSS the size of this tooltip, as a multiple of 32.
                element.attr( 'width-32', Math.ceil( tipRect.width / 32 ) );
                element.attr( 'md-direction', tipDirection );
            }
        }
    }
    MdTooltipDirective.$inject = [ "$timeout", "$window", "$$rAF", "$document", "$mdUtil", "$mdTheming" ];
} )();
( function() {
    'use strict';
    /**
     * @ngdoc module
     * @name material.components.whiteframe
     */
    angular.module( 'material.components.whiteframe', [] );
} )();
( function() {
    'use strict';
    /**
     * Conditionally configure ink bar animations when the
     * tab selection changes. If `mdNoBar` then do not show the
     * bar nor animate.
     */
    angular.module( 'material.components.tabs' ).directive( 'mdTabsInkBar', MdTabInkDirective );

    function MdTabInkDirective( $mdConstant, $window, $$rAF, $timeout ) {
        return {
            restrict: 'E',
            require: [ '^?mdNoBar', '^mdTabs' ],
            link: postLink
        };

        function postLink( scope, element, attr, ctrls ) {
            var nobar = ctrls[ 0 ],
                tabsCtrl = ctrls[ 1 ],
                timeout;
            if ( nobar ) return;
            tabsCtrl.inkBarElement = element;
            scope.$watch( tabsCtrl.selected, updateBar );
            scope.$on( '$mdTabsChanged', updateBar );

            function updateBar() {
                var selected = tabsCtrl.selected();
                var hideInkBar = !selected || tabsCtrl.count() < 2 || ( scope.pagination || {} ).itemsPerPage === 1;
                element.css( 'display', hideInkBar ? 'none' : 'block' );
                if ( !hideInkBar ) {
                    var count = tabsCtrl.count();
                    var scale = 1 / count;
                    var left = tabsCtrl.indexOf( selected );
                    element.css( $mdConstant.CSS.TRANSFORM, 'scaleX(' + scale + ') ' + 'translate3d(' + left * 100 + '%,0,0)' );
                    element.addClass( 'md-ink-bar-grow' );
                    if ( timeout ) $timeout.cancel( timeout );
                    timeout = $timeout( function() {
                        element.removeClass( 'md-ink-bar-grow' );
                    }, 250, false );
                }
            }
        }
    }
    MdTabInkDirective.$inject = [ "$mdConstant", "$window", "$$rAF", "$timeout" ];
} )();
( function() {
    'use strict';
    angular.module( 'material.components.tabs' ).directive( 'mdTabsPagination', TabPaginationDirective );

    function TabPaginationDirective( $mdConstant, $window, $$rAF, $$q, $timeout ) {
        // TODO allow configuration of TAB_MIN_WIDTH
        // Must match tab min-width rule in _tabs.scss
        var TAB_MIN_WIDTH = 8 * 12;
        // Must match (2 * width of paginators) in scss
        var PAGINATORS_WIDTH = ( 8 * 4 ) * 2;
        return {
            restrict: 'A',
            require: '^mdTabs',
            link: postLink
        };

        function postLink( scope, element, attr, tabsCtrl ) {
            var tabsParent = element.children();
            var state = scope.pagination = {
                page: -1,
                active: false,
                clickNext: function() {
                    userChangePage( +1 );
                },
                clickPrevious: function() {
                    userChangePage( -1 );
                }
            };
            updatePagination();
            var debouncedUpdatePagination = $$rAF.debounce( updatePagination );
            scope.$on( '$mdTabsChanged', debouncedUpdatePagination );
            angular.element( $window ).on( 'resize', debouncedUpdatePagination );
            scope.$on( '$destroy', function() {
                angular.element( $window ).off( 'resize', debouncedUpdatePagination );
            } );
            scope.$watch( tabsCtrl.selected, onSelectedTabChange );
            scope.$watch( function() {
                return tabsCtrl.tabToFocus;
            }, onTabFocus );
            // Make sure we don't focus an element on the next page
            // before it's in view
            function onTabFocus( tab, oldTab ) {
                if ( !tab ) return;
                var pageIndex = getPageForTab( tab );
                if ( !state.active || pageIndex === state.page ) {
                    tab.element.focus();
                } else {
                    // Go to the new page, wait for the page transition to end, then focus.
                    oldTab && oldTab.element.blur();
                    setPage( pageIndex ).then( function() {
                        tab.element.focus();
                    } );
                }
            }

            function onSelectedTabChange( selectedTab ) {
                    if ( !selectedTab ) return;
                    if ( state.active ) {
                        var selectedTabPage = getPageForTab( selectedTab );
                        setPage( selectedTabPage );
                    } else {
                        debouncedUpdatePagination();
                    }
                }
                // Called when page is changed by a user action (click)
            function userChangePage( increment ) {
                var newPage = state.page + increment;
                var newTab;
                if ( !tabsCtrl.selected() || getPageForTab( tabsCtrl.selected() ) !== newPage ) {
                    var startIndex;
                    if ( increment < 0 ) {
                        // If going backward, select the previous available tab, starting from
                        // the first item on the page after newPage.
                        startIndex = ( newPage + 1 ) * state.itemsPerPage;
                        newTab = tabsCtrl.previous( tabsCtrl.itemAt( startIndex ) );
                    } else {
                        // If going forward, select the next available tab, starting with the
                        // last item before newPage.
                        startIndex = ( newPage * state.itemsPerPage ) - 1;
                        newTab = tabsCtrl.next( tabsCtrl.itemAt( startIndex ) );
                    }
                }
                setPage( newPage ).then( function() {
                    newTab && newTab.element.focus();
                } );
                newTab && tabsCtrl.select( newTab );
            }

            function updatePagination() {
                var tabs = element.find( 'md-tab' );
                var tabsWidth = element.parent().prop( 'clientWidth' ) - PAGINATORS_WIDTH;
                var needPagination = tabsWidth && TAB_MIN_WIDTH * tabsCtrl.count() > tabsWidth;
                var paginationToggled = needPagination !== state.active;
                // If the md-tabs element is not displayed, then do nothing.
                if ( tabsWidth <= 0 ) {
                    needPagination = false;
                    paginationToggled = true;
                }
                state.active = needPagination;
                if ( needPagination ) {
                    state.pagesCount = Math.ceil( ( TAB_MIN_WIDTH * tabsCtrl.count() ) / tabsWidth );
                    state.itemsPerPage = Math.max( 1, Math.floor( tabsCtrl.count() / state.pagesCount ) );
                    state.tabWidth = tabsWidth / state.itemsPerPage;
                    tabsParent.css( 'width', state.tabWidth * tabsCtrl.count() + 'px' );
                    tabs.css( 'width', state.tabWidth + 'px' );
                    var selectedTabPage = getPageForTab( tabsCtrl.selected() );
                    setPage( selectedTabPage );
                } else {
                    if ( paginationToggled ) {
                        $timeout( function() {
                            tabsParent.css( 'width', '' );
                            tabs.css( 'width', '' );
                            slideTabButtons( 0 );
                            state.page = -1;
                        } );
                    }
                }
            }

            function slideTabButtons( x ) {
                if ( tabsCtrl.pagingOffset === x ) {
                    // Resolve instantly if no change
                    return $$q.when();
                }
                var deferred = $$q.defer();
                tabsCtrl.$$pagingOffset = x;
                tabsParent.css( $mdConstant.CSS.TRANSFORM, 'translate3d(' + x + 'px,0,0)' );
                tabsParent.on( $mdConstant.CSS.TRANSITIONEND, onTabsParentTransitionEnd );
                return deferred.promise;

                function onTabsParentTransitionEnd( ev ) {
                    // Make sure this event didn't bubble up from an animation in a child element.
                    if ( ev.target === tabsParent[ 0 ] ) {
                        tabsParent.off( $mdConstant.CSS.TRANSITIONEND, onTabsParentTransitionEnd );
                        deferred.resolve();
                    }
                }
            }

            function getPageForTab( tab ) {
                var tabIndex = tabsCtrl.indexOf( tab );
                if ( tabIndex === -1 ) return 0;
                return Math.floor( tabIndex / state.itemsPerPage );
            }

            function setPage( page ) {
                if ( page === state.page ) return;
                var lastPage = state.pagesCount;
                if ( page < 0 ) page = 0;
                if ( page > lastPage ) page = lastPage;
                state.hasPrev = page > 0;
                state.hasNext = ( ( page + 1 ) * state.itemsPerPage ) < tabsCtrl.count();
                state.page = page;
                $timeout( function() {
                    scope.$broadcast( '$mdTabsPaginationChanged' );
                } );
                return slideTabButtons( -page * state.itemsPerPage * state.tabWidth );
            }
        }
    }
    TabPaginationDirective.$inject = [ "$mdConstant", "$window", "$$rAF", "$$q", "$timeout" ];
} )();
( function() {
    'use strict';
    angular.module( 'material.components.tabs' ).controller( '$mdTab', TabItemController );

    function TabItemController( $scope, $element, $attrs, $compile, $animate, $mdUtil, $parse ) {
        var self = this;
        // Properties
        self.contentContainer = angular.element( '<div class="md-tab-content ng-hide">' );
        self.hammertime = new Hammer( self.contentContainer[ 0 ] );
        self.element = $element;
        // Methods
        self.isDisabled = isDisabled;
        self.onAdd = onAdd;
        self.onRemove = onRemove;
        self.onSelect = onSelect;
        self.onDeselect = onDeselect;
        var disabledParsed = $parse( $attrs.ngDisabled );

        function isDisabled() {
                return disabledParsed( $scope.$parent );
            }
            /**
             * Add the tab's content to the DOM container area in the tabs,
             * @param contentArea the contentArea to add the content of the tab to
             */
        function onAdd( contentArea ) {
            if ( self.content.length ) {
                self.contentContainer.append( self.content );
                self.contentScope = $scope.$parent.$new();
                contentArea.append( self.contentContainer );
                $compile( self.contentContainer )( self.contentScope );
                $mdUtil.disconnectScope( self.contentScope );
            }
        }

        function onRemove() {
            self.hammertime.destroy();
            $animate.leave( self.contentContainer ).then( function() {
                self.contentScope && self.contentScope.$destroy();
                self.contentScope = null;
            } );
        }

        function onSelect() {
            // Resume watchers and events firing when tab is selected
            $mdUtil.reconnectScope( self.contentScope );
            self.hammertime.on( 'swipeleft swiperight', $scope.onSwipe );
            $element.addClass( 'active' );
            $element.attr( 'aria-selected', true );
            $element.attr( 'tabIndex', 0 );
            $animate.removeClass( self.contentContainer, 'ng-hide' );
            $scope.onSelect();
        }

        function onDeselect() {
            // Stop watchers & events from firing while tab is deselected
            $mdUtil.disconnectScope( self.contentScope );
            self.hammertime.off( 'swipeleft swiperight', $scope.onSwipe );
            $element.removeClass( 'active' );
            $element.attr( 'aria-selected', false );
            // Only allow tabbing to the active tab
            $element.attr( 'tabIndex', -1 );
            $animate.addClass( self.contentContainer, 'ng-hide' );
            $scope.onDeselect();
        }
    }
    TabItemController.$inject = [ "$scope", "$element", "$attrs", "$compile", "$animate", "$mdUtil", "$parse" ];
} )();
( function() {
    'use strict';
    angular.module( 'material.components.tabs' ).directive( 'mdTab', MdTabDirective );
    /**
     * @ngdoc directive
     * @name mdTab
     * @module material.components.tabs
     *
     * @restrict E
     *
     * @description
     * `<md-tab>` is the nested directive used [within `<md-tabs>`] to specify each tab with a **label** and optional *view content*.
     *
     * If the `label` attribute is not specified, then an optional `<md-tab-label>` tag can be used to specified more
     * complex tab header markup. If neither the **label** nor the **md-tab-label** are specified, then the nested
     * markup of the `<md-tab>` is used as the tab header markup.
     *
     * If a tab **label** has been identified, then any **non-**`<md-tab-label>` markup
     * will be considered tab content and will be transcluded to the internal `<div class="md-tabs-content">` container.
     *
     * This container is used by the TabsController to show/hide the active tab's content view. This synchronization is
     * automatically managed by the internal TabsController whenever the tab selection changes. Selection changes can
     * be initiated via data binding changes, programmatic invocation, or user gestures.
     *
     * @param {string=} label Optional attribute to specify a simple string as the tab label
     * @param {boolean=} md-active When evaluteing to true, selects the tab.
     * @param {boolean=} disabled If present, disabled tab selection.
     * @param {expression=} md-on-deselect Expression to be evaluated after the tab has been de-selected.
     * @param {expression=} md-on-select Expression to be evaluated after the tab has been selected.
     *
     *
     * @usage
     *
     * <hljs lang="html">
     * <md-tab label="" disabled="" md-on-select="" md-on-deselect="" >
     *   <h3>My Tab content</h3>
     * </md-tab>
     *
     * <md-tab >
     *   <md-tab-label>
     *     <h3>My Tab content</h3>
     *   </md-tab-label>
     *   <p>
     *     Sed ut perspiciatis unde omnis iste natus error sit voluptatem accusantium doloremque laudantium,
     *     totam rem aperiam, eaque ipsa quae ab illo inventore veritatis et quasi architecto beatae vitae
     *     dicta sunt explicabo. Nemo enim ipsam voluptatem quia voluptas sit aspernatur aut odit aut fugit,
     *     sed quia consequuntur magni dolores eos qui ratione voluptatem sequi nesciunt.
     *   </p>
     * </md-tab>
     * </hljs>
     *
     */
    function MdTabDirective( $mdInkRipple, $compile, $mdAria, $mdUtil, $mdConstant ) {
        return {
            restrict: 'E',
            require: [ 'mdTab', '^mdTabs' ],
            controller: '$mdTab',
            scope: {
                onSelect: '&mdOnSelect',
                onDeselect: '&mdOnDeselect',
                label: '@'
            },
            compile: compile
        };

        function compile( element, attr ) {
            var tabLabel = element.find( 'md-tab-label' );
            if ( tabLabel.length ) {
                // If a tab label element is found, remove it for later re-use.
                tabLabel.remove();
            } else if ( angular.isDefined( attr.label ) ) {
                // Otherwise, try to use attr.label as the label
                tabLabel = angular.element( '<md-tab-label>' ).html( attr.label );
            } else {
                // If nothing is found, use the tab's content as the label
                tabLabel = angular.element( '<md-tab-label>' ).append( element.contents().remove() );
            }
            // Everything that's left as a child is the tab's content.
            var tabContent = element.contents().remove();
            return function postLink( scope, element, attr, ctrls ) {
                var tabItemCtrl = ctrls[ 0 ]; // Controller for THIS tabItemCtrl
                var tabsCtrl = ctrls[ 1 ]; // Controller for ALL tabs
                transcludeTabContent();
                configureAria();
                var detachRippleFn = $mdInkRipple.attachTabBehavior( scope, element, {
                    colorElement: tabsCtrl.inkBarElement
                } );
                tabsCtrl.add( tabItemCtrl );
                scope.$on( '$destroy', function() {
                    detachRippleFn();
                    tabsCtrl.remove( tabItemCtrl );
                } );
                if ( !angular.isDefined( attr.ngClick ) ) {
                    element.on( 'click', defaultClickListener );
                }
                element.on( 'keydown', keydownListener );
                scope.onSwipe = onSwipe;
                if ( angular.isNumber( scope.$parent.$index ) ) {
                    watchNgRepeatIndex();
                }
                if ( angular.isDefined( attr.mdActive ) ) {
                    watchActiveAttribute();
                }
                watchDisabled();

                function transcludeTabContent() {
                        // Clone the label we found earlier, and $compile and append it
                        var label = tabLabel.clone();
                        element.append( label );
                        $compile( label )( scope.$parent );
                        // Clone the content we found earlier, and mark it for later placement into
                        // the proper content area.
                        tabItemCtrl.content = tabContent.clone();
                    }
                    //defaultClickListener isn't applied if the user provides an ngClick expression.
                function defaultClickListener() {
                    scope.$apply( function() {
                        tabsCtrl.select( tabItemCtrl );
                        tabsCtrl.focus( tabItemCtrl );
                    } );
                }

                function keydownListener( ev ) {
                    if ( ev.keyCode == $mdConstant.KEY_CODE.SPACE || ev.keyCode == $mdConstant.KEY_CODE.ENTER ) {
                        // Fire the click handler to do normal selection if space is pressed
                        element.triggerHandler( 'click' );
                        ev.preventDefault();
                    } else if ( ev.keyCode === $mdConstant.KEY_CODE.LEFT_ARROW ) {
                        scope.$evalAsync( function() {
                            tabsCtrl.focus( tabsCtrl.previous( tabItemCtrl ) );
                        } );
                    } else if ( ev.keyCode === $mdConstant.KEY_CODE.RIGHT_ARROW ) {
                        scope.$evalAsync( function() {
                            tabsCtrl.focus( tabsCtrl.next( tabItemCtrl ) );
                        } );
                    }
                }

                function onSwipe( ev ) {
                        scope.$apply( function() {
                            if ( ev.type === 'swipeleft' ) {
                                tabsCtrl.select( tabsCtrl.next() );
                            } else {
                                tabsCtrl.select( tabsCtrl.previous() );
                            }
                        } );
                    }
                    // If tabItemCtrl is part of an ngRepeat, move the tabItemCtrl in our internal array
                    // when its $index changes
                function watchNgRepeatIndex() {
                    // The tabItemCtrl has an isolate scope, so we watch the $index on the parent.
                    scope.$watch( '$parent.$index', function $indexWatchAction( newIndex ) {
                        tabsCtrl.move( tabItemCtrl, newIndex );
                    } );
                }

                function watchActiveAttribute() {
                    var unwatch = scope.$parent.$watch( '!!(' + attr.mdActive + ')', activeWatchAction );
                    scope.$on( '$destroy', unwatch );

                    function activeWatchAction( isActive ) {
                        var isSelected = tabsCtrl.selected() === tabItemCtrl;
                        if ( isActive && !isSelected ) {
                            tabsCtrl.select( tabItemCtrl );
                        } else if ( !isActive && isSelected ) {
                            tabsCtrl.deselect( tabItemCtrl );
                        }
                    }
                }

                function watchDisabled() {
                    scope.$watch( tabItemCtrl.isDisabled, disabledWatchAction );

                    function disabledWatchAction( isDisabled ) {
                        element.attr( 'aria-disabled', isDisabled );
                        // Auto select `next` tab when disabled
                        var isSelected = ( tabsCtrl.selected() === tabItemCtrl );
                        if ( isSelected && isDisabled ) {
                            tabsCtrl.select( tabsCtrl.next() || tabsCtrl.previous() );
                        }
                    }
                }

                function configureAria() {
                    // Link together the content area and tabItemCtrl with an id
                    var tabId = attr.id || ( 'tab_' + $mdUtil.nextUid() );
                    element.attr( {
                        id: tabId,
                        role: 'tab',
                        tabIndex: -1 //this is also set on select/deselect in tabItemCtrl
                    } );
                    // Only setup the contentContainer's aria attributes if tab content is provided
                    if ( tabContent.length ) {
                        var tabContentId = 'content_' + tabId;
                        if ( !element.attr( 'aria-controls' ) ) {
                            element.attr( 'aria-controls', tabContentId );
                        }
                        tabItemCtrl.contentContainer.attr( {
                            id: tabContentId,
                            role: 'tabpanel',
                            'aria-labelledby': tabId
                        } );
                    }
                }
            };
        }
    }
    MdTabDirective.$inject = [ "$mdInkRipple", "$compile", "$mdAria", "$mdUtil", "$mdConstant" ];
} )();
( function() {
    'use strict';
    angular.module( 'material.components.tabs' ).controller( '$mdTabs', MdTabsController );

    function MdTabsController( $scope, $element, $mdUtil ) {
        var tabsList = $mdUtil.iterator( [], false );
        var self = this;
        // Properties
        self.$element = $element;
        self.scope = $scope;
        // The section containing the tab content $elements
        self.contentArea = angular.element( $element[ 0 ].querySelector( '.md-tabs-content' ) );
        // Methods from iterator
        self.inRange = tabsList.inRange;
        self.indexOf = tabsList.indexOf;
        self.itemAt = tabsList.itemAt;
        self.count = tabsList.count;
        self.selected = selected;
        self.add = add;
        self.remove = remove;
        self.move = move;
        self.select = select;
        self.focus = focus;
        self.deselect = deselect;
        self.next = next;
        self.previous = previous;
        $scope.$on( '$destroy', function() {
            self.deselect( self.selected() );
            for ( var i = tabsList.count() - 1; i >= 0; i-- ) {
                self.remove( tabsList[ i ], true );
            }
        } );
        // Get the selected tab
        function selected() {
                return self.itemAt( $scope.selectedIndex );
            }
            // Add a new tab.
            // Returns a method to remove the tab from the list.
        function add( tab, index ) {
            tabsList.add( tab, index );
            tab.onAdd( self.contentArea );
            // Select the new tab if we don't have a selectedIndex, or if the
            // selectedIndex we've been waiting for is this tab
            if ( $scope.selectedIndex === -1 || !angular.isNumber( $scope.selectedIndex ) || $scope.selectedIndex === self.indexOf( tab ) ) {
                self.select( tab );
            }
            $scope.$broadcast( '$mdTabsChanged' );
        }

        function remove( tab, noReselect ) {
                if ( !tabsList.contains( tab ) ) return;
                if ( noReselect ) {
                    // do nothing
                } else if ( self.selected() === tab ) {
                    if ( tabsList.count() > 1 ) {
                        self.select( self.previous() || self.next() );
                    } else {
                        self.deselect( tab );
                    }
                }
                tabsList.remove( tab );
                tab.onRemove();
                $scope.$broadcast( '$mdTabsChanged' );
            }
            // Move a tab (used when ng-repeat order changes)
        function move( tab, toIndex ) {
            var isSelected = self.selected() === tab;
            tabsList.remove( tab );
            tabsList.add( tab, toIndex );
            if ( isSelected ) self.select( tab );
            $scope.$broadcast( '$mdTabsChanged' );
        }

        function select( tab ) {
            if ( !tab || tab.isSelected || tab.isDisabled() ) return;
            if ( !tabsList.contains( tab ) ) return;
            self.deselect( self.selected() );
            $scope.selectedIndex = self.indexOf( tab );
            tab.isSelected = true;
            tab.onSelect();
        }

        function focus( tab ) {
            // this variable is $watch'd by pagination
            self.tabToFocus = tab;
        }

        function deselect( tab ) {
            if ( !tab || !tab.isSelected ) return;
            if ( !tabsList.contains( tab ) ) return;
            $scope.selectedIndex = -1;
            tab.isSelected = false;
            tab.onDeselect();
        }

        function next( tab, filterFn ) {
            return tabsList.next( tab || self.selected(), filterFn || isTabEnabled );
        }

        function previous( tab, filterFn ) {
            return tabsList.previous( tab || self.selected(), filterFn || isTabEnabled );
        }

        function isTabEnabled( tab ) {
            return tab && !tab.isDisabled();
        }
    }
    MdTabsController.$inject = [ "$scope", "$element", "$mdUtil" ];
} )();
( function() {
    'use strict';
    angular.module( 'material.components.tabs' ).directive( 'mdTabs', TabsDirective );
    /**
     * @ngdoc directive
     * @name mdTabs
     * @module material.components.tabs
     *
     * @restrict E
     *
     * @description
     * The `<md-tabs>` directive serves as the container for 1..n `<md-tab>` child directives to produces a Tabs components.
     * In turn, the nested `<md-tab>` directive is used to specify a tab label for the **header button** and a [optional] tab view
     * content that will be associated with each tab button.
     *
     * Below is the markup for its simplest usage:
     *
     *  <hljs lang="html">
     *  <md-tabs>
     *    <md-tab label="Tab #1"></md-tab>
     *    <md-tab label="Tab #2"></md-tab>
     *    <md-tab label="Tab #3"></md-tab>
     *  <md-tabs>
     *  </hljs>
     *
     * Tabs supports three (3) usage scenarios:
     *
     *  1. Tabs (buttons only)
     *  2. Tabs with internal view content
     *  3. Tabs with external view content
     *
     * **Tab-only** support is useful when tab buttons are used for custom navigation regardless of any other components, content, or views.
     * **Tabs with internal views** are the traditional usages where each tab has associated view content and the view switching is managed internally by the Tabs component.
     * **Tabs with external view content** is often useful when content associated with each tab is independently managed and data-binding notifications announce tab selection changes.
     *
     * > As a performance bonus, if the tab content is managed internally then the non-active (non-visible) tab contents are temporarily disconnected from the `$scope.$digest()` processes; which restricts and optimizes DOM updates to only the currently active tab.
     *
     * Additional features also include:
     *
     * *  Content can include any markup.
     * *  If a tab is disabled while active/selected, then the next tab will be auto-selected.
     * *  If the currently active tab is the last tab, then next() action will select the first tab.
     * *  Any markup (other than **`<md-tab>`** tags) will be transcluded into the tab header area BEFORE the tab buttons.
     *
     * @param {integer=} md-selected Index of the active/selected tab
     * @param {boolean=} md-no-ink If present, disables ink ripple effects.
     * @param {boolean=} md-no-bar If present, disables the selection ink bar.
     * @param {string=}  md-align-tabs Attribute to indicate position of tab buttons: bottom or top; default is `top`
     *
     * @usage
     * <hljs lang="html">
     * <md-tabs md-selected="selectedIndex" >
     *   <img ng-src="img/angular.png" class="centered">
     *
     *   <md-tab
     *      ng-repeat="tab in tabs | orderBy:predicate:reversed"
     *      md-on-select="onTabSelected(tab)"
     *      md-on-deselect="announceDeselected(tab)"
     *      disabled="tab.disabled" >
     *
     *       <md-tab-label>
     *           {{tab.title}}
     *           <img src="img/removeTab.png"
     *                ng-click="removeTab(tab)"
     *                class="delete" >
     *       </md-tab-label>
     *
     *       {{tab.content}}
     *
     *   </md-tab>
     *
     * </md-tabs>
     * </hljs>
     *
     */
    function TabsDirective( $parse, $mdTheming ) {
        return {
            restrict: 'E',
            controller: '$mdTabs',
            require: 'mdTabs',
            transclude: true,
            scope: {
                selectedIndex: '=?mdSelected'
            },
            template: '<section class="md-header" ' + 'ng-class="{\'md-paginating\': pagination.active}">' + '<button class="md-paginator md-prev" ' + 'ng-if="pagination.active && pagination.hasPrev" ' + 'ng-click="pagination.clickPrevious()" ' + 'aria-hidden="true">' + '</button>' +
                // overflow: hidden container when paginating
                '<div class="md-header-items-container" md-tabs-pagination>' +
                // flex container for <md-tab> elements
                '<div class="md-header-items">' + '<md-tabs-ink-bar></md-tabs-ink-bar>' + '<md-tabs-ink-bar class="md-ink-bar-delayed"></md-tabs-ink-bar>' + '</div>' + '</div>' + '<button class="md-paginator md-next" ' + 'ng-if="pagination.active && pagination.hasNext" ' + 'ng-click="pagination.clickNext()" ' + 'aria-hidden="true">' + '</button>' + '</section>' + '<section class="md-tabs-content"></section>',
            link: postLink
        };

        function postLink( scope, element, attr, tabsCtrl, transclude ) {
            $mdTheming( element );
            configureAria();
            watchSelected();
            transclude( scope.$parent, function( clone ) {
                angular.element( element[ 0 ].querySelector( '.md-header-items' ) ).append( clone );
            } );

            function configureAria() {
                element.attr( {
                    role: 'tablist'
                } );
            }

            function watchSelected() {
                scope.$watch( 'selectedIndex', function watchSelectedIndex( newIndex, oldIndex ) {
                    // Note: if the user provides an invalid newIndex, all tabs will be deselected
                    // and the associated view will be hidden.
                    tabsCtrl.deselect( tabsCtrl.itemAt( oldIndex ) );
                    if ( tabsCtrl.inRange( newIndex ) ) {
                        var newTab = tabsCtrl.itemAt( newIndex );
                        // If the newTab is disabled, find an enabled one to go to.
                        if ( newTab && newTab.isDisabled() ) {
                            newTab = newIndex > oldIndex ? tabsCtrl.next( newTab ) : tabsCtrl.previous( newTab );
                        }
                        tabsCtrl.select( newTab );
                    }
                } );
            }
        }
    }
    TabsDirective.$inject = [ "$parse", "$mdTheming" ];
} )();
/**
 * @license AngularJS v1.3.7
 * (c) 2010-2014 Google, Inc. http://angularjs.org
 * License: MIT
 */
( function( window, angular, undefined ) {
    'use strict';
    /**
     * @ngdoc module
     * @name ngRoute
     * @description
     *
     * # ngRoute
     *
     * The `ngRoute` module provides routing and deeplinking services and directives for angular apps.
     *
     * ## Example
     * See {@link ngRoute.$route#example $route} for an example of configuring and using `ngRoute`.
     *
     *
     * <div doc-module-components="ngRoute"></div>
     */
    /* global -ngRouteModule */
    var ngRouteModule = angular.module( 'ngRoute', [ 'ng' ] ).
    provider( '$route', $RouteProvider ),
        $routeMinErr = angular.$$minErr( 'ngRoute' );
    /**
     * @ngdoc provider
     * @name $routeProvider
     *
     * @description
     *
     * Used for configuring routes.
     *
     * ## Example
     * See {@link ngRoute.$route#example $route} for an example of configuring and using `ngRoute`.
     *
     * ## Dependencies
     * Requires the {@link ngRoute `ngRoute`} module to be installed.
     */
    function $RouteProvider() {
        function inherit( parent, extra ) {
            return angular.extend( Object.create( parent ), extra );
        }
        var routes = {};
        /**
         * @ngdoc method
         * @name $routeProvider#when
         *
         * @param {string} path Route path (matched against `$location.path`). If `$location.path`
         *    contains redundant trailing slash or is missing one, the route will still match and the
         *    `$location.path` will be updated to add or drop the trailing slash to exactly match the
         *    route definition.
         *
         *    * `path` can contain named groups starting with a colon: e.g. `:name`. All characters up
         *        to the next slash are matched and stored in `$routeParams` under the given `name`
         *        when the route matches.
         *    * `path` can contain named groups starting with a colon and ending with a star:
         *        e.g.`:name*`. All characters are eagerly stored in `$routeParams` under the given `name`
         *        when the route matches.
         *    * `path` can contain optional named groups with a question mark: e.g.`:name?`.
         *
         *    For example, routes like `/color/:color/largecode/:largecode*\/edit` will match
         *    `/color/brown/largecode/code/with/slashes/edit` and extract:
         *
         *    * `color: brown`
         *    * `largecode: code/with/slashes`.
         *
         *
         * @param {Object} route Mapping information to be assigned to `$route.current` on route
         *    match.
         *
         *    Object properties:
         *
         *    - `controller`  `{(string|function()=}`  Controller fn that should be associated with
         *      newly created scope or the name of a {@link angular.Module#controller registered
         *      controller} if passed as a string.
         *    - `controllerAs`  `{string=}`  A controller alias name. If present the controller will be
         *      published to scope under the `controllerAs` name.
         *    - `template`  `{string=|function()=}`  html template as a string or a function that
         *      returns an html template as a string which should be used by {@link
         *      ngRoute.directive:ngView ngView} or {@link ng.directive:ngInclude ngInclude} directives.
         *      This property takes precedence over `templateUrl`.
         *
         *      If `template` is a function, it will be called with the following parameters:
         *
         *      - `{Array.<Object>}` - route parameters extracted from the current
         *        `$location.path()` by applying the current route
         *
         *    - `templateUrl`  `{string=|function()=}`  path or function that returns a path to an html
         *      template that should be used by {@link ngRoute.directive:ngView ngView}.
         *
         *      If `templateUrl` is a function, it will be called with the following parameters:
         *
         *      - `{Array.<Object>}` - route parameters extracted from the current
         *        `$location.path()` by applying the current route
         *
         *    - `resolve` - `{Object.<string, function>=}` - An optional map of dependencies which should
         *      be injected into the controller. If any of these dependencies are promises, the router
         *      will wait for them all to be resolved or one to be rejected before the controller is
         *      instantiated.
         *      If all the promises are resolved successfully, the values of the resolved promises are
         *      injected and {@link ngRoute.$route#$routeChangeSuccess $routeChangeSuccess} event is
         *      fired. If any of the promises are rejected the
         *      {@link ngRoute.$route#$routeChangeError $routeChangeError} event is fired. The map object
         *      is:
         *
         *      - `key`  `{string}`: a name of a dependency to be injected into the controller.
         *      - `factory` - `{string|function}`: If `string` then it is an alias for a service.
         *        Otherwise if function, then it is {@link auto.$injector#invoke injected}
         *        and the return value is treated as the dependency. If the result is a promise, it is
         *        resolved before its value is injected into the controller. Be aware that
         *        `ngRoute.$routeParams` will still refer to the previous route within these resolve
         *        functions.  Use `$route.current.params` to access the new route parameters, instead.
         *
         *    - `redirectTo`  {(string|function())=}  value to update
         *      {@link ng.$location $location} path with and trigger route redirection.
         *
         *      If `redirectTo` is a function, it will be called with the following parameters:
         *
         *      - `{Object.<string>}` - route parameters extracted from the current
         *        `$location.path()` by applying the current route templateUrl.
         *      - `{string}` - current `$location.path()`
         *      - `{Object}` - current `$location.search()`
         *
         *      The custom `redirectTo` function is expected to return a string which will be used
         *      to update `$location.path()` and `$location.search()`.
         *
         *    - `[reloadOnSearch=true]` - {boolean=} - reload route when only `$location.search()`
         *      or `$location.hash()` changes.
         *
         *      If the option is set to `false` and url in the browser changes, then
         *      `$routeUpdate` event is broadcasted on the root scope.
         *
         *    - `[caseInsensitiveMatch=false]` - {boolean=} - match routes without being case sensitive
         *
         *      If the option is set to `true`, then the particular route can be matched without being
         *      case sensitive
         *
         * @returns {Object} self
         *
         * @description
         * Adds a new route definition to the `$route` service.
         */
        this.when = function( path, route ) {
            //copy original route object to preserve params inherited from proto chain
            var routeCopy = angular.copy( route );
            if ( angular.isUndefined( routeCopy.reloadOnSearch ) ) {
                routeCopy.reloadOnSearch = true;
            }
            if ( angular.isUndefined( routeCopy.caseInsensitiveMatch ) ) {
                routeCopy.caseInsensitiveMatch = this.caseInsensitiveMatch;
            }
            routes[ path ] = angular.extend( routeCopy, path && pathRegExp( path, routeCopy ) );
            // create redirection for trailing slashes
            if ( path ) {
                var redirectPath = ( path[ path.length - 1 ] == '/' ) ? path.substr( 0, path.length - 1 ) : path + '/';
                routes[ redirectPath ] = angular.extend( {
                    redirectTo: path
                }, pathRegExp( redirectPath, routeCopy ) );
            }
            return this;
        };
        /**
         * @ngdoc property
         * @name $routeProvider#caseInsensitiveMatch
         * @description
         *
         * A boolean property indicating if routes defined
         * using this provider should be matched using a case insensitive
         * algorithm. Defaults to `false`.
         */
        this.caseInsensitiveMatch = false;
        /**
         * @param path {string} path
         * @param opts {Object} options
         * @return {?Object}
         *
         * @description
         * Normalizes the given path, returning a regular expression
         * and the original path.
         *
         * Inspired by pathRexp in visionmedia/express/lib/utils.js.
         */
        function pathRegExp( path, opts ) {
                var insensitive = opts.caseInsensitiveMatch,
                    ret = {
                        originalPath: path,
                        regexp: path
                    },
                    keys = ret.keys = [];
                path = path.replace( /([().])/g, '\\$1' ).replace( /(\/)?:(\w+)([\?\*])?/g, function( _, slash, key, option ) {
                    var optional = option === '?' ? option : null;
                    var star = option === '*' ? option : null;
                    keys.push( {
                        name: key,
                        optional: !!optional
                    } );
                    slash = slash || '';
                    return '' + ( optional ? '' : slash ) + '(?:' + ( optional ? slash : '' ) + ( star && '(.+?)' || '([^/]+)' ) + ( optional || '' ) + ')' + ( optional || '' );
                } ).replace( /([\/$\*])/g, '\\$1' );
                ret.regexp = new RegExp( '^' + path + '$', insensitive ? 'i' : '' );
                return ret;
            }
            /**
             * @ngdoc method
             * @name $routeProvider#otherwise
             *
             * @description
             * Sets route definition that will be used on route change when no other route definition
             * is matched.
             *
             * @param {Object|string} params Mapping information to be assigned to `$route.current`.
             * If called with a string, the value maps to `redirectTo`.
             * @returns {Object} self
             */
        this.otherwise = function( params ) {
            if ( typeof params === 'string' ) {
                params = {
                    redirectTo: params
                };
            }
            this.when( null, params );
            return this;
        };
        this.$get = [ '$rootScope',
               '$location',
               '$routeParams',
               '$q',
               '$injector',
               '$templateRequest',
               '$sce',
      function( $rootScope, $location, $routeParams, $q, $injector, $templateRequest, $sce ) {
                /**
                 * @ngdoc service
                 * @name $route
                 * @requires $location
                 * @requires $routeParams
                 *
                 * @property {Object} current Reference to the current route definition.
                 * The route definition contains:
                 *
                 *   - `controller`: The controller constructor as define in route definition.
                 *   - `locals`: A map of locals which is used by {@link ng.$controller $controller} service for
                 *     controller instantiation. The `locals` contain
                 *     the resolved values of the `resolve` map. Additionally the `locals` also contain:
                 *
                 *     - `$scope` - The current route scope.
                 *     - `$template` - The current route template HTML.
                 *
                 * @property {Object} routes Object with all route configuration Objects as its properties.
                 *
                 * @description
                 * `$route` is used for deep-linking URLs to controllers and views (HTML partials).
                 * It watches `$location.url()` and tries to map the path to an existing route definition.
                 *
                 * Requires the {@link ngRoute `ngRoute`} module to be installed.
                 *
                 * You can define routes through {@link ngRoute.$routeProvider $routeProvider}'s API.
                 *
                 * The `$route` service is typically used in conjunction with the
                 * {@link ngRoute.directive:ngView `ngView`} directive and the
                 * {@link ngRoute.$routeParams `$routeParams`} service.
                 *
                 * @example
                 * This example shows how changing the URL hash causes the `$route` to match a route against the
                 * URL, and the `ngView` pulls in the partial.
                 *
                 * <example name="$route-service" module="ngRouteExample"
                 *          deps="angular-route.js" fixBase="true">
                 *   <file name="index.html">
                 *     <div ng-controller="MainController">
                 *       Choose:
                 *       <a href="Book/Moby">Moby</a> |
                 *       <a href="Book/Moby/ch/1">Moby: Ch1</a> |
                 *       <a href="Book/Gatsby">Gatsby</a> |
                 *       <a href="Book/Gatsby/ch/4?key=value">Gatsby: Ch4</a> |
                 *       <a href="Book/Scarlet">Scarlet Letter</a><br/>
                 *
                 *       <div ng-view></div>
                 *
                 *       <hr />
                 *
                 *       <pre>$location.path() = {{$location.path()}}</pre>
                 *       <pre>$route.current.templateUrl = {{$route.current.templateUrl}}</pre>
                 *       <pre>$route.current.params = {{$route.current.params}}</pre>
                 *       <pre>$route.current.scope.name = {{$route.current.scope.name}}</pre>
                 *       <pre>$routeParams = {{$routeParams}}</pre>
                 *     </div>
                 *   </file>
                 *
                 *   <file name="book.html">
                 *     controller: {{name}}<br />
                 *     Book Id: {{params.bookId}}<br />
                 *   </file>
                 *
                 *   <file name="chapter.html">
                 *     controller: {{name}}<br />
                 *     Book Id: {{params.bookId}}<br />
                 *     Chapter Id: {{params.chapterId}}
                 *   </file>
                 *
                 *   <file name="script.js">
                 *     angular.module('ngRouteExample', ['ngRoute'])
                 *
                 *      .controller('MainController', function($scope, $route, $routeParams, $location) {
                 *          $scope.$route = $route;
                 *          $scope.$location = $location;
                 *          $scope.$routeParams = $routeParams;
                 *      })
                 *
                 *      .controller('BookController', function($scope, $routeParams) {
                 *          $scope.name = "BookController";
                 *          $scope.params = $routeParams;
                 *      })
                 *
                 *      .controller('ChapterController', function($scope, $routeParams) {
                 *          $scope.name = "ChapterController";
                 *          $scope.params = $routeParams;
                 *      })
                 *
                 *     .config(function($routeProvider, $locationProvider) {
                 *       $routeProvider
                 *        .when('/Book/:bookId', {
                 *         templateUrl: 'book.html',
                 *         controller: 'BookController',
                 *         resolve: {
                 *           // I will cause a 1 second delay
                 *           delay: function($q, $timeout) {
                 *             var delay = $q.defer();
                 *             $timeout(delay.resolve, 1000);
                 *             return delay.promise;
                 *           }
                 *         }
                 *       })
                 *       .when('/Book/:bookId/ch/:chapterId', {
                 *         templateUrl: 'chapter.html',
                 *         controller: 'ChapterController'
                 *       });
                 *
                 *       // configure html5 to get links working on jsfiddle
                 *       $locationProvider.html5Mode(true);
                 *     });
                 *
                 *   </file>
                 *
                 *   <file name="protractor.js" type="protractor">
                 *     it('should load and compile correct template', function() {
                 *       element(by.linkText('Moby: Ch1')).click();
                 *       var content = element(by.css('[ng-view]')).getText();
                 *       expect(content).toMatch(/controller\: ChapterController/);
                 *       expect(content).toMatch(/Book Id\: Moby/);
                 *       expect(content).toMatch(/Chapter Id\: 1/);
                 *
                 *       element(by.partialLinkText('Scarlet')).click();
                 *
                 *       content = element(by.css('[ng-view]')).getText();
                 *       expect(content).toMatch(/controller\: BookController/);
                 *       expect(content).toMatch(/Book Id\: Scarlet/);
                 *     });
                 *   </file>
                 * </example>
                 */
                /**
                 * @ngdoc event
                 * @name $route#$routeChangeStart
                 * @eventType broadcast on root scope
                 * @description
                 * Broadcasted before a route change. At this  point the route services starts
                 * resolving all of the dependencies needed for the route change to occur.
                 * Typically this involves fetching the view template as well as any dependencies
                 * defined in `resolve` route property. Once  all of the dependencies are resolved
                 * `$routeChangeSuccess` is fired.
                 *
                 * The route change (and the `$location` change that triggered it) can be prevented
                 * by calling `preventDefault` method of the event. See {@link ng.$rootScope.Scope#$on}
                 * for more details about event object.
                 *
                 * @param {Object} angularEvent Synthetic event object.
                 * @param {Route} next Future route information.
                 * @param {Route} current Current route information.
                 */
                /**
                 * @ngdoc event
                 * @name $route#$routeChangeSuccess
                 * @eventType broadcast on root scope
                 * @description
                 * Broadcasted after a route dependencies are resolved.
                 * {@link ngRoute.directive:ngView ngView} listens for the directive
                 * to instantiate the controller and render the view.
                 *
                 * @param {Object} angularEvent Synthetic event object.
                 * @param {Route} current Current route information.
                 * @param {Route|Undefined} previous Previous route information, or undefined if current is
                 * first route entered.
                 */
                /**
                 * @ngdoc event
                 * @name $route#$routeChangeError
                 * @eventType broadcast on root scope
                 * @description
                 * Broadcasted if any of the resolve promises are rejected.
                 *
                 * @param {Object} angularEvent Synthetic event object
                 * @param {Route} current Current route information.
                 * @param {Route} previous Previous route information.
                 * @param {Route} rejection Rejection of the promise. Usually the error of the failed promise.
                 */
                /**
                 * @ngdoc event
                 * @name $route#$routeUpdate
                 * @eventType broadcast on root scope
                 * @description
                 *
                 * The `reloadOnSearch` property has been set to false, and we are reusing the same
                 * instance of the Controller.
                 */
                var forceReload = false,
                    preparedRoute,
                    preparedRouteIsUpdateOnly,
                    $route = {
                        routes: routes,
                        /**
                         * @ngdoc method
                         * @name $route#reload
                         *
                         * @description
                         * Causes `$route` service to reload the current route even if
                         * {@link ng.$location $location} hasn't changed.
                         *
                         * As a result of that, {@link ngRoute.directive:ngView ngView}
                         * creates new scope and reinstantiates the controller.
                         */
                        reload: function() {
                            forceReload = true;
                            $rootScope.$evalAsync( function() {
                                // Don't support cancellation of a reload for now...
                                prepareRoute();
                                commitRoute();
                            } );
                        },
                        /**
                         * @ngdoc method
                         * @name $route#updateParams
                         *
                         * @description
                         * Causes `$route` service to update the current URL, replacing
                         * current route parameters with those specified in `newParams`.
                         * Provided property names that match the route's path segment
                         * definitions will be interpolated into the location's path, while
                         * remaining properties will be treated as query params.
                         *
                         * @param {Object} newParams mapping of URL parameter names to values
                         */
                        updateParams: function( newParams ) {
                            if ( this.current && this.current.$$route ) {
                                var searchParams = {},
                                    self = this;
                                angular.forEach( Object.keys( newParams ), function( key ) {
                                    if ( !self.current.pathParams[ key ] ) searchParams[ key ] = newParams[ key ];
                                } );
                                newParams = angular.extend( {}, this.current.params, newParams );
                                $location.path( interpolate( this.current.$$route.originalPath, newParams ) );
                                $location.search( angular.extend( {}, $location.search(), searchParams ) );
                            } else {
                                throw $routeMinErr( 'norout', 'Tried updating route when with no current route' );
                            }
                        }
                    };
                $rootScope.$on( '$locationChangeStart', prepareRoute );
                $rootScope.$on( '$locationChangeSuccess', commitRoute );
                return $route;
                /////////////////////////////////////////////////////
                /**
                 * @param on {string} current url
                 * @param route {Object} route regexp to match the url against
                 * @return {?Object}
                 *
                 * @description
                 * Check if the route matches the current url.
                 *
                 * Inspired by match in
                 * visionmedia/express/lib/router/router.js.
                 */
                function switchRouteMatcher( on, route ) {
                    var keys = route.keys,
                        params = {};
                    if ( !route.regexp ) return null;
                    var m = route.regexp.exec( on );
                    if ( !m ) return null;
                    for ( var i = 1, len = m.length; i < len; ++i ) {
                        var key = keys[ i - 1 ];
                        var val = m[ i ];
                        if ( key && val ) {
                            params[ key.name ] = val;
                        }
                    }
                    return params;
                }

                function prepareRoute( $locationEvent ) {
                    var lastRoute = $route.current;
                    preparedRoute = parseRoute();
                    preparedRouteIsUpdateOnly = preparedRoute && lastRoute && preparedRoute.$$route === lastRoute.$$route && angular.equals( preparedRoute.pathParams, lastRoute.pathParams ) && !preparedRoute.reloadOnSearch && !forceReload;
                    if ( !preparedRouteIsUpdateOnly && ( lastRoute || preparedRoute ) ) {
                        if ( $rootScope.$broadcast( '$routeChangeStart', preparedRoute, lastRoute ).defaultPrevented ) {
                            if ( $locationEvent ) {
                                $locationEvent.preventDefault();
                            }
                        }
                    }
                }

                function commitRoute() {
                        var lastRoute = $route.current;
                        var nextRoute = preparedRoute;
                        if ( preparedRouteIsUpdateOnly ) {
                            lastRoute.params = nextRoute.params;
                            angular.copy( lastRoute.params, $routeParams );
                            $rootScope.$broadcast( '$routeUpdate', lastRoute );
                        } else if ( nextRoute || lastRoute ) {
                            forceReload = false;
                            $route.current = nextRoute;
                            if ( nextRoute ) {
                                if ( nextRoute.redirectTo ) {
                                    if ( angular.isString( nextRoute.redirectTo ) ) {
                                        $location.path( interpolate( nextRoute.redirectTo, nextRoute.params ) ).search( nextRoute.params ).replace();
                                    } else {
                                        $location.url( nextRoute.redirectTo( nextRoute.pathParams, $location.path(), $location.search() ) ).replace();
                                    }
                                }
                            }
                            $q.when( nextRoute ).
                            then( function() {
                                    if ( nextRoute ) {
                                        var locals = angular.extend( {}, nextRoute.resolve ),
                                            template, templateUrl;
                                        angular.forEach( locals, function( value, key ) {
                                            locals[ key ] = angular.isString( value ) ? $injector.get( value ) : $injector.invoke( value, null, null, key );
                                        } );
                                        if ( angular.isDefined( template = nextRoute.template ) ) {
                                            if ( angular.isFunction( template ) ) {
                                                template = template( nextRoute.params );
                                            }
                                        } else if ( angular.isDefined( templateUrl = nextRoute.templateUrl ) ) {
                                            if ( angular.isFunction( templateUrl ) ) {
                                                templateUrl = templateUrl( nextRoute.params );
                                            }
                                            templateUrl = $sce.getTrustedResourceUrl( templateUrl );
                                            if ( angular.isDefined( templateUrl ) ) {
                                                nextRoute.loadedTemplateUrl = templateUrl;
                                                template = $templateRequest( templateUrl );
                                            }
                                        }
                                        if ( angular.isDefined( template ) ) {
                                            locals[ '$template' ] = template;
                                        }
                                        return $q.all( locals );
                                    }
                                } ).
                                // after route change
                            then( function( locals ) {
                                if ( nextRoute == $route.current ) {
                                    if ( nextRoute ) {
                                        nextRoute.locals = locals;
                                        angular.copy( nextRoute.params, $routeParams );
                                    }
                                    $rootScope.$broadcast( '$routeChangeSuccess', nextRoute, lastRoute );
                                }
                            }, function( error ) {
                                if ( nextRoute == $route.current ) {
                                    $rootScope.$broadcast( '$routeChangeError', nextRoute, lastRoute, error );
                                }
                            } );
                        }
                    }
                    /**
                     * @returns {Object} the current active route, by matching it against the URL
                     */
                function parseRoute() {
                        // Match a route
                        var params, match;
                        angular.forEach( routes, function( route, path ) {
                            if ( !match && ( params = switchRouteMatcher( $location.path(), route ) ) ) {
                                match = inherit( route, {
                                    params: angular.extend( {}, $location.search(), params ),
                                    pathParams: params
                                } );
                                match.$$route = route;
                            }
                        } );
                        // No route matched; fallback to "otherwise" route
                        return match || routes[ null ] && inherit( routes[ null ], {
                            params: {},
                            pathParams: {}
                        } );
                    }
                    /**
                     * @returns {string} interpolation of the redirect path with the parameters
                     */
                function interpolate( string, params ) {
                    var result = [];
                    angular.forEach( ( string || '' ).split( ':' ), function( segment, i ) {
                        if ( i === 0 ) {
                            result.push( segment );
                        } else {
                            var segmentMatch = segment.match( /(\w+)(?:[?*])?(.*)/ );
                            var key = segmentMatch[ 1 ];
                            result.push( params[ key ] );
                            result.push( segmentMatch[ 2 ] || '' );
                            delete params[ key ];
                        }
                    } );
                    return result.join( '' );
                }
  } ];
    }
    ngRouteModule.provider( '$routeParams', $RouteParamsProvider );
    /**
     * @ngdoc service
     * @name $routeParams
     * @requires $route
     *
     * @description
     * The `$routeParams` service allows you to retrieve the current set of route parameters.
     *
     * Requires the {@link ngRoute `ngRoute`} module to be installed.
     *
     * The route parameters are a combination of {@link ng.$location `$location`}'s
     * {@link ng.$location#search `search()`} and {@link ng.$location#path `path()`}.
     * The `path` parameters are extracted when the {@link ngRoute.$route `$route`} path is matched.
     *
     * In case of parameter name collision, `path` params take precedence over `search` params.
     *
     * The service guarantees that the identity of the `$routeParams` object will remain unchanged
     * (but its properties will likely change) even when a route change occurs.
     *
     * Note that the `$routeParams` are only updated *after* a route change completes successfully.
     * This means that you cannot rely on `$routeParams` being correct in route resolve functions.
     * Instead you can use `$route.current.params` to access the new route's parameters.
     *
     * @example
     * ```js
     *  // Given:
     *  // URL: http://server.com/index.html#/Chapter/1/Section/2?search=moby
     *  // Route: /Chapter/:chapterId/Section/:sectionId
     *  //
     *  // Then
     *  $routeParams ==> {chapterId:'1', sectionId:'2', search:'moby'}
     * ```
     */
    function $RouteParamsProvider() {
        this.$get = function() {
            return {};
        };
    }
    ngRouteModule.directive( 'ngView', ngViewFactory );
    ngRouteModule.directive( 'ngView', ngViewFillContentFactory );
    /**
     * @ngdoc directive
     * @name ngView
     * @restrict ECA
     *
     * @description
     * # Overview
     * `ngView` is a directive that complements the {@link ngRoute.$route $route} service by
     * including the rendered template of the current route into the main layout (`index.html`) file.
     * Every time the current route changes, the included view changes with it according to the
     * configuration of the `$route` service.
     *
     * Requires the {@link ngRoute `ngRoute`} module to be installed.
     *
     * @animations
     * enter - animation is used to bring new content into the browser.
     * leave - animation is used to animate existing content away.
     *
     * The enter and leave animation occur concurrently.
     *
     * @scope
     * @priority 400
     * @param {string=} onload Expression to evaluate whenever the view updates.
     *
     * @param {string=} autoscroll Whether `ngView` should call {@link ng.$anchorScroll
     *                  $anchorScroll} to scroll the viewport after the view is updated.
     *
     *                  - If the attribute is not set, disable scrolling.
     *                  - If the attribute is set without value, enable scrolling.
     *                  - Otherwise enable scrolling only if the `autoscroll` attribute value evaluated
     *                    as an expression yields a truthy value.
     * @example
        <example name="ngView-directive" module="ngViewExample"
                 deps="angular-route.js;angular-animate.js"
                 animations="true" fixBase="true">
          <file name="index.html">
            <div ng-controller="MainCtrl as main">
              Choose:
              <a href="Book/Moby">Moby</a> |
              <a href="Book/Moby/ch/1">Moby: Ch1</a> |
              <a href="Book/Gatsby">Gatsby</a> |
              <a href="Book/Gatsby/ch/4?key=value">Gatsby: Ch4</a> |
              <a href="Book/Scarlet">Scarlet Letter</a><br/>

              <div class="view-animate-container">
                <div ng-view class="view-animate"></div>
              </div>
              <hr />

              <pre>$location.path() = {{main.$location.path()}}</pre>
              <pre>$route.current.templateUrl = {{main.$route.current.templateUrl}}</pre>
              <pre>$route.current.params = {{main.$route.current.params}}</pre>
              <pre>$routeParams = {{main.$routeParams}}</pre>
            </div>
          </file>

          <file name="book.html">
            <div>
              controller: {{book.name}}<br />
              Book Id: {{book.params.bookId}}<br />
            </div>
          </file>

          <file name="chapter.html">
            <div>
              controller: {{chapter.name}}<br />
              Book Id: {{chapter.params.bookId}}<br />
              Chapter Id: {{chapter.params.chapterId}}
            </div>
          </file>

          <file name="animations.css">
            .view-animate-container {
              position:relative;
              height:100px!important;
              background:white;
              border:1px solid black;
              height:40px;
              overflow:hidden;
            }

            .view-animate {
              padding:10px;
            }

            .view-animate.ng-enter, .view-animate.ng-leave {
              -webkit-transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;
              transition:all cubic-bezier(0.250, 0.460, 0.450, 0.940) 1.5s;

              display:block;
              width:100%;
              border-left:1px solid black;

              position:absolute;
              top:0;
              left:0;
              right:0;
              bottom:0;
              padding:10px;
            }

            .view-animate.ng-enter {
              left:100%;
            }
            .view-animate.ng-enter.ng-enter-active {
              left:0;
            }
            .view-animate.ng-leave.ng-leave-active {
              left:-100%;
            }
          </file>

          <file name="script.js">
            angular.module('ngViewExample', ['ngRoute', 'ngAnimate'])
              .config(['$routeProvider', '$locationProvider',
                function($routeProvider, $locationProvider) {
                  $routeProvider
                    .when('/Book/:bookId', {
                      templateUrl: 'book.html',
                      controller: 'BookCtrl',
                      controllerAs: 'book'
                    })
                    .when('/Book/:bookId/ch/:chapterId', {
                      templateUrl: 'chapter.html',
                      controller: 'ChapterCtrl',
                      controllerAs: 'chapter'
                    });

                  $locationProvider.html5Mode(true);
              }])
              .controller('MainCtrl', ['$route', '$routeParams', '$location',
                function($route, $routeParams, $location) {
                  this.$route = $route;
                  this.$location = $location;
                  this.$routeParams = $routeParams;
              }])
              .controller('BookCtrl', ['$routeParams', function($routeParams) {
                this.name = "BookCtrl";
                this.params = $routeParams;
              }])
              .controller('ChapterCtrl', ['$routeParams', function($routeParams) {
                this.name = "ChapterCtrl";
                this.params = $routeParams;
              }]);

          </file>

          <file name="protractor.js" type="protractor">
            it('should load and compile correct template', function() {
              element(by.linkText('Moby: Ch1')).click();
              var content = element(by.css('[ng-view]')).getText();
              expect(content).toMatch(/controller\: ChapterCtrl/);
              expect(content).toMatch(/Book Id\: Moby/);
              expect(content).toMatch(/Chapter Id\: 1/);

              element(by.partialLinkText('Scarlet')).click();

              content = element(by.css('[ng-view]')).getText();
              expect(content).toMatch(/controller\: BookCtrl/);
              expect(content).toMatch(/Book Id\: Scarlet/);
            });
          </file>
        </example>
     */
    /**
     * @ngdoc event
     * @name ngView#$viewContentLoaded
     * @eventType emit on the current ngView scope
     * @description
     * Emitted every time the ngView content is reloaded.
     */
    ngViewFactory.$inject = [ '$route', '$anchorScroll', '$animate' ];

    function ngViewFactory( $route, $anchorScroll, $animate ) {
            return {
                restrict: 'ECA',
                terminal: true,
                priority: 400,
                transclude: 'element',
                link: function( scope, $element, attr, ctrl, $transclude ) {
                    var currentScope,
                        currentElement,
                        previousLeaveAnimation,
                        autoScrollExp = attr.autoscroll,
                        onloadExp = attr.onload || '';
                    scope.$on( '$routeChangeSuccess', update );
                    update();

                    function cleanupLastView() {
                        if ( previousLeaveAnimation ) {
                            $animate.cancel( previousLeaveAnimation );
                            previousLeaveAnimation = null;
                        }
                        if ( currentScope ) {
                            currentScope.$destroy();
                            currentScope = null;
                        }
                        if ( currentElement ) {
                            previousLeaveAnimation = $animate.leave( currentElement );
                            previousLeaveAnimation.then( function() {
                                previousLeaveAnimation = null;
                            } );
                            currentElement = null;
                        }
                    }

                    function update() {
                        var locals = $route.current && $route.current.locals,
                            template = locals && locals.$template;
                        if ( angular.isDefined( template ) ) {
                            var newScope = scope.$new();
                            var current = $route.current;
                            // Note: This will also link all children of ng-view that were contained in the original
                            // html. If that content contains controllers, ... they could pollute/change the scope.
                            // However, using ng-view on an element with additional content does not make sense...
                            // Note: We can't remove them in the cloneAttchFn of $transclude as that
                            // function is called before linking the content, which would apply child
                            // directives to non existing elements.
                            var clone = $transclude( newScope, function( clone ) {
                                $animate.enter( clone, null, currentElement || $element ).then( function onNgViewEnter() {
                                    if ( angular.isDefined( autoScrollExp ) && ( !autoScrollExp || scope.$eval( autoScrollExp ) ) ) {
                                        $anchorScroll();
                                    }
                                } );
                                cleanupLastView();
                            } );
                            currentElement = clone;
                            currentScope = current.scope = newScope;
                            currentScope.$emit( '$viewContentLoaded' );
                            currentScope.$eval( onloadExp );
                        } else {
                            cleanupLastView();
                        }
                    }
                }
            };
        }
        // This directive is called during the $transclude call of the first `ngView` directive.
        // It will replace and compile the content of the element with the loaded template.
        // We need this directive so that the element content is already filled when
        // the link function of another directive on the same element as ngView
        // is called.
    ngViewFillContentFactory.$inject = [ '$compile', '$controller', '$route' ];

    function ngViewFillContentFactory( $compile, $controller, $route ) {
        return {
            restrict: 'ECA',
            priority: -400,
            link: function( scope, $element ) {
                var current = $route.current,
                    locals = current.locals;
                $element.html( locals.$template );
                var link = $compile( $element.contents() );
                if ( current.controller ) {
                    locals.$scope = scope;
                    var controller = $controller( current.controller, locals );
                    if ( current.controllerAs ) {
                        scope[ current.controllerAs ] = controller;
                    }
                    $element.data( '$ngControllerController', controller );
                    $element.children().data( '$ngControllerController', controller );
                }
                link( scope );
            }
        };
    }
} )( window, window.angular );
/**
 * @license AngularJS v1.3.7
 * (c) 2010-2014 Google, Inc. http://angularjs.org
 * License: MIT
 */
( function( window, angular, undefined ) {
    'use strict';
    var $sanitizeMinErr = angular.$$minErr( '$sanitize' );
    /**
     * @ngdoc module
     * @name ngSanitize
     * @description
     *
     * # ngSanitize
     *
     * The `ngSanitize` module provides functionality to sanitize HTML.
     *
     *
     * <div doc-module-components="ngSanitize"></div>
     *
     * See {@link ngSanitize.$sanitize `$sanitize`} for usage.
     */
    /*
     * HTML Parser By Misko Hevery (misko@hevery.com)
     * based on:  HTML Parser By John Resig (ejohn.org)
     * Original code by Erik Arvidsson, Mozilla Public License
     * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
     *
     * // Use like so:
     * htmlParser(htmlString, {
     *     start: function(tag, attrs, unary) {},
     *     end: function(tag) {},
     *     chars: function(text) {},
     *     comment: function(text) {}
     * });
     *
     */
    /**
     * @ngdoc service
     * @name $sanitize
     * @kind function
     *
     * @description
     *   The input is sanitized by parsing the HTML into tokens. All safe tokens (from a whitelist) are
     *   then serialized back to properly escaped html string. This means that no unsafe input can make
     *   it into the returned string, however, since our parser is more strict than a typical browser
     *   parser, it's possible that some obscure input, which would be recognized as valid HTML by a
     *   browser, won't make it through the sanitizer. The input may also contain SVG markup.
     *   The whitelist is configured using the functions `aHrefSanitizationWhitelist` and
     *   `imgSrcSanitizationWhitelist` of {@link ng.$compileProvider `$compileProvider`}.
     *
     * @param {string} html HTML input.
     * @returns {string} Sanitized HTML.
     *
     * @example
       <example module="sanitizeExample" deps="angular-sanitize.js">
       <file name="index.html">
         <script>
             angular.module('sanitizeExample', ['ngSanitize'])
               .controller('ExampleController', ['$scope', '$sce', function($scope, $sce) {
                 $scope.snippet =
                   '<p style="color:blue">an html\n' +
                   '<em onmouseover="this.textContent=\'PWN3D!\'">click here</em>\n' +
                   'snippet</p>';
                 $scope.deliberatelyTrustDangerousSnippet = function() {
                   return $sce.trustAsHtml($scope.snippet);
                 };
               }]);
         </script>
         <div ng-controller="ExampleController">
            Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
           <table>
             <tr>
               <td>Directive</td>
               <td>How</td>
               <td>Source</td>
               <td>Rendered</td>
             </tr>
             <tr id="bind-html-with-sanitize">
               <td>ng-bind-html</td>
               <td>Automatically uses $sanitize</td>
               <td><pre>&lt;div ng-bind-html="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
               <td><div ng-bind-html="snippet"></div></td>
             </tr>
             <tr id="bind-html-with-trust">
               <td>ng-bind-html</td>
               <td>Bypass $sanitize by explicitly trusting the dangerous value</td>
               <td>
               <pre>&lt;div ng-bind-html="deliberatelyTrustDangerousSnippet()"&gt;
    &lt;/div&gt;</pre>
               </td>
               <td><div ng-bind-html="deliberatelyTrustDangerousSnippet()"></div></td>
             </tr>
             <tr id="bind-default">
               <td>ng-bind</td>
               <td>Automatically escapes</td>
               <td><pre>&lt;div ng-bind="snippet"&gt;<br/>&lt;/div&gt;</pre></td>
               <td><div ng-bind="snippet"></div></td>
             </tr>
           </table>
           </div>
       </file>
       <file name="protractor.js" type="protractor">
         it('should sanitize the html snippet by default', function() {
           expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).
             toBe('<p>an html\n<em>click here</em>\nsnippet</p>');
         });

         it('should inline raw snippet if bound to a trusted value', function() {
           expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).
             toBe("<p style=\"color:blue\">an html\n" +
                  "<em onmouseover=\"this.textContent='PWN3D!'\">click here</em>\n" +
                  "snippet</p>");
         });

         it('should escape snippet without any filter', function() {
           expect(element(by.css('#bind-default div')).getInnerHtml()).
             toBe("&lt;p style=\"color:blue\"&gt;an html\n" +
                  "&lt;em onmouseover=\"this.textContent='PWN3D!'\"&gt;click here&lt;/em&gt;\n" +
                  "snippet&lt;/p&gt;");
         });

         it('should update', function() {
           element(by.model('snippet')).clear();
           element(by.model('snippet')).sendKeys('new <b onclick="alert(1)">text</b>');
           expect(element(by.css('#bind-html-with-sanitize div')).getInnerHtml()).
             toBe('new <b>text</b>');
           expect(element(by.css('#bind-html-with-trust div')).getInnerHtml()).toBe(
             'new <b onclick="alert(1)">text</b>');
           expect(element(by.css('#bind-default div')).getInnerHtml()).toBe(
             "new &lt;b onclick=\"alert(1)\"&gt;text&lt;/b&gt;");
         });
       </file>
       </example>
     */
    function $SanitizeProvider() {
        this.$get = [ '$$sanitizeUri', function( $$sanitizeUri ) {
            return function( html ) {
                var buf = [];
                htmlParser( html, htmlSanitizeWriter( buf, function( uri, isImage ) {
                    return !/^unsafe/.test( $$sanitizeUri( uri, isImage ) );
                } ) );
                return buf.join( '' );
            };
  } ];
    }

    function sanitizeText( chars ) {
            var buf = [];
            var writer = htmlSanitizeWriter( buf, angular.noop );
            writer.chars( chars );
            return buf.join( '' );
        }
        // Regular Expressions for parsing tags and attributes
    var START_TAG_REGEXP = /^<((?:[a-zA-Z])[\w:-]*)((?:\s+[\w:-]+(?:\s*=\s*(?:(?:"[^"]*")|(?:'[^']*')|[^>\s]+))?)*)\s*(\/?)\s*(>?)/,
        END_TAG_REGEXP = /^<\/\s*([\w:-]+)[^>]*>/,
        ATTR_REGEXP = /([\w:-]+)(?:\s*=\s*(?:(?:"((?:[^"])*)")|(?:'((?:[^'])*)')|([^>\s]+)))?/g,
        BEGIN_TAG_REGEXP = /^</,
        BEGING_END_TAGE_REGEXP = /^<\//,
        COMMENT_REGEXP = /<!--(.*?)-->/g,
        DOCTYPE_REGEXP = /<!DOCTYPE([^>]*?)>/i,
        CDATA_REGEXP = /<!\[CDATA\[(.*?)]]>/g,
        SURROGATE_PAIR_REGEXP = /[\uD800-\uDBFF][\uDC00-\uDFFF]/g,
        // Match everything outside of normal chars and " (quote character)
        NON_ALPHANUMERIC_REGEXP = /([^\#-~| |!])/g;
    // Good source of info about elements and attributes
    // http://dev.w3.org/html5/spec/Overview.html#semantics
    // http://simon.html5.org/html-elements
    // Safe Void Elements - HTML5
    // http://dev.w3.org/html5/spec/Overview.html#void-elements
    var voidElements = makeMap( "area,br,col,hr,img,wbr" );
    // Elements that you can, intentionally, leave open (and which close themselves)
    // http://dev.w3.org/html5/spec/Overview.html#optional-tags
    var optionalEndTagBlockElements = makeMap( "colgroup,dd,dt,li,p,tbody,td,tfoot,th,thead,tr" ),
        optionalEndTagInlineElements = makeMap( "rp,rt" ),
        optionalEndTagElements = angular.extend( {}, optionalEndTagInlineElements, optionalEndTagBlockElements );
    // Safe Block Elements - HTML5
    var blockElements = angular.extend( {}, optionalEndTagBlockElements, makeMap( "address,article," + "aside,blockquote,caption,center,del,dir,div,dl,figure,figcaption,footer,h1,h2,h3,h4,h5," + "h6,header,hgroup,hr,ins,map,menu,nav,ol,pre,script,section,table,ul" ) );
    // Inline Elements - HTML5
    var inlineElements = angular.extend( {}, optionalEndTagInlineElements, makeMap( "a,abbr,acronym,b," + "bdi,bdo,big,br,cite,code,del,dfn,em,font,i,img,ins,kbd,label,map,mark,q,ruby,rp,rt,s," + "samp,small,span,strike,strong,sub,sup,time,tt,u,var" ) );
    // SVG Elements
    // https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Elements
    var svgElements = makeMap( "animate,animateColor,animateMotion,animateTransform,circle,defs," + "desc,ellipse,font-face,font-face-name,font-face-src,g,glyph,hkern,image,linearGradient," + "line,marker,metadata,missing-glyph,mpath,path,polygon,polyline,radialGradient,rect,set," + "stop,svg,switch,text,title,tspan,use" );
    // Special Elements (can contain anything)
    var specialElements = makeMap( "script,style" );
    var validElements = angular.extend( {}, voidElements, blockElements, inlineElements, optionalEndTagElements, svgElements );
    //Attributes that have href and hence need to be sanitized
    var uriAttrs = makeMap( "background,cite,href,longdesc,src,usemap,xlink:href" );
    var htmlAttrs = makeMap( 'abbr,align,alt,axis,bgcolor,border,cellpadding,cellspacing,class,clear,' + 'color,cols,colspan,compact,coords,dir,face,headers,height,hreflang,hspace,' + 'ismap,lang,language,nohref,nowrap,rel,rev,rows,rowspan,rules,' + 'scope,scrolling,shape,size,span,start,summary,target,title,type,' + 'valign,value,vspace,width' );
    // SVG attributes (without "id" and "name" attributes)
    // https://wiki.whatwg.org/wiki/Sanitization_rules#svg_Attributes
    var svgAttrs = makeMap( 'accent-height,accumulate,additive,alphabetic,arabic-form,ascent,' + 'attributeName,attributeType,baseProfile,bbox,begin,by,calcMode,cap-height,class,color,' + 'color-rendering,content,cx,cy,d,dx,dy,descent,display,dur,end,fill,fill-rule,font-family,' + 'font-size,font-stretch,font-style,font-variant,font-weight,from,fx,fy,g1,g2,glyph-name,' + 'gradientUnits,hanging,height,horiz-adv-x,horiz-origin-x,ideographic,k,keyPoints,' + 'keySplines,keyTimes,lang,marker-end,marker-mid,marker-start,markerHeight,markerUnits,' + 'markerWidth,mathematical,max,min,offset,opacity,orient,origin,overline-position,' + 'overline-thickness,panose-1,path,pathLength,points,preserveAspectRatio,r,refX,refY,' + 'repeatCount,repeatDur,requiredExtensions,requiredFeatures,restart,rotate,rx,ry,slope,stemh,' + 'stemv,stop-color,stop-opacity,strikethrough-position,strikethrough-thickness,stroke,' + 'stroke-dasharray,stroke-dashoffset,stroke-linecap,stroke-linejoin,stroke-miterlimit,' + 'stroke-opacity,stroke-width,systemLanguage,target,text-anchor,to,transform,type,u1,u2,' + 'underline-position,underline-thickness,unicode,unicode-range,units-per-em,values,version,' + 'viewBox,visibility,width,widths,x,x-height,x1,x2,xlink:actuate,xlink:arcrole,xlink:role,' + 'xlink:show,xlink:title,xlink:type,xml:base,xml:lang,xml:space,xmlns,xmlns:xlink,y,y1,y2,' + 'zoomAndPan' );
    var validAttrs = angular.extend( {}, uriAttrs, svgAttrs, htmlAttrs );

    function makeMap( str ) {
            var obj = {},
                items = str.split( ',' ),
                i;
            for ( i = 0; i < items.length; i++ ) obj[ items[ i ] ] = true;
            return obj;
        }
        /**
         * @example
         * htmlParser(htmlString, {
         *     start: function(tag, attrs, unary) {},
         *     end: function(tag) {},
         *     chars: function(text) {},
         *     comment: function(text) {}
         * });
         *
         * @param {string} html string
         * @param {object} handler
         */
    function htmlParser( html, handler ) {
        if ( typeof html !== 'string' ) {
            if ( html === null || typeof html === 'undefined' ) {
                html = '';
            } else {
                html = '' + html;
            }
        }
        var index, chars, match, stack = [],
            last = html,
            text;
        stack.last = function() {
            return stack[ stack.length - 1 ];
        };
        while ( html ) {
            text = '';
            chars = true;
            // Make sure we're not in a script or style element
            if ( !stack.last() || !specialElements[ stack.last() ] ) {
                // Comment
                if ( html.indexOf( "<!--" ) === 0 ) {
                    // comments containing -- are not allowed unless they terminate the comment
                    index = html.indexOf( "--", 4 );
                    if ( index >= 0 && html.lastIndexOf( "-->", index ) === index ) {
                        if ( handler.comment ) handler.comment( html.substring( 4, index ) );
                        html = html.substring( index + 3 );
                        chars = false;
                    }
                    // DOCTYPE
                } else if ( DOCTYPE_REGEXP.test( html ) ) {
                    match = html.match( DOCTYPE_REGEXP );
                    if ( match ) {
                        html = html.replace( match[ 0 ], '' );
                        chars = false;
                    }
                    // end tag
                } else if ( BEGING_END_TAGE_REGEXP.test( html ) ) {
                    match = html.match( END_TAG_REGEXP );
                    if ( match ) {
                        html = html.substring( match[ 0 ].length );
                        match[ 0 ].replace( END_TAG_REGEXP, parseEndTag );
                        chars = false;
                    }
                    // start tag
                } else if ( BEGIN_TAG_REGEXP.test( html ) ) {
                    match = html.match( START_TAG_REGEXP );
                    if ( match ) {
                        // We only have a valid start-tag if there is a '>'.
                        if ( match[ 4 ] ) {
                            html = html.substring( match[ 0 ].length );
                            match[ 0 ].replace( START_TAG_REGEXP, parseStartTag );
                        }
                        chars = false;
                    } else {
                        // no ending tag found --- this piece should be encoded as an entity.
                        text += '<';
                        html = html.substring( 1 );
                    }
                }
                if ( chars ) {
                    index = html.indexOf( "<" );
                    text += index < 0 ? html : html.substring( 0, index );
                    html = index < 0 ? "" : html.substring( index );
                    if ( handler.chars ) handler.chars( decodeEntities( text ) );
                }
            } else {
                html = html.replace( new RegExp( "(.*)<\\s*\\/\\s*" + stack.last() + "[^>]*>", 'i' ), function( all, text ) {
                    text = text.replace( COMMENT_REGEXP, "$1" ).replace( CDATA_REGEXP, "$1" );
                    if ( handler.chars ) handler.chars( decodeEntities( text ) );
                    return "";
                } );
                parseEndTag( "", stack.last() );
            }
            if ( html == last ) {
                throw $sanitizeMinErr( 'badparse', "The sanitizer was unable to parse the following block " + "of html: {0}", html );
            }
            last = html;
        }
        // Clean up any remaining tags
        parseEndTag();

        function parseStartTag( tag, tagName, rest, unary ) {
            tagName = angular.lowercase( tagName );
            if ( blockElements[ tagName ] ) {
                while ( stack.last() && inlineElements[ stack.last() ] ) {
                    parseEndTag( "", stack.last() );
                }
            }
            if ( optionalEndTagElements[ tagName ] && stack.last() == tagName ) {
                parseEndTag( "", tagName );
            }
            unary = voidElements[ tagName ] || !!unary;
            if ( !unary ) stack.push( tagName );
            var attrs = {};
            rest.replace( ATTR_REGEXP, function( match, name, doubleQuotedValue, singleQuotedValue, unquotedValue ) {
                var value = doubleQuotedValue || singleQuotedValue || unquotedValue || '';
                attrs[ name ] = decodeEntities( value );
            } );
            if ( handler.start ) handler.start( tagName, attrs, unary );
        }

        function parseEndTag( tag, tagName ) {
            var pos = 0,
                i;
            tagName = angular.lowercase( tagName );
            if ( tagName )
            // Find the closest opened tag of the same type
                for ( pos = stack.length - 1; pos >= 0; pos-- )
                if ( stack[ pos ] == tagName ) break;
            if ( pos >= 0 ) {
                // Close all the open elements, up the stack
                for ( i = stack.length - 1; i >= pos; i-- )
                    if ( handler.end ) handler.end( stack[ i ] );
                    // Remove the open elements from the stack
                stack.length = pos;
            }
        }
    }
    var hiddenPre = document.createElement( "pre" );
    var spaceRe = /^(\s*)([\s\S]*?)(\s*)$/;
    /**
     * decodes all entities into regular string
     * @param value
     * @returns {string} A string with decoded entities.
     */
    function decodeEntities( value ) {
            if ( !value ) {
                return '';
            }
            // Note: IE8 does not preserve spaces at the start/end of innerHTML
            // so we must capture them and reattach them afterward
            var parts = spaceRe.exec( value );
            var spaceBefore = parts[ 1 ];
            var spaceAfter = parts[ 3 ];
            var content = parts[ 2 ];
            if ( content ) {
                hiddenPre.innerHTML = content.replace( /</g, "&lt;" );
                // innerText depends on styling as it doesn't display hidden elements.
                // Therefore, it's better to use textContent not to cause unnecessary
                // reflows. However, IE<9 don't support textContent so the innerText
                // fallback is necessary.
                content = 'textContent' in hiddenPre ? hiddenPre.textContent : hiddenPre.innerText;
            }
            return spaceBefore + content + spaceAfter;
        }
        /**
         * Escapes all potentially dangerous characters, so that the
         * resulting string can be safely inserted into attribute or
         * element text.
         * @param value
         * @returns {string} escaped text
         */
    function encodeEntities( value ) {
            return value.
            replace( /&/g, '&amp;' ).
            replace( SURROGATE_PAIR_REGEXP, function( value ) {
                var hi = value.charCodeAt( 0 );
                var low = value.charCodeAt( 1 );
                return '&#' + ( ( ( hi - 0xD800 ) * 0x400 ) + ( low - 0xDC00 ) + 0x10000 ) + ';';
            } ).
            replace( NON_ALPHANUMERIC_REGEXP, function( value ) {
                return '&#' + value.charCodeAt( 0 ) + ';';
            } ).
            replace( /</g, '&lt;' ).
            replace( />/g, '&gt;' );
        }
        /**
         * create an HTML/XML writer which writes to buffer
         * @param {Array} buf use buf.jain('') to get out sanitized html string
         * @returns {object} in the form of {
         *     start: function(tag, attrs, unary) {},
         *     end: function(tag) {},
         *     chars: function(text) {},
         *     comment: function(text) {}
         * }
         */
    function htmlSanitizeWriter( buf, uriValidator ) {
            var ignore = false;
            var out = angular.bind( buf, buf.push );
            return {
                start: function( tag, attrs, unary ) {
                    tag = angular.lowercase( tag );
                    if ( !ignore && specialElements[ tag ] ) {
                        ignore = tag;
                    }
                    if ( !ignore && validElements[ tag ] === true ) {
                        out( '<' );
                        out( tag );
                        angular.forEach( attrs, function( value, key ) {
                            var lkey = angular.lowercase( key );
                            var isImage = ( tag === 'img' && lkey === 'src' ) || ( lkey === 'background' );
                            if ( validAttrs[ lkey ] === true && ( uriAttrs[ lkey ] !== true || uriValidator( value, isImage ) ) ) {
                                out( ' ' );
                                out( key );
                                out( '="' );
                                out( encodeEntities( value ) );
                                out( '"' );
                            }
                        } );
                        out( unary ? '/>' : '>' );
                    }
                },
                end: function( tag ) {
                    tag = angular.lowercase( tag );
                    if ( !ignore && validElements[ tag ] === true ) {
                        out( '</' );
                        out( tag );
                        out( '>' );
                    }
                    if ( tag == ignore ) {
                        ignore = false;
                    }
                },
                chars: function( chars ) {
                    if ( !ignore ) {
                        out( encodeEntities( chars ) );
                    }
                }
            };
        }
        // define ngSanitize module and register $sanitize service
    angular.module( 'ngSanitize', [] ).provider( '$sanitize', $SanitizeProvider );
    /* global sanitizeText: false */
    /**
     * @ngdoc filter
     * @name linky
     * @kind function
     *
     * @description
     * Finds links in text input and turns them into html links. Supports http/https/ftp/mailto and
     * plain email address links.
     *
     * Requires the {@link ngSanitize `ngSanitize`} module to be installed.
     *
     * @param {string} text Input text.
     * @param {string} target Window (_blank|_self|_parent|_top) or named frame to open links in.
     * @returns {string} Html-linkified text.
     *
     * @usage
       <span ng-bind-html="linky_expression | linky"></span>
     *
     * @example
       <example module="linkyExample" deps="angular-sanitize.js">
         <file name="index.html">
           <script>
             angular.module('linkyExample', ['ngSanitize'])
               .controller('ExampleController', ['$scope', function($scope) {
                 $scope.snippet =
                   'Pretty text with some links:\n'+
                   'http://angularjs.org/,\n'+
                   'mailto:us@somewhere.org,\n'+
                   'another@somewhere.org,\n'+
                   'and one more: ftp://127.0.0.1/.';
                 $scope.snippetWithTarget = 'http://angularjs.org/';
               }]);
           </script>
           <div ng-controller="ExampleController">
           Snippet: <textarea ng-model="snippet" cols="60" rows="3"></textarea>
           <table>
             <tr>
               <td>Filter</td>
               <td>Source</td>
               <td>Rendered</td>
             </tr>
             <tr id="linky-filter">
               <td>linky filter</td>
               <td>
                 <pre>&lt;div ng-bind-html="snippet | linky"&gt;<br>&lt;/div&gt;</pre>
               </td>
               <td>
                 <div ng-bind-html="snippet | linky"></div>
               </td>
             </tr>
             <tr id="linky-target">
              <td>linky target</td>
              <td>
                <pre>&lt;div ng-bind-html="snippetWithTarget | linky:'_blank'"&gt;<br>&lt;/div&gt;</pre>
              </td>
              <td>
                <div ng-bind-html="snippetWithTarget | linky:'_blank'"></div>
              </td>
             </tr>
             <tr id="escaped-html">
               <td>no filter</td>
               <td><pre>&lt;div ng-bind="snippet"&gt;<br>&lt;/div&gt;</pre></td>
               <td><div ng-bind="snippet"></div></td>
             </tr>
           </table>
         </file>
         <file name="protractor.js" type="protractor">
           it('should linkify the snippet with urls', function() {
             expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
                 toBe('Pretty text with some links: http://angularjs.org/, us@somewhere.org, ' +
                      'another@somewhere.org, and one more: ftp://127.0.0.1/.');
             expect(element.all(by.css('#linky-filter a')).count()).toEqual(4);
           });

           it('should not linkify snippet without the linky filter', function() {
             expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText()).
                 toBe('Pretty text with some links: http://angularjs.org/, mailto:us@somewhere.org, ' +
                      'another@somewhere.org, and one more: ftp://127.0.0.1/.');
             expect(element.all(by.css('#escaped-html a')).count()).toEqual(0);
           });

           it('should update', function() {
             element(by.model('snippet')).clear();
             element(by.model('snippet')).sendKeys('new http://link.');
             expect(element(by.id('linky-filter')).element(by.binding('snippet | linky')).getText()).
                 toBe('new http://link.');
             expect(element.all(by.css('#linky-filter a')).count()).toEqual(1);
             expect(element(by.id('escaped-html')).element(by.binding('snippet')).getText())
                 .toBe('new http://link.');
           });

           it('should work with the target property', function() {
            expect(element(by.id('linky-target')).
                element(by.binding("snippetWithTarget | linky:'_blank'")).getText()).
                toBe('http://angularjs.org/');
            expect(element(by.css('#linky-target a')).getAttribute('target')).toEqual('_blank');
           });
         </file>
       </example>
     */
    angular.module( 'ngSanitize' ).filter( 'linky', [ '$sanitize', function( $sanitize ) {
        var LINKY_URL_REGEXP = /((ftp|https?):\/\/|(www\.)|(mailto:)?[A-Za-z0-9._%+-]+@)\S*[^\s.;,(){}<>"]/,
            MAILTO_REGEXP = /^mailto:/;
        return function( text, target ) {
            if ( !text ) return text;
            var match;
            var raw = text;
            var html = [];
            var url;
            var i;
            while ( ( match = raw.match( LINKY_URL_REGEXP ) ) ) {
                // We can not end in these as they are sometimes found at the end of the sentence
                url = match[ 0 ];
                // if we did not match ftp/http/www/mailto then assume mailto
                if ( !match[ 2 ] && !match[ 4 ] ) {
                    url = ( match[ 3 ] ? 'http://' : 'mailto:' ) + url;
                }
                i = match.index;
                addText( raw.substr( 0, i ) );
                addLink( url, match[ 0 ].replace( MAILTO_REGEXP, '' ) );
                raw = raw.substring( i + match[ 0 ].length );
            }
            addText( raw );
            return $sanitize( html.join( '' ) );

            function addText( text ) {
                if ( !text ) {
                    return;
                }
                html.push( sanitizeText( text ) );
            }

            function addLink( url, text ) {
                html.push( '<a ' );
                if ( angular.isDefined( target ) ) {
                    html.push( 'target="', target, '" ' );
                }
                html.push( 'href="', url.replace( /"/g, '&quot;' ), '">' );
                addText( text );
                html.push( '</a>' );
            }
        };
} ] );
} )( window, window.angular );
/**
 * @license AngularJS v1.3.7
 * (c) 2010-2014 Google, Inc. http://angularjs.org
 * License: MIT
 */
( function( window, angular, undefined ) {
    'use strict';
    /**
     * @ngdoc module
     * @name ngTouch
     * @description
     *
     * # ngTouch
     *
     * The `ngTouch` module provides touch events and other helpers for touch-enabled devices.
     * The implementation is based on jQuery Mobile touch event handling
     * ([jquerymobile.com](http://jquerymobile.com/)).
     *
     *
     * See {@link ngTouch.$swipe `$swipe`} for usage.
     *
     * <div doc-module-components="ngTouch"></div>
     *
     */
    // define ngTouch module
    /* global -ngTouch */
    var ngTouch = angular.module( 'ngTouch', [] );
    /* global ngTouch: false */
    /**
     * @ngdoc service
     * @name $swipe
     *
     * @description
     * The `$swipe` service is a service that abstracts the messier details of hold-and-drag swipe
     * behavior, to make implementing swipe-related directives more convenient.
     *
     * Requires the {@link ngTouch `ngTouch`} module to be installed.
     *
     * `$swipe` is used by the `ngSwipeLeft` and `ngSwipeRight` directives in `ngTouch`, and by
     * `ngCarousel` in a separate component.
     *
     * # Usage
     * The `$swipe` service is an object with a single method: `bind`. `bind` takes an element
     * which is to be watched for swipes, and an object with four handler functions. See the
     * documentation for `bind` below.
     */
    ngTouch.factory( '$swipe', [ function() {
        // The total distance in any direction before we make the call on swipe vs. scroll.
        var MOVE_BUFFER_RADIUS = 10;
        var POINTER_EVENTS = {
            'mouse': {
                start: 'mousedown',
                move: 'mousemove',
                end: 'mouseup'
            },
            'touch': {
                start: 'touchstart',
                move: 'touchmove',
                end: 'touchend',
                cancel: 'touchcancel'
            }
        };

        function getCoordinates( event ) {
            var touches = event.touches && event.touches.length ? event.touches : [ event ];
            var e = ( event.changedTouches && event.changedTouches[ 0 ] ) || ( event.originalEvent && event.originalEvent.changedTouches && event.originalEvent.changedTouches[ 0 ] ) || touches[ 0 ].originalEvent || touches[ 0 ];
            return {
                x: e.clientX,
                y: e.clientY
            };
        }

        function getEvents( pointerTypes, eventType ) {
            var res = [];
            angular.forEach( pointerTypes, function( pointerType ) {
                var eventName = POINTER_EVENTS[ pointerType ][ eventType ];
                if ( eventName ) {
                    res.push( eventName );
                }
            } );
            return res.join( ' ' );
        }
        return {
            /**
             * @ngdoc method
             * @name $swipe#bind
             *
             * @description
             * The main method of `$swipe`. It takes an element to be watched for swipe motions, and an
             * object containing event handlers.
             * The pointer types that should be used can be specified via the optional
             * third argument, which is an array of strings `'mouse'` and `'touch'`. By default,
             * `$swipe` will listen for `mouse` and `touch` events.
             *
             * The four events are `start`, `move`, `end`, and `cancel`. `start`, `move`, and `end`
             * receive as a parameter a coordinates object of the form `{ x: 150, y: 310 }`.
             *
             * `start` is called on either `mousedown` or `touchstart`. After this event, `$swipe` is
             * watching for `touchmove` or `mousemove` events. These events are ignored until the total
             * distance moved in either dimension exceeds a small threshold.
             *
             * Once this threshold is exceeded, either the horizontal or vertical delta is greater.
             * - If the horizontal distance is greater, this is a swipe and `move` and `end` events follow.
             * - If the vertical distance is greater, this is a scroll, and we let the browser take over.
             *   A `cancel` event is sent.
             *
             * `move` is called on `mousemove` and `touchmove` after the above logic has determined that
             * a swipe is in progress.
             *
             * `end` is called when a swipe is successfully completed with a `touchend` or `mouseup`.
             *
             * `cancel` is called either on a `touchcancel` from the browser, or when we begin scrolling
             * as described above.
             *
             */
            bind: function( element, eventHandlers, pointerTypes ) {
                // Absolute total movement, used to control swipe vs. scroll.
                var totalX, totalY;
                // Coordinates of the start position.
                var startCoords;
                // Last event's position.
                var lastPos;
                // Whether a swipe is active.
                var active = false;
                pointerTypes = pointerTypes || [ 'mouse', 'touch' ];
                element.on( getEvents( pointerTypes, 'start' ), function( event ) {
                    startCoords = getCoordinates( event );
                    active = true;
                    totalX = 0;
                    totalY = 0;
                    lastPos = startCoords;
                    eventHandlers[ 'start' ] && eventHandlers[ 'start' ]( startCoords, event );
                } );
                var events = getEvents( pointerTypes, 'cancel' );
                if ( events ) {
                    element.on( events, function( event ) {
                        active = false;
                        eventHandlers[ 'cancel' ] && eventHandlers[ 'cancel' ]( event );
                    } );
                }
                element.on( getEvents( pointerTypes, 'move' ), function( event ) {
                    if ( !active ) return;
                    // Android will send a touchcancel if it thinks we're starting to scroll.
                    // So when the total distance (+ or - or both) exceeds 10px in either direction,
                    // we either:
                    // - On totalX > totalY, we send preventDefault() and treat this as a swipe.
                    // - On totalY > totalX, we let the browser handle it as a scroll.
                    if ( !startCoords ) return;
                    var coords = getCoordinates( event );
                    totalX += Math.abs( coords.x - lastPos.x );
                    totalY += Math.abs( coords.y - lastPos.y );
                    lastPos = coords;
                    if ( totalX < MOVE_BUFFER_RADIUS && totalY < MOVE_BUFFER_RADIUS ) {
                        return;
                    }
                    // One of totalX or totalY has exceeded the buffer, so decide on swipe vs. scroll.
                    if ( totalY > totalX ) {
                        // Allow native scrolling to take over.
                        active = false;
                        eventHandlers[ 'cancel' ] && eventHandlers[ 'cancel' ]( event );
                        return;
                    } else {
                        // Prevent the browser from scrolling.
                        event.preventDefault();
                        eventHandlers[ 'move' ] && eventHandlers[ 'move' ]( coords, event );
                    }
                } );
                element.on( getEvents( pointerTypes, 'end' ), function( event ) {
                    if ( !active ) return;
                    active = false;
                    eventHandlers[ 'end' ] && eventHandlers[ 'end' ]( getCoordinates( event ), event );
                } );
            }
        };
} ] );
    /* global ngTouch: false */
    /**
     * @ngdoc directive
     * @name ngClick
     *
     * @description
     * A more powerful replacement for the default ngClick designed to be used on touchscreen
     * devices. Most mobile browsers wait about 300ms after a tap-and-release before sending
     * the click event. This version handles them immediately, and then prevents the
     * following click event from propagating.
     *
     * Requires the {@link ngTouch `ngTouch`} module to be installed.
     *
     * This directive can fall back to using an ordinary click event, and so works on desktop
     * browsers as well as mobile.
     *
     * This directive also sets the CSS class `ng-click-active` while the element is being held
     * down (by a mouse click or touch) so you can restyle the depressed element if you wish.
     *
     * @element ANY
     * @param {expression} ngClick {@link guide/expression Expression} to evaluate
     * upon tap. (Event object is available as `$event`)
     *
     * @example
        <example module="ngClickExample" deps="angular-touch.js">
          <file name="index.html">
            <button ng-click="count = count + 1" ng-init="count=0">
              Increment
            </button>
            count: {{ count }}
          </file>
          <file name="script.js">
            angular.module('ngClickExample', ['ngTouch']);
          </file>
        </example>
     */
    ngTouch.config( [ '$provide', function( $provide ) {
        $provide.decorator( 'ngClickDirective', [ '$delegate', function( $delegate ) {
            // drop the default ngClick directive
            $delegate.shift();
            return $delegate;
  } ] );
} ] );
    ngTouch.directive( 'ngClick', [ '$parse', '$timeout', '$rootElement',
    function( $parse, $timeout, $rootElement ) {
            var TAP_DURATION = 750; // Shorter than 750ms is a tap, longer is a taphold or drag.
            var MOVE_TOLERANCE = 12; // 12px seems to work in most mobile browsers.
            var PREVENT_DURATION = 2500; // 2.5 seconds maximum from preventGhostClick call to click
            var CLICKBUSTER_THRESHOLD = 25; // 25 pixels in any dimension is the limit for busting clicks.
            var ACTIVE_CLASS_NAME = 'ng-click-active';
            var lastPreventedTime;
            var touchCoordinates;
            var lastLabelClickCoordinates;
            // TAP EVENTS AND GHOST CLICKS
            //
            // Why tap events?
            // Mobile browsers detect a tap, then wait a moment (usually ~300ms) to see if you're
            // double-tapping, and then fire a click event.
            //
            // This delay sucks and makes mobile apps feel unresponsive.
            // So we detect touchstart, touchmove, touchcancel and touchend ourselves and determine when
            // the user has tapped on something.
            //
            // What happens when the browser then generates a click event?
            // The browser, of course, also detects the tap and fires a click after a delay. This results in
            // tapping/clicking twice. We do "clickbusting" to prevent it.
            //
            // How does it work?
            // We attach global touchstart and click handlers, that run during the capture (early) phase.
            // So the sequence for a tap is:
            // - global touchstart: Sets an "allowable region" at the point touched.
            // - element's touchstart: Starts a touch
            // (- touchmove or touchcancel ends the touch, no click follows)
            // - element's touchend: Determines if the tap is valid (didn't move too far away, didn't hold
            //   too long) and fires the user's tap handler. The touchend also calls preventGhostClick().
            // - preventGhostClick() removes the allowable region the global touchstart created.
            // - The browser generates a click event.
            // - The global click handler catches the click, and checks whether it was in an allowable region.
            //     - If preventGhostClick was called, the region will have been removed, the click is busted.
            //     - If the region is still there, the click proceeds normally. Therefore clicks on links and
            //       other elements without ngTap on them work normally.
            //
            // This is an ugly, terrible hack!
            // Yeah, tell me about it. The alternatives are using the slow click events, or making our users
            // deal with the ghost clicks, so I consider this the least of evils. Fortunately Angular
            // encapsulates this ugly logic away from the user.
            //
            // Why not just put click handlers on the element?
            // We do that too, just to be sure. If the tap event caused the DOM to change,
            // it is possible another element is now in that position. To take account for these possibly
            // distinct elements, the handlers are global and care only about coordinates.
            // Checks if the coordinates are close enough to be within the region.
            function hit( x1, y1, x2, y2 ) {
                    return Math.abs( x1 - x2 ) < CLICKBUSTER_THRESHOLD && Math.abs( y1 - y2 ) < CLICKBUSTER_THRESHOLD;
                }
                // Checks a list of allowable regions against a click location.
                // Returns true if the click should be allowed.
                // Splices out the allowable region from the list after it has been used.
            function checkAllowableRegions( touchCoordinates, x, y ) {
                    for ( var i = 0; i < touchCoordinates.length; i += 2 ) {
                        if ( hit( touchCoordinates[ i ], touchCoordinates[ i + 1 ], x, y ) ) {
                            touchCoordinates.splice( i, i + 2 );
                            return true; // allowable region
                        }
                    }
                    return false; // No allowable region; bust it.
                }
                // Global click handler that prevents the click if it's in a bustable zone and preventGhostClick
                // was called recently.
            function onClick( event ) {
                    if ( Date.now() - lastPreventedTime > PREVENT_DURATION ) {
                        return; // Too old.
                    }
                    var touches = event.touches && event.touches.length ? event.touches : [ event ];
                    var x = touches[ 0 ].clientX;
                    var y = touches[ 0 ].clientY;
                    // Work around desktop Webkit quirk where clicking a label will fire two clicks (on the label
                    // and on the input element). Depending on the exact browser, this second click we don't want
                    // to bust has either (0,0), negative coordinates, or coordinates equal to triggering label
                    // click event
                    if ( x < 1 && y < 1 ) {
                        return; // offscreen
                    }
                    if ( lastLabelClickCoordinates && lastLabelClickCoordinates[ 0 ] === x && lastLabelClickCoordinates[ 1 ] === y ) {
                        return; // input click triggered by label click
                    }
                    // reset label click coordinates on first subsequent click
                    if ( lastLabelClickCoordinates ) {
                        lastLabelClickCoordinates = null;
                    }
                    // remember label click coordinates to prevent click busting of trigger click event on input
                    if ( event.target.tagName.toLowerCase() === 'label' ) {
                        lastLabelClickCoordinates = [ x, y ];
                    }
                    // Look for an allowable region containing this click.
                    // If we find one, that means it was created by touchstart and not removed by
                    // preventGhostClick, so we don't bust it.
                    if ( checkAllowableRegions( touchCoordinates, x, y ) ) {
                        return;
                    }
                    // If we didn't find an allowable region, bust the click.
                    event.stopPropagation();
                    event.preventDefault();
                    // Blur focused form elements
                    event.target && event.target.blur();
                }
                // Global touchstart handler that creates an allowable region for a click event.
                // This allowable region can be removed by preventGhostClick if we want to bust it.
            function onTouchStart( event ) {
                    var touches = event.touches && event.touches.length ? event.touches : [ event ];
                    var x = touches[ 0 ].clientX;
                    var y = touches[ 0 ].clientY;
                    touchCoordinates.push( x, y );
                    $timeout( function() {
                        // Remove the allowable region.
                        for ( var i = 0; i < touchCoordinates.length; i += 2 ) {
                            if ( touchCoordinates[ i ] == x && touchCoordinates[ i + 1 ] == y ) {
                                touchCoordinates.splice( i, i + 2 );
                                return;
                            }
                        }
                    }, PREVENT_DURATION, false );
                }
                // On the first call, attaches some event handlers. Then whenever it gets called, it creates a
                // zone around the touchstart where clicks will get busted.
            function preventGhostClick( x, y ) {
                    if ( !touchCoordinates ) {
                        $rootElement[ 0 ].addEventListener( 'click', onClick, true );
                        $rootElement[ 0 ].addEventListener( 'touchstart', onTouchStart, true );
                        touchCoordinates = [];
                    }
                    lastPreventedTime = Date.now();
                    checkAllowableRegions( touchCoordinates, x, y );
                }
                // Actual linking function.
            return function( scope, element, attr ) {
                var clickHandler = $parse( attr.ngClick ),
                    tapping = false,
                    tapElement, // Used to blur the element after a tap.
                    startTime, // Used to check if the tap was held too long.
                    touchStartX,
                    touchStartY;

                function resetState() {
                    tapping = false;
                    element.removeClass( ACTIVE_CLASS_NAME );
                }
                element.on( 'touchstart', function( event ) {
                    tapping = true;
                    tapElement = event.target ? event.target : event.srcElement; // IE uses srcElement.
                    // Hack for Safari, which can target text nodes instead of containers.
                    if ( tapElement.nodeType == 3 ) {
                        tapElement = tapElement.parentNode;
                    }
                    element.addClass( ACTIVE_CLASS_NAME );
                    startTime = Date.now();
                    var touches = event.touches && event.touches.length ? event.touches : [ event ];
                    var e = touches[ 0 ].originalEvent || touches[ 0 ];
                    touchStartX = e.clientX;
                    touchStartY = e.clientY;
                } );
                element.on( 'touchmove', function( event ) {
                    resetState();
                } );
                element.on( 'touchcancel', function( event ) {
                    resetState();
                } );
                element.on( 'touchend', function( event ) {
                    var diff = Date.now() - startTime;
                    var touches = ( event.changedTouches && event.changedTouches.length ) ? event.changedTouches : ( ( event.touches && event.touches.length ) ? event.touches : [ event ] );
                    var e = touches[ 0 ].originalEvent || touches[ 0 ];
                    var x = e.clientX;
                    var y = e.clientY;
                    var dist = Math.sqrt( Math.pow( x - touchStartX, 2 ) + Math.pow( y - touchStartY, 2 ) );
                    if ( tapping && diff < TAP_DURATION && dist < MOVE_TOLERANCE ) {
                        // Call preventGhostClick so the clickbuster will catch the corresponding click.
                        preventGhostClick( x, y );
                        // Blur the focused element (the button, probably) before firing the callback.
                        // This doesn't work perfectly on Android Chrome, but seems to work elsewhere.
                        // I couldn't get anything to work reliably on Android Chrome.
                        if ( tapElement ) {
                            tapElement.blur();
                        }
                        if ( !angular.isDefined( attr.disabled ) || attr.disabled === false ) {
                            element.triggerHandler( 'click', [ event ] );
                        }
                    }
                    resetState();
                } );
                // Hack for iOS Safari's benefit. It goes searching for onclick handlers and is liable to click
                // something else nearby.
                element.onclick = function( event ) {};
                // Actual click handler.
                // There are three different kinds of clicks, only two of which reach this point.
                // - On desktop browsers without touch events, their clicks will always come here.
                // - On mobile browsers, the simulated "fast" click will call this.
                // - But the browser's follow-up slow click will be "busted" before it reaches this handler.
                // Therefore it's safe to use this directive on both mobile and desktop.
                element.on( 'click', function( event, touchend ) {
                    scope.$apply( function() {
                        clickHandler( scope, {
                            $event: ( touchend || event )
                        } );
                    } );
                } );
                element.on( 'mousedown', function( event ) {
                    element.addClass( ACTIVE_CLASS_NAME );
                } );
                element.on( 'mousemove mouseup', function( event ) {
                    element.removeClass( ACTIVE_CLASS_NAME );
                } );
            };
} ] );
    /* global ngTouch: false */
    /**
     * @ngdoc directive
     * @name ngSwipeLeft
     *
     * @description
     * Specify custom behavior when an element is swiped to the left on a touchscreen device.
     * A leftward swipe is a quick, right-to-left slide of the finger.
     * Though ngSwipeLeft is designed for touch-based devices, it will work with a mouse click and drag
     * too.
     *
     * To disable the mouse click and drag functionality, add `ng-swipe-disable-mouse` to
     * the `ng-swipe-left` or `ng-swipe-right` DOM Element.
     *
     * Requires the {@link ngTouch `ngTouch`} module to be installed.
     *
     * @element ANY
     * @param {expression} ngSwipeLeft {@link guide/expression Expression} to evaluate
     * upon left swipe. (Event object is available as `$event`)
     *
     * @example
        <example module="ngSwipeLeftExample" deps="angular-touch.js">
          <file name="index.html">
            <div ng-show="!showActions" ng-swipe-left="showActions = true">
              Some list content, like an email in the inbox
            </div>
            <div ng-show="showActions" ng-swipe-right="showActions = false">
              <button ng-click="reply()">Reply</button>
              <button ng-click="delete()">Delete</button>
            </div>
          </file>
          <file name="script.js">
            angular.module('ngSwipeLeftExample', ['ngTouch']);
          </file>
        </example>
     */
    /**
     * @ngdoc directive
     * @name ngSwipeRight
     *
     * @description
     * Specify custom behavior when an element is swiped to the right on a touchscreen device.
     * A rightward swipe is a quick, left-to-right slide of the finger.
     * Though ngSwipeRight is designed for touch-based devices, it will work with a mouse click and drag
     * too.
     *
     * Requires the {@link ngTouch `ngTouch`} module to be installed.
     *
     * @element ANY
     * @param {expression} ngSwipeRight {@link guide/expression Expression} to evaluate
     * upon right swipe. (Event object is available as `$event`)
     *
     * @example
        <example module="ngSwipeRightExample" deps="angular-touch.js">
          <file name="index.html">
            <div ng-show="!showActions" ng-swipe-left="showActions = true">
              Some list content, like an email in the inbox
            </div>
            <div ng-show="showActions" ng-swipe-right="showActions = false">
              <button ng-click="reply()">Reply</button>
              <button ng-click="delete()">Delete</button>
            </div>
          </file>
          <file name="script.js">
            angular.module('ngSwipeRightExample', ['ngTouch']);
          </file>
        </example>
     */
    function makeSwipeDirective( directiveName, direction, eventName ) {
            ngTouch.directive( directiveName, [ '$parse', '$swipe', function( $parse, $swipe ) {
                // The maximum vertical delta for a swipe should be less than 75px.
                var MAX_VERTICAL_DISTANCE = 75;
                // Vertical distance should not be more than a fraction of the horizontal distance.
                var MAX_VERTICAL_RATIO = 0.3;
                // At least a 30px lateral motion is necessary for a swipe.
                var MIN_HORIZONTAL_DISTANCE = 30;
                return function( scope, element, attr ) {
                    var swipeHandler = $parse( attr[ directiveName ] );
                    var startCoords, valid;

                    function validSwipe( coords ) {
                        // Check that it's within the coordinates.
                        // Absolute vertical distance must be within tolerances.
                        // Horizontal distance, we take the current X - the starting X.
                        // This is negative for leftward swipes and positive for rightward swipes.
                        // After multiplying by the direction (-1 for left, +1 for right), legal swipes
                        // (ie. same direction as the directive wants) will have a positive delta and
                        // illegal ones a negative delta.
                        // Therefore this delta must be positive, and larger than the minimum.
                        if ( !startCoords ) return false;
                        var deltaY = Math.abs( coords.y - startCoords.y );
                        var deltaX = ( coords.x - startCoords.x ) * direction;
                        return valid && // Short circuit for already-invalidated swipes.
                            deltaY < MAX_VERTICAL_DISTANCE && deltaX > 0 && deltaX > MIN_HORIZONTAL_DISTANCE && deltaY / deltaX < MAX_VERTICAL_RATIO;
                    }
                    var pointerTypes = [ 'touch' ];
                    if ( !angular.isDefined( attr[ 'ngSwipeDisableMouse' ] ) ) {
                        pointerTypes.push( 'mouse' );
                    }
                    $swipe.bind( element, {
                        'start': function( coords, event ) {
                            startCoords = coords;
                            valid = true;
                        },
                        'cancel': function( event ) {
                            valid = false;
                        },
                        'end': function( coords, event ) {
                            if ( validSwipe( coords ) ) {
                                scope.$apply( function() {
                                    element.triggerHandler( eventName );
                                    swipeHandler( scope, {
                                        $event: event
                                    } );
                                } );
                            }
                        }
                    }, pointerTypes );
                };
  } ] );
        }
        // Left is negative X-coordinate, right is positive.
    makeSwipeDirective( 'ngSwipeLeft', -1, 'swipeleft' );
    makeSwipeDirective( 'ngSwipeRight', 1, 'swiperight' );
} )( window, window.angular );
/*! @license Firebase v2.0.6 - License: https://www.firebase.com/terms/terms-of-service.html */
( function() {
    var h, aa = this;

    function n( a ) {
        return void 0 !== a
    }

    function ba() {}

    function ca( a ) {
        a.Qb = function() {
            return a.ef ? a.ef : a.ef = new a
        }
    }

    function da( a ) {
        var b = typeof a;
        if ( "object" == b )
            if ( a ) {
                if ( a instanceof Array ) return "array";
                if ( a instanceof Object ) return b;
                var c = Object.prototype.toString.call( a );
                if ( "[object Window]" == c ) return "object";
                if ( "[object Array]" == c || "number" == typeof a.length && "undefined" != typeof a.splice && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable( "splice" ) ) return "array";
                if ( "[object Function]" == c || "undefined" != typeof a.call && "undefined" != typeof a.propertyIsEnumerable && !a.propertyIsEnumerable( "call" ) ) return "function"
            } else return "null";
        else if ( "function" == b && "undefined" == typeof a.call ) return "object";
        return b
    }

    function ea( a ) {
        return "array" == da( a )
    }

    function fa( a ) {
        var b = da( a );
        return "array" == b || "object" == b && "number" == typeof a.length
    }

    function p( a ) {
        return "string" == typeof a
    }

    function ga( a ) {
        return "number" == typeof a
    }

    function ha( a ) {
        return "function" == da( a )
    }

    function ia( a ) {
        var b = typeof a;
        return "object" == b && null != a || "function" == b
    }

    function ja( a, b, c ) {
        return a.call.apply( a.bind, arguments )
    }

    function ka( a, b, c ) {
        if ( !a ) throw Error();
        if ( 2 < arguments.length ) {
            var d = Array.prototype.slice.call( arguments, 2 );
            return function() {
                var c = Array.prototype.slice.call( arguments );
                Array.prototype.unshift.apply( c, d );
                return a.apply( b, c )
            }
        }
        return function() {
            return a.apply( b, arguments )
        }
    }

    function q( a, b, c ) {
        q = Function.prototype.bind && -1 != Function.prototype.bind.toString().indexOf( "native code" ) ? ja : ka;
        return q.apply( null, arguments )
    }

    function la( a, b ) {
        var c = Array.prototype.slice.call( arguments, 1 );
        return function() {
            var b = c.slice();
            b.push.apply( b, arguments );
            return a.apply( this, b )
        }
    }
    var ma = Date.now || function() {
        return +new Date
    };

    function na( a, b ) {
        function c() {}
        c.prototype = b.prototype;
        a.oc = b.prototype;
        a.prototype = new c;
        a.Ag = function( a, c, f ) {
            return b.prototype[ c ].apply( a, Array.prototype.slice.call( arguments, 2 ) )
        }
    };

    function oa( a ) {
        a = String( a );
        if ( /^\s*$/.test( a ) ? 0 : /^[\],:{}\s\u2028\u2029]*$/.test( a.replace( /\\["\\\/bfnrtu]/g, "@" ).replace( /"[^"\\\n\r\u2028\u2029\x00-\x08\x0a-\x1f]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g, "]" ).replace( /(?:^|:|,)(?:[\s\u2028\u2029]*\[)+/g, "" ) ) ) try {
            return eval( "(" + a + ")" )
        } catch ( b ) {}
        throw Error( "Invalid JSON string: " + a );
    }

    function pa() {
        this.Id = void 0
    }

    function qa( a, b, c ) {
        switch ( typeof b ) {
            case "string":
                ra( b, c );
                break;
            case "number":
                c.push( isFinite( b ) && !isNaN( b ) ? b : "null" );
                break;
            case "boolean":
                c.push( b );
                break;
            case "undefined":
                c.push( "null" );
                break;
            case "object":
                if ( null == b ) {
                    c.push( "null" );
                    break
                }
                if ( ea( b ) ) {
                    var d = b.length;
                    c.push( "[" );
                    for ( var e = "", f = 0; f < d; f++ ) c.push( e ), e = b[ f ], qa( a, a.Id ? a.Id.call( b, String( f ), e ) : e, c ), e = ",";
                    c.push( "]" );
                    break
                }
                c.push( "{" );
                d = "";
                for ( f in b ) Object.prototype.hasOwnProperty.call( b, f ) && ( e = b[ f ], "function" != typeof e && ( c.push( d ), ra( f, c ), c.push( ":" ), qa( a, a.Id ? a.Id.call( b, f, e ) : e, c ), d = "," ) );
                c.push( "}" );
                break;
            case "function":
                break;
            default:
                throw Error( "Unknown type: " + typeof b );
        }
    }
    var sa = {
            '"': '\\"',
            "\\": "\\\\",
            "/": "\\/",
            "\b": "\\b",
            "\f": "\\f",
            "\n": "\\n",
            "\r": "\\r",
            "\t": "\\t",
            "\x0B": "\\u000b"
        },
        ta = /\uffff/.test( "\uffff" ) ? /[\\\"\x00-\x1f\x7f-\uffff]/g : /[\\\"\x00-\x1f\x7f-\xff]/g;

    function ra( a, b ) {
        b.push( '"', a.replace( ta, function( a ) {
            if ( a in sa ) return sa[ a ];
            var b = a.charCodeAt( 0 ),
                e = "\\u";
            16 > b ? e += "000" : 256 > b ? e += "00" : 4096 > b && ( e += "0" );
            return sa[ a ] = e + b.toString( 16 )
        } ), '"' )
    };

    function ua( a ) {
        return "undefined" !== typeof JSON && n( JSON.parse ) ? JSON.parse( a ) : oa( a )
    }

    function t( a ) {
        if ( "undefined" !== typeof JSON && n( JSON.stringify ) ) a = JSON.stringify( a );
        else {
            var b = [];
            qa( new pa, a, b );
            a = b.join( "" )
        }
        return a
    };

    function u( a, b ) {
        return Object.prototype.hasOwnProperty.call( a, b )
    }

    function v( a, b ) {
        if ( Object.prototype.hasOwnProperty.call( a, b ) ) return a[ b ]
    }

    function va( a, b ) {
        for ( var c in a ) Object.prototype.hasOwnProperty.call( a, c ) && b( c, a[ c ] )
    }

    function wa( a ) {
        var b = {};
        va( a, function( a, d ) {
            b[ a ] = d
        } );
        return b
    };

    function xa( a ) {
        this.xc = a;
        this.Hd = "firebase:"
    }
    h = xa.prototype;
    h.set = function( a, b ) {
        null == b ? this.xc.removeItem( this.Hd + a ) : this.xc.setItem( this.Hd + a, t( b ) )
    };
    h.get = function( a ) {
        a = this.xc.getItem( this.Hd + a );
        return null == a ? null : ua( a )
    };
    h.remove = function( a ) {
        this.xc.removeItem( this.Hd + a )
    };
    h.ff = !1;
    h.toString = function() {
        return this.xc.toString()
    };

    function ya() {
        this.ha = {}
    }
    ya.prototype.set = function( a, b ) {
        null == b ? delete this.ha[ a ] : this.ha[ a ] = b
    };
    ya.prototype.get = function( a ) {
        return u( this.ha, a ) ? this.ha[ a ] : null
    };
    ya.prototype.remove = function( a ) {
        delete this.ha[ a ]
    };
    ya.prototype.ff = !0;

    function za( a ) {
        try {
            if ( "undefined" !== typeof window && "undefined" !== typeof window[ a ] ) {
                var b = window[ a ];
                b.setItem( "firebase:sentinel", "cache" );
                b.removeItem( "firebase:sentinel" );
                return new xa( b )
            }
        } catch ( c ) {}
        return new ya
    }
    var Aa = za( "localStorage" ),
        Ba = za( "sessionStorage" );

    function Ca( a, b, c, d, e ) {
        this.host = a.toLowerCase();
        this.domain = this.host.substr( this.host.indexOf( "." ) + 1 );
        this.Cb = b;
        this.yb = c;
        this.yg = d;
        this.Gd = e || "";
        this.Ka = Aa.get( "host:" + a ) || this.host
    }

    function Da( a, b ) {
        b !== a.Ka && ( a.Ka = b, "s-" === a.Ka.substr( 0, 2 ) && Aa.set( "host:" + a.host, a.Ka ) )
    }
    Ca.prototype.toString = function() {
        var a = ( this.Cb ? "https://" : "http://" ) + this.host;
        this.Gd && ( a += "<" + this.Gd + ">" );
        return a
    };

    function Ea() {
        this.Ta = -1
    };

    function Fa() {
        this.Ta = -1;
        this.Ta = 64;
        this.R = [];
        this.be = [];
        this.Af = [];
        this.Dd = [];
        this.Dd[ 0 ] = 128;
        for ( var a = 1; a < this.Ta; ++a ) this.Dd[ a ] = 0;
        this.Rd = this.Tb = 0;
        this.reset()
    }
    na( Fa, Ea );
    Fa.prototype.reset = function() {
        this.R[ 0 ] = 1732584193;
        this.R[ 1 ] = 4023233417;
        this.R[ 2 ] = 2562383102;
        this.R[ 3 ] = 271733878;
        this.R[ 4 ] = 3285377520;
        this.Rd = this.Tb = 0
    };

    function Ga( a, b, c ) {
        c || ( c = 0 );
        var d = a.Af;
        if ( p( b ) )
            for ( var e = 0; 16 > e; e++ ) d[ e ] = b.charCodeAt( c ) << 24 | b.charCodeAt( c + 1 ) << 16 | b.charCodeAt( c + 2 ) << 8 | b.charCodeAt( c + 3 ), c += 4;
        else
            for ( e = 0; 16 > e; e++ ) d[ e ] = b[ c ] << 24 | b[ c + 1 ] << 16 | b[ c + 2 ] << 8 | b[ c + 3 ], c += 4;
        for ( e = 16; 80 > e; e++ ) {
            var f = d[ e - 3 ] ^ d[ e - 8 ] ^ d[ e - 14 ] ^ d[ e - 16 ];
            d[ e ] = ( f << 1 | f >>> 31 ) & 4294967295
        }
        b = a.R[ 0 ];
        c = a.R[ 1 ];
        for ( var g = a.R[ 2 ], k = a.R[ 3 ], l = a.R[ 4 ], m, e = 0; 80 > e; e++ ) 40 > e ? 20 > e ? ( f = k ^ c & ( g ^ k ), m = 1518500249 ) : ( f = c ^ g ^ k, m = 1859775393 ) : 60 > e ? ( f = c & g | k & ( c | g ), m = 2400959708 ) : ( f = c ^ g ^ k, m = 3395469782 ), f = ( b << 5 | b >>> 27 ) + f + l + m + d[ e ] & 4294967295, l = k, k = g, g = ( c << 30 | c >>> 2 ) & 4294967295, c = b, b = f;
        a.R[ 0 ] = a.R[ 0 ] + b & 4294967295;
        a.R[ 1 ] = a.R[ 1 ] + c & 4294967295;
        a.R[ 2 ] = a.R[ 2 ] + g & 4294967295;
        a.R[ 3 ] = a.R[ 3 ] + k & 4294967295;
        a.R[ 4 ] = a.R[ 4 ] + l & 4294967295
    }
    Fa.prototype.update = function( a, b ) {
        n( b ) || ( b = a.length );
        for ( var c = b - this.Ta, d = 0, e = this.be, f = this.Tb; d < b; ) {
            if ( 0 == f )
                for ( ; d <= c; ) Ga( this, a, d ), d += this.Ta;
            if ( p( a ) )
                for ( ; d < b; ) {
                    if ( e[ f ] = a.charCodeAt( d ), ++f, ++d, f == this.Ta ) {
                        Ga( this, e );
                        f = 0;
                        break
                    }
                } else
                    for ( ; d < b; )
                        if ( e[ f ] = a[ d ], ++f, ++d, f == this.Ta ) {
                            Ga( this, e );
                            f = 0;
                            break
                        }
        }
        this.Tb = f;
        this.Rd += b
    };

    function Ha() {
        return Math.floor( 2147483648 * Math.random() ).toString( 36 ) + Math.abs( Math.floor( 2147483648 * Math.random() ) ^ ma() ).toString( 36 )
    };
    var w = Array.prototype,
        Ia = w.indexOf ? function( a, b, c ) {
            return w.indexOf.call( a, b, c )
        } : function( a, b, c ) {
            c = null == c ? 0 : 0 > c ? Math.max( 0, a.length + c ) : c;
            if ( p( a ) ) return p( b ) && 1 == b.length ? a.indexOf( b, c ) : -1;
            for ( ; c < a.length; c++ )
                if ( c in a && a[ c ] === b ) return c;
            return -1
        },
        Ja = w.forEach ? function( a, b, c ) {
            w.forEach.call( a, b, c )
        } : function( a, b, c ) {
            for ( var d = a.length, e = p( a ) ? a.split( "" ) : a, f = 0; f < d; f++ ) f in e && b.call( c, e[ f ], f, a )
        },
        Ka = w.filter ? function( a, b, c ) {
            return w.filter.call( a, b, c )
        } : function( a, b, c ) {
            for ( var d = a.length, e = [], f = 0, g = p( a ) ? a.split( "" ) : a, k = 0; k < d; k++ )
                if ( k in g ) {
                    var l = g[ k ];
                    b.call( c, l, k, a ) && ( e[ f++ ] = l )
                }
            return e
        },
        La = w.map ? function( a, b, c ) {
            return w.map.call( a, b, c )
        } : function( a, b, c ) {
            for ( var d = a.length, e = Array( d ), f = p( a ) ? a.split( "" ) : a, g = 0; g < d; g++ ) g in f && ( e[ g ] = b.call( c, f[ g ], g, a ) );
            return e
        },
        Ma = w.reduce ? function( a, b, c, d ) {
            d && ( b = q( b, d ) );
            return w.reduce.call( a, b, c )
        } : function( a, b, c, d ) {
            var e = c;
            Ja( a, function( c, g ) {
                e = b.call( d, e, c, g, a )
            } );
            return e
        },
        Na = w.every ? function( a, b, c ) {
            return w.every.call( a, b, c )
        } : function( a, b, c ) {
            for ( var d = a.length, e = p( a ) ? a.split( "" ) : a, f = 0; f < d; f++ )
                if ( f in e && !b.call( c, e[ f ], f, a ) ) return !1;
            return !0
        };

    function Oa( a, b ) {
        var c = Pa( a, b, void 0 );
        return 0 > c ? null : p( a ) ? a.charAt( c ) : a[ c ]
    }

    function Pa( a, b, c ) {
        for ( var d = a.length, e = p( a ) ? a.split( "" ) : a, f = 0; f < d; f++ )
            if ( f in e && b.call( c, e[ f ], f, a ) ) return f;
        return -1
    }

    function Qa( a, b ) {
        var c = Ia( a, b );
        0 <= c && w.splice.call( a, c, 1 )
    }

    function Ra( a, b, c, d ) {
        return w.splice.apply( a, Sa( arguments, 1 ) )
    }

    function Sa( a, b, c ) {
        return 2 >= arguments.length ? w.slice.call( a, b ) : w.slice.call( a, b, c )
    }

    function Ta( a, b ) {
        a.sort( b || Ua )
    }

    function Ua( a, b ) {
        return a > b ? 1 : a < b ? -1 : 0
    };
    var Va;
    a: {
        var Wa = aa.navigator;
        if ( Wa ) {
            var Xa = Wa.userAgent;
            if ( Xa ) {
                Va = Xa;
                break a
            }
        }
        Va = ""
    }

    function Ya( a ) {
        return -1 != Va.indexOf( a )
    };
    var Za = Ya( "Opera" ) || Ya( "OPR" ),
        $a = Ya( "Trident" ) || Ya( "MSIE" ),
        ab = Ya( "Gecko" ) && -1 == Va.toLowerCase().indexOf( "webkit" ) && !( Ya( "Trident" ) || Ya( "MSIE" ) ),
        bb = -1 != Va.toLowerCase().indexOf( "webkit" );
    ( function() {
        var a = "",
            b;
        if ( Za && aa.opera ) return a = aa.opera.version, ha( a ) ? a() : a;
        ab ? b = /rv\:([^\);]+)(\)|;)/ : $a ? b = /\b(?:MSIE|rv)[: ]([^\);]+)(\)|;)/ : bb && ( b = /WebKit\/(\S+)/ );
        b && ( a = ( a = b.exec( Va ) ) ? a[ 1 ] : "" );
        return $a && ( b = ( b = aa.document ) ? b.documentMode : void 0, b > parseFloat( a ) ) ? String( b ) : a
    } )();
    var cb = null,
        db = null,
        eb = null;

    function fb( a, b ) {
        if ( !fa( a ) ) throw Error( "encodeByteArray takes an array as a parameter" );
        gb();
        for ( var c = b ? db : cb, d = [], e = 0; e < a.length; e += 3 ) {
            var f = a[ e ],
                g = e + 1 < a.length,
                k = g ? a[ e + 1 ] : 0,
                l = e + 2 < a.length,
                m = l ? a[ e + 2 ] : 0,
                r = f >> 2,
                f = ( f & 3 ) << 4 | k >> 4,
                k = ( k & 15 ) << 2 | m >> 6,
                m = m & 63;
            l || ( m = 64, g || ( k = 64 ) );
            d.push( c[ r ], c[ f ], c[ k ], c[ m ] )
        }
        return d.join( "" )
    }

    function gb() {
        if ( !cb ) {
            cb = {};
            db = {};
            eb = {};
            for ( var a = 0; 65 > a; a++ ) cb[ a ] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".charAt( a ), db[ a ] = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.".charAt( a ), eb[ db[ a ] ] = a
        }
    };
    var hb = function() {
        var a = 1;
        return function() {
            return a++
        }
    }();

    function x( a, b ) {
        if ( !a ) throw ib( b );
    }

    function ib( a ) {
        return Error( "Firebase INTERNAL ASSERT FAILED:" + a )
    }

    function jb( a ) {
        try {
            var b;
            if ( "undefined" !== typeof atob ) b = atob( a );
            else {
                gb();
                for ( var c = eb, d = [], e = 0; e < a.length; ) {
                    var f = c[ a.charAt( e++ ) ],
                        g = e < a.length ? c[ a.charAt( e ) ] : 0;
                    ++e;
                    var k = e < a.length ? c[ a.charAt( e ) ] : 64;
                    ++e;
                    var l = e < a.length ? c[ a.charAt( e ) ] : 64;
                    ++e;
                    if ( null == f || null == g || null == k || null == l ) throw Error();
                    d.push( f << 2 | g >> 4 );
                    64 != k && ( d.push( g << 4 & 240 | k >> 2 ), 64 != l && d.push( k << 6 & 192 | l ) )
                }
                if ( 8192 > d.length ) b = String.fromCharCode.apply( null, d );
                else {
                    a = "";
                    for ( c = 0; c < d.length; c += 8192 ) a += String.fromCharCode.apply( null, Sa( d, c, c + 8192 ) );
                    b = a
                }
            }
            return b
        } catch ( m ) {
            kb( "base64Decode failed: ", m )
        }
        return null
    }

    function lb( a ) {
        var b = mb( a );
        a = new Fa;
        a.update( b );
        var b = [],
            c = 8 * a.Rd;
        56 > a.Tb ? a.update( a.Dd, 56 - a.Tb ) : a.update( a.Dd, a.Ta - ( a.Tb - 56 ) );
        for ( var d = a.Ta - 1; 56 <= d; d-- ) a.be[ d ] = c & 255, c /= 256;
        Ga( a, a.be );
        for ( d = c = 0; 5 > d; d++ )
            for ( var e = 24; 0 <= e; e -= 8 ) b[ c ] = a.R[ d ] >> e & 255, ++c;
        return fb( b )
    }

    function nb( a ) {
        for ( var b = "", c = 0; c < arguments.length; c++ ) b = fa( arguments[ c ] ) ? b + nb.apply( null, arguments[ c ] ) : "object" === typeof arguments[ c ] ? b + t( arguments[ c ] ) : b + arguments[ c ], b += " ";
        return b
    }
    var ob = null,
        pb = !0;

    function kb( a ) {
        !0 === pb && ( pb = !1, null === ob && !0 === Ba.get( "logging_enabled" ) && qb( !0 ) );
        if ( ob ) {
            var b = nb.apply( null, arguments );
            ob( b )
        }
    }

    function rb( a ) {
        return function() {
            kb( a, arguments )
        }
    }

    function sb( a ) {
        if ( "undefined" !== typeof console ) {
            var b = "FIREBASE INTERNAL ERROR: " + nb.apply( null, arguments );
            "undefined" !== typeof console.error ? console.error( b ) : console.log( b )
        }
    }

    function tb( a ) {
        var b = nb.apply( null, arguments );
        throw Error( "FIREBASE FATAL ERROR: " + b );
    }

    function z( a ) {
        if ( "undefined" !== typeof console ) {
            var b = "FIREBASE WARNING: " + nb.apply( null, arguments );
            "undefined" !== typeof console.warn ? console.warn( b ) : console.log( b )
        }
    }

    function ub( a ) {
        var b = "",
            c = "",
            d = "",
            e = !0,
            f = "https",
            g = "";
        if ( p( a ) ) {
            var k = a.indexOf( "//" );
            0 <= k && ( f = a.substring( 0, k - 1 ), a = a.substring( k + 2 ) );
            k = a.indexOf( "/" ); - 1 === k && ( k = a.length );
            b = a.substring( 0, k );
            a = a.substring( k + 1 );
            var l = b.split( "." );
            if ( 3 === l.length ) {
                k = l[ 2 ].indexOf( ":" );
                e = 0 <= k ? "https" === f || "wss" === f : !0;
                c = l[ 1 ];
                d = l[ 0 ];
                g = "";
                a = ( "/" + a ).split( "/" );
                for ( k = 0; k < a.length; k++ )
                    if ( 0 < a[ k ].length ) {
                        l = a[ k ];
                        try {
                            l = decodeURIComponent( l.replace( /\+/g, " " ) )
                        } catch ( m ) {}
                        g += "/" + l
                    }
                d = d.toLowerCase()
            } else 2 === l.length && ( c = l[ 0 ] )
        }
        return {
            host: b,
            domain: c,
            vg: d,
            Cb: e,
            scheme: f,
            Pc: g
        }
    }

    function vb( a ) {
        return ga( a ) && ( a != a || a == Number.POSITIVE_INFINITY || a == Number.NEGATIVE_INFINITY )
    }

    function wb( a ) {
        if ( "complete" === document.readyState ) a();
        else {
            var b = !1,
                c = function() {
                    document.body ? b || ( b = !0, a() ) : setTimeout( c, Math.floor( 10 ) )
                };
            document.addEventListener ? ( document.addEventListener( "DOMContentLoaded", c, !1 ), window.addEventListener( "load", c, !1 ) ) : document.attachEvent && ( document.attachEvent( "onreadystatechange", function() {
                "complete" === document.readyState && c()
            } ), window.attachEvent( "onload", c ) )
        }
    }

    function xb( a, b ) {
        if ( a === b ) return 0;
        if ( "[MIN_NAME]" === a || "[MAX_NAME]" === b ) return -1;
        if ( "[MIN_NAME]" === b || "[MAX_NAME]" === a ) return 1;
        var c = yb( a ),
            d = yb( b );
        return null !== c ? null !== d ? 0 == c - d ? a.length - b.length : c - d : -1 : null !== d ? 1 : a < b ? -1 : 1
    }

    function zb( a, b ) {
        if ( b && a in b ) return b[ a ];
        throw Error( "Missing required key (" + a + ") in object: " + t( b ) );
    }

    function Ab( a ) {
        if ( "object" !== typeof a || null === a ) return t( a );
        var b = [],
            c;
        for ( c in a ) b.push( c );
        b.sort();
        c = "{";
        for ( var d = 0; d < b.length; d++ ) 0 !== d && ( c += "," ), c += t( b[ d ] ), c += ":", c += Ab( a[ b[ d ] ] );
        return c + "}"
    }

    function Bb( a, b ) {
        if ( a.length <= b ) return [ a ];
        for ( var c = [], d = 0; d < a.length; d += b ) d + b > a ? c.push( a.substring( d, a.length ) ) : c.push( a.substring( d, d + b ) );
        return c
    }

    function Cb( a, b ) {
        if ( ea( a ) )
            for ( var c = 0; c < a.length; ++c ) b( c, a[ c ] );
        else A( a, b )
    }

    function Db( a ) {
        x( !vb( a ), "Invalid JSON number" );
        var b, c, d, e;
        0 === a ? ( d = c = 0, b = -Infinity === 1 / a ? 1 : 0 ) : ( b = 0 > a, a = Math.abs( a ), a >= Math.pow( 2, -1022 ) ? ( d = Math.min( Math.floor( Math.log( a ) / Math.LN2 ), 1023 ), c = d + 1023, d = Math.round( a * Math.pow( 2, 52 - d ) - Math.pow( 2, 52 ) ) ) : ( c = 0, d = Math.round( a / Math.pow( 2, -1074 ) ) ) );
        e = [];
        for ( a = 52; a; a -= 1 ) e.push( d % 2 ? 1 : 0 ), d = Math.floor( d / 2 );
        for ( a = 11; a; a -= 1 ) e.push( c % 2 ? 1 : 0 ), c = Math.floor( c / 2 );
        e.push( b ? 1 : 0 );
        e.reverse();
        b = e.join( "" );
        c = "";
        for ( a = 0; 64 > a; a += 8 ) d = parseInt( b.substr( a, 8 ), 2 ).toString( 16 ), 1 === d.length && ( d = "0" + d ), c += d;
        return c.toLowerCase()
    }
    var Eb = /^-?\d{1,10}$/;

    function yb( a ) {
        return Eb.test( a ) && ( a = Number( a ), -2147483648 <= a && 2147483647 >= a ) ? a : null
    }

    function Fb( a ) {
        try {
            a()
        } catch ( b ) {
            setTimeout( function() {
                throw b;
            }, Math.floor( 0 ) )
        }
    }

    function B( a, b ) {
        if ( ha( a ) ) {
            var c = Array.prototype.slice.call( arguments, 1 ).slice();
            Fb( function() {
                a.apply( null, c )
            } )
        }
    };

    function Gb( a, b, c, d ) {
        this.me = b;
        this.Ld = c;
        this.Rc = d;
        this.nd = a
    }
    Gb.prototype.Rb = function() {
        var a = this.Ld.hc();
        return "value" === this.nd ? a.path : a.parent().path
    };
    Gb.prototype.oe = function() {
        return this.nd
    };
    Gb.prototype.Pb = function() {
        return this.me.Pb( this )
    };
    Gb.prototype.toString = function() {
        return this.Rb().toString() + ":" + this.nd + ":" + t( this.Ld.Xe() )
    };

    function Hb( a, b, c ) {
        this.me = a;
        this.error = b;
        this.path = c
    }
    Hb.prototype.Rb = function() {
        return this.path
    };
    Hb.prototype.oe = function() {
        return "cancel"
    };
    Hb.prototype.Pb = function() {
        return this.me.Pb( this )
    };
    Hb.prototype.toString = function() {
        return this.path.toString() + ":cancel"
    };

    function Ib( a, b, c ) {
        this.Kb = a;
        this.mb = b;
        this.vc = c || null
    }
    h = Ib.prototype;
    h.pf = function( a ) {
        return "value" === a
    };
    h.createEvent = function( a, b ) {
        var c = b.w.m;
        return new Gb( "value", this, new C( a.Wa, b.hc(), c ) )
    };
    h.Pb = function( a ) {
        var b = this.vc;
        if ( "cancel" === a.oe() ) {
            x( this.mb, "Raising a cancel event on a listener with no cancel callback" );
            var c = this.mb;
            return function() {
                c.call( b, a.error )
            }
        }
        var d = this.Kb;
        return function() {
            d.call( b, a.Ld )
        }
    };
    h.Te = function( a, b ) {
        return this.mb ? new Hb( this, a, b ) : null
    };
    h.matches = function( a ) {
        return a instanceof Ib && ( !a.Kb || !this.Kb || a.Kb === this.Kb ) && a.vc === this.vc
    };
    h.cf = function() {
        return null !== this.Kb
    };

    function Jb( a, b, c ) {
        this.ba = a;
        this.mb = b;
        this.vc = c
    }
    h = Jb.prototype;
    h.pf = function( a ) {
        a = "children_added" === a ? "child_added" : a;
        return ( "children_removed" === a ? "child_removed" : a ) in this.ba
    };
    h.Te = function( a, b ) {
        return this.mb ? new Hb( this, a, b ) : null
    };
    h.createEvent = function( a, b ) {
        var c = b.hc().k( a.nb );
        return new Gb( a.type, this, new C( a.Wa, c, b.w.m ), a.Rc )
    };
    h.Pb = function( a ) {
        var b = this.vc;
        if ( "cancel" === a.oe() ) {
            x( this.mb, "Raising a cancel event on a listener with no cancel callback" );
            var c = this.mb;
            return function() {
                c.call( b, a.error )
            }
        }
        var d = this.ba[ a.nd ];
        return function() {
            d.call( b, a.Ld, a.Rc )
        }
    };
    h.matches = function( a ) {
        if ( a instanceof Jb ) {
            if ( this.ba && a.ba ) {
                var b = Kb( a.ba );
                if ( b === Kb( this.ba ) ) {
                    if ( 1 === b ) {
                        var b = Lb( a.ba ),
                            c = Lb( this.ba );
                        return c === b && ( !a.ba[ b ] || !this.ba[ c ] || a.ba[ b ] === this.ba[ c ] )
                    }
                    return Mb( this.ba, function( b, c ) {
                        return a.ba[ c ] === b
                    } )
                }
                return !1
            }
            return !0
        }
        return !1
    };
    h.cf = function() {
        return null !== this.ba
    };

    function mb( a ) {
        for ( var b = [], c = 0, d = 0; d < a.length; d++ ) {
            var e = a.charCodeAt( d );
            55296 <= e && 56319 >= e && ( e -= 55296, d++, x( d < a.length, "Surrogate pair missing trail surrogate." ), e = 65536 + ( e << 10 ) + ( a.charCodeAt( d ) - 56320 ) );
            128 > e ? b[ c++ ] = e : ( 2048 > e ? b[ c++ ] = e >> 6 | 192 : ( 65536 > e ? b[ c++ ] = e >> 12 | 224 : ( b[ c++ ] = e >> 18 | 240, b[ c++ ] = e >> 12 & 63 | 128 ), b[ c++ ] = e >> 6 & 63 | 128 ), b[ c++ ] = e & 63 | 128 )
        }
        return b
    };

    function D( a, b, c, d ) {
        var e;
        d < b ? e = "at least " + b : d > c && ( e = 0 === c ? "none" : "no more than " + c );
        if ( e ) throw Error( a + " failed: Was called with " + d + ( 1 === d ? " argument." : " arguments." ) + " Expects " + e + "." );
    }

    function E( a, b, c ) {
        var d = "";
        switch ( b ) {
            case 1:
                d = c ? "first" : "First";
                break;
            case 2:
                d = c ? "second" : "Second";
                break;
            case 3:
                d = c ? "third" : "Third";
                break;
            case 4:
                d = c ? "fourth" : "Fourth";
                break;
            default:
                throw Error( "errorPrefix called with argumentNumber > 4.  Need to update it?" );
        }
        return a = a + " failed: " + ( d + " argument " )
    }

    function F( a, b, c, d ) {
        if ( ( !d || n( c ) ) && !ha( c ) ) throw Error( E( a, b, d ) + "must be a valid function." );
    }

    function Nb( a, b, c ) {
        if ( n( c ) && ( !ia( c ) || null === c ) ) throw Error( E( a, b, !0 ) + "must be a valid context object." );
    };
    var Ob = /[\[\].#$\/\u0000-\u001F\u007F]/,
        Pb = /[\[\].#$\u0000-\u001F\u007F]/;

    function Qb( a ) {
        return p( a ) && 0 !== a.length && !Ob.test( a )
    }

    function Rb( a ) {
        return null === a || p( a ) || ga( a ) && !vb( a ) || ia( a ) && u( a, ".sv" )
    }

    function Sb( a, b, c ) {
        c && !n( b ) || Tb( E( a, 1, c ), b )
    }

    function Tb( a, b, c, d ) {
        c || ( c = 0 );
        d = d || [];
        if ( !n( b ) ) throw Error( a + "contains undefined" + Ub( d ) );
        if ( ha( b ) ) throw Error( a + "contains a function" + Ub( d ) + " with contents: " + b.toString() );
        if ( vb( b ) ) throw Error( a + "contains " + b.toString() + Ub( d ) );
        if ( 1E3 < c ) throw new TypeError( a + "contains a cyclic object value (" + d.slice( 0, 100 ).join( "." ) + "...)" );
        if ( p( b ) && b.length > 10485760 / 3 && 10485760 < mb( b ).length ) throw Error( a + "contains a string greater than 10485760 utf8 bytes" + Ub( d ) + " ('" + b.substring( 0, 50 ) + "...')" );
        if ( ia( b ) )
            for ( var e in b )
                if ( u( b, e ) ) {
                    var f = b[ e ];
                    if ( ".priority" !== e && ".value" !== e && ".sv" !== e && !Qb( e ) ) throw Error( a + " contains an invalid key (" + e + ")" + Ub( d ) + '.  Keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]"' );
                    d.push( e );
                    Tb( a, f, c + 1, d );
                    d.pop()
                }
    }

    function Ub( a ) {
        return 0 == a.length ? "" : " in property '" + a.join( "." ) + "'"
    }

    function Vb( a, b ) {
        if ( !ia( b ) || ea( b ) ) throw Error( E( a, 1, !1 ) + " must be an Object containing the children to replace." );
        Sb( a, b, !1 )
    }

    function Wb( a, b, c ) {
        if ( vb( c ) ) throw Error( E( a, b, !1 ) + "is " + c.toString() + ", but must be a valid Firebase priority (a string, finite number, server value, or null)." );
        if ( !Rb( c ) ) throw Error( E( a, b, !1 ) + "must be a valid Firebase priority (a string, finite number, server value, or null)." );
    }

    function Xb( a, b, c ) {
        if ( !c || n( b ) ) switch ( b ) {
            case "value":
            case "child_added":
            case "child_removed":
            case "child_changed":
            case "child_moved":
                break;
            default:
                throw Error( E( a, 1, c ) + 'must be a valid event type: "value", "child_added", "child_removed", "child_changed", or "child_moved".' );
        }
    }

    function Yb( a, b, c, d ) {
        if ( ( !d || n( c ) ) && !Qb( c ) ) throw Error( E( a, b, d ) + 'was an invalid key: "' + c + '".  Firebase keys must be non-empty strings and can\'t contain ".", "#", "$", "/", "[", or "]").' );
    }

    function Zb( a, b ) {
        if ( !p( b ) || 0 === b.length || Pb.test( b ) ) throw Error( E( a, 1, !1 ) + 'was an invalid path: "' + b + '". Paths must be non-empty strings and can\'t contain ".", "#", "$", "[", or "]"' );
    }

    function $b( a, b ) {
        if ( ".info" === G( b ) ) throw Error( a + " failed: Can't modify data under /.info/" );
    }

    function ac( a, b ) {
        if ( !p( b ) ) throw Error( E( a, 1, !1 ) + "must be a valid credential (a string)." );
    }

    function bc( a, b, c ) {
        if ( !p( c ) ) throw Error( E( a, b, !1 ) + "must be a valid string." );
    }

    function cc( a, b, c, d ) {
        if ( !d || n( c ) )
            if ( !ia( c ) || null === c ) throw Error( E( a, b, d ) + "must be a valid object." );
    }

    function dc( a, b, c ) {
        if ( !ia( b ) || null === b || !u( b, c ) ) throw Error( E( a, 1, !1 ) + 'must contain the key "' + c + '"' );
        if ( !p( v( b, c ) ) ) throw Error( E( a, 1, !1 ) + 'must contain the key "' + c + '" with type "string"' );
    };

    function ec( a, b ) {
        return xb( a.name, b.name )
    }

    function fc( a, b ) {
        return xb( a, b )
    };

    function gc() {}
    var hc = {};

    function H( a ) {
        return q( a.compare, a )
    }
    gc.prototype.df = function( a, b ) {
        return 0 !== this.compare( new I( "[MIN_NAME]", a ), new I( "[MIN_NAME]", b ) )
    };
    gc.prototype.Ae = function() {
        return ic
    };

    function jc( a ) {
        this.Vb = a
    }
    na( jc, gc );
    h = jc.prototype;
    h.se = function( a ) {
        return !a.B( this.Vb ).e()
    };
    h.compare = function( a, b ) {
        var c = a.K.B( this.Vb ),
            d = b.K.B( this.Vb ),
            c = c.he( d );
        return 0 === c ? xb( a.name, b.name ) : c
    };
    h.ye = function( a, b ) {
        var c = J( a ),
            c = K.I( this.Vb, c );
        return new I( b, c )
    };
    h.ze = function() {
        var a = K.I( this.Vb, kc );
        return new I( "[MAX_NAME]", a )
    };
    h.toString = function() {
        return this.Vb
    };
    var L = new jc( ".priority" );

    function lc() {}
    na( lc, gc );
    h = lc.prototype;
    h.compare = function( a, b ) {
        return xb( a.name, b.name )
    };
    h.se = function() {
        throw ib( "KeyIndex.isDefinedOn not expected to be called." );
    };
    h.df = function() {
        return !1
    };
    h.Ae = function() {
        return ic
    };
    h.ze = function() {
        return new I( "[MAX_NAME]", K )
    };
    h.ye = function( a ) {
        x( p( a ), "KeyIndex indexValue must always be a string." );
        return new I( a, K )
    };
    h.toString = function() {
        return ".key"
    };
    var mc = new lc;

    function nc() {
        this.yc = this.na = this.nc = this.ga = this.ka = !1;
        this.xb = 0;
        this.Hb = "";
        this.Bc = null;
        this.Xb = "";
        this.Ac = null;
        this.Ub = "";
        this.m = L
    }
    var oc = new nc;

    function pc( a ) {
        x( a.ga, "Only valid if start has been set" );
        return a.Bc
    }

    function qc( a ) {
        x( a.ga, "Only valid if start has been set" );
        return a.nc ? a.Xb : "[MIN_NAME]"
    }

    function rc( a ) {
        x( a.na, "Only valid if end has been set" );
        return a.Ac
    }

    function sc( a ) {
        x( a.na, "Only valid if end has been set" );
        return a.yc ? a.Ub : "[MAX_NAME]"
    }

    function tc( a ) {
        x( a.ka, "Only valid if limit has been set" );
        return a.xb
    }

    function uc( a ) {
        var b = new nc;
        b.ka = a.ka;
        b.xb = a.xb;
        b.ga = a.ga;
        b.Bc = a.Bc;
        b.nc = a.nc;
        b.Xb = a.Xb;
        b.na = a.na;
        b.Ac = a.Ac;
        b.yc = a.yc;
        b.Ub = a.Ub;
        b.m = a.m;
        return b
    }
    h = nc.prototype;
    h.ve = function( a ) {
        var b = uc( this );
        b.ka = !0;
        b.xb = a;
        b.Hb = "";
        return b
    };
    h.we = function( a ) {
        var b = uc( this );
        b.ka = !0;
        b.xb = a;
        b.Hb = "l";
        return b
    };
    h.xe = function( a ) {
        var b = uc( this );
        b.ka = !0;
        b.xb = a;
        b.Hb = "r";
        return b
    };
    h.Md = function( a, b ) {
        var c = uc( this );
        c.ga = !0;
        c.Bc = a;
        null != b ? ( c.nc = !0, c.Xb = b ) : ( c.nc = !1, c.Xb = "" );
        return c
    };
    h.md = function( a, b ) {
        var c = uc( this );
        c.na = !0;
        c.Ac = a;
        n( b ) ? ( c.yc = !0, c.Ub = b ) : ( c.Dg = !1, c.Ub = "" );
        return c
    };

    function vc( a, b ) {
        var c = uc( a );
        c.m = b;
        return c
    }

    function wc( a ) {
        return !( a.ga || a.na || a.ka )
    };

    function M( a, b, c, d ) {
        this.g = a;
        this.path = b;
        this.w = c;
        this.dc = d
    }

    function xc( a ) {
        var b = null,
            c = null;
        a.ga && ( b = pc( a ) );
        a.na && ( c = rc( a ) );
        if ( a.m === mc ) {
            if ( a.ga ) {
                if ( "[MIN_NAME]" != qc( a ) ) throw Error( "Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo()." );
                if ( null != b && "string" !== typeof b ) throw Error( "Query: When ordering by key, the argument passed to startAt(), endAt(),or equalTo() must be a string." );
            }
            if ( a.na ) {
                if ( "[MAX_NAME]" != sc( a ) ) throw Error( "Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo()." );
                if ( null != c && "string" !== typeof c ) throw Error( "Query: When ordering by key, the argument passed to startAt(), endAt(),or equalTo() must be a string." );
            }
        } else if ( a.m === L ) {
            if ( null != b && !Rb( b ) || null != c && !Rb( c ) ) throw Error( "Query: When ordering by priority, the first argument passed to startAt(), endAt(), or equalTo() must be a valid priority value (null, a number, or a string)." );
        } else if ( x( a.m instanceof jc, "unknown index type." ), null != b && "object" === typeof b || null != c && "object" === typeof c ) throw Error( "Query: First argument passed to startAt(), endAt(), or equalTo() cannot be an object." );
    }

    function yc( a ) {
        if ( a.ga && a.na && a.ka && ( !a.ka || "" === a.Hb ) ) throw Error( "Query: Can't combine startAt(), endAt(), and limit(). Use limitToFirst() or limitToLast() instead." );
    }

    function zc( a, b ) {
        if ( !0 === a.dc ) throw Error( b + ": You can't combine multiple orderBy calls." );
    }
    M.prototype.hc = function() {
        D( "Query.ref", 0, 0, arguments.length );
        return new O( this.g, this.path )
    };
    M.prototype.ref = M.prototype.hc;
    M.prototype.zb = function( a, b, c, d ) {
        D( "Query.on", 2, 4, arguments.length );
        Xb( "Query.on", a, !1 );
        F( "Query.on", 2, b, !1 );
        var e = Ac( "Query.on", c, d );
        if ( "value" === a ) Bc( this.g, this, new Ib( b, e.cancel || null, e.Ha || null ) );
        else {
            var f = {};
            f[ a ] = b;
            Bc( this.g, this, new Jb( f, e.cancel, e.Ha ) )
        }
        return b
    };
    M.prototype.on = M.prototype.zb;
    M.prototype.bc = function( a, b, c ) {
        D( "Query.off", 0, 3, arguments.length );
        Xb( "Query.off", a, !0 );
        F( "Query.off", 2, b, !0 );
        Nb( "Query.off", 3, c );
        var d = null,
            e = null;
        "value" === a ? d = new Ib( b || null, null, c || null ) : a && ( b && ( e = {}, e[ a ] = b ), d = new Jb( e, null, c || null ) );
        e = this.g;
        d = ".info" === G( this.path ) ? e.ud.hb( this, d ) : e.M.hb( this, d );
        Cc( e.Z, this.path, d )
    };
    M.prototype.off = M.prototype.bc;
    M.prototype.gg = function( a, b ) {
        function c( g ) {
            f && ( f = !1, e.bc( a, c ), b.call( d.Ha, g ) )
        }
        D( "Query.once", 2, 4, arguments.length );
        Xb( "Query.once", a, !1 );
        F( "Query.once", 2, b, !1 );
        var d = Ac( "Query.once", arguments[ 2 ], arguments[ 3 ] ),
            e = this,
            f = !0;
        this.zb( a, c, function( b ) {
            e.bc( a, c );
            d.cancel && d.cancel.call( d.Ha, b )
        } )
    };
    M.prototype.once = M.prototype.gg;
    M.prototype.ve = function( a ) {
        z( "Query.limit() being deprecated. Please use Query.limitToFirst() or Query.limitToLast() instead." );
        D( "Query.limit", 1, 1, arguments.length );
        if ( !ga( a ) || Math.floor( a ) !== a || 0 >= a ) throw Error( "Query.limit: First argument must be a positive integer." );
        if ( this.w.ka ) throw Error( "Query.limit: Limit was already set (by another call to limit, limitToFirst, orlimitToLast." );
        var b = this.w.ve( a );
        yc( b );
        return new M( this.g, this.path, b, this.dc )
    };
    M.prototype.limit = M.prototype.ve;
    M.prototype.we = function( a ) {
        D( "Query.limitToFirst", 1, 1, arguments.length );
        if ( !ga( a ) || Math.floor( a ) !== a || 0 >= a ) throw Error( "Query.limitToFirst: First argument must be a positive integer." );
        if ( this.w.ka ) throw Error( "Query.limitToFirst: Limit was already set (by another call to limit, limitToFirst, or limitToLast)." );
        return new M( this.g, this.path, this.w.we( a ), this.dc )
    };
    M.prototype.limitToFirst = M.prototype.we;
    M.prototype.xe = function( a ) {
        D( "Query.limitToLast", 1, 1, arguments.length );
        if ( !ga( a ) || Math.floor( a ) !== a || 0 >= a ) throw Error( "Query.limitToLast: First argument must be a positive integer." );
        if ( this.w.ka ) throw Error( "Query.limitToLast: Limit was already set (by another call to limit, limitToFirst, or limitToLast)." );
        return new M( this.g, this.path, this.w.xe( a ), this.dc )
    };
    M.prototype.limitToLast = M.prototype.xe;
    M.prototype.hg = function( a ) {
        D( "Query.orderByChild", 1, 1, arguments.length );
        if ( "$key" === a ) throw Error( 'Query.orderByChild: "$key" is invalid.  Use Query.orderByKey() instead.' );
        if ( "$priority" === a ) throw Error( 'Query.orderByChild: "$priority" is invalid.  Use Query.orderByPriority() instead.' );
        Yb( "Query.orderByChild", 1, a, !1 );
        zc( this, "Query.orderByChild" );
        var b = vc( this.w, new jc( a ) );
        xc( b );
        return new M( this.g, this.path, b, !0 )
    };
    M.prototype.orderByChild = M.prototype.hg;
    M.prototype.ig = function() {
        D( "Query.orderByKey", 0, 0, arguments.length );
        zc( this, "Query.orderByKey" );
        var a = vc( this.w, mc );
        xc( a );
        return new M( this.g, this.path, a, !0 )
    };
    M.prototype.orderByKey = M.prototype.ig;
    M.prototype.jg = function() {
        D( "Query.orderByPriority", 0, 0, arguments.length );
        zc( this, "Query.orderByPriority" );
        var a = vc( this.w, L );
        xc( a );
        return new M( this.g, this.path, a, !0 )
    };
    M.prototype.orderByPriority = M.prototype.jg;
    M.prototype.Md = function( a, b ) {
        D( "Query.startAt", 0, 2, arguments.length );
        Sb( "Query.startAt", a, !0 );
        Yb( "Query.startAt", 2, b, !0 );
        var c = this.w.Md( a, b );
        yc( c );
        xc( c );
        if ( this.w.ga ) throw Error( "Query.startAt: Starting point was already set (by another call to startAt or equalTo)." );
        n( a ) || ( b = a = null );
        return new M( this.g, this.path, c, this.dc )
    };
    M.prototype.startAt = M.prototype.Md;
    M.prototype.md = function( a, b ) {
        D( "Query.endAt", 0, 2, arguments.length );
        Sb( "Query.endAt", a, !0 );
        Yb( "Query.endAt", 2, b, !0 );
        var c = this.w.md( a, b );
        yc( c );
        xc( c );
        if ( this.w.na ) throw Error( "Query.endAt: Ending point was already set (by another call to endAt or equalTo)." );
        return new M( this.g, this.path, c, this.dc )
    };
    M.prototype.endAt = M.prototype.md;
    M.prototype.Of = function( a, b ) {
        D( "Query.equalTo", 1, 2, arguments.length );
        Sb( "Query.equalTo", a, !1 );
        Yb( "Query.equalTo", 2, b, !0 );
        if ( this.w.ga ) throw Error( "Query.equalTo: Starting point was already set (by another call to endAt or equalTo)." );
        if ( this.w.na ) throw Error( "Query.equalTo: Ending point was already set (by another call to endAt or equalTo)." );
        return this.Md( a, b ).md( a, b )
    };
    M.prototype.equalTo = M.prototype.Of;

    function Dc( a ) {
        a = a.w;
        var b = {};
        a.ga && ( b.sp = a.Bc, a.nc && ( b.sn = a.Xb ) );
        a.na && ( b.ep = a.Ac, a.yc && ( b.en = a.Ub ) );
        if ( a.ka ) {
            b.l = a.xb;
            var c = a.Hb;
            "" === c && ( c = a.ga ? "l" : "r" );
            b.vf = c
        }
        a.m !== L && ( b.i = a.m.toString() );
        return b
    }
    M.prototype.Da = function() {
        var a = Ab( Dc( this ) );
        return "{}" === a ? "default" : a
    };

    function Ac( a, b, c ) {
        var d = {
            cancel: null,
            Ha: null
        };
        if ( b && c ) d.cancel = b, F( a, 3, d.cancel, !0 ), d.Ha = c, Nb( a, 4, d.Ha );
        else if ( b )
            if ( "object" === typeof b && null !== b ) d.Ha = b;
            else if ( "function" === typeof b ) d.cancel = b;
        else throw Error( E( a, 3, !0 ) + " must either be a cancel callback or a context object." );
        return d
    };

    function P( a, b ) {
        if ( 1 == arguments.length ) {
            this.n = a.split( "/" );
            for ( var c = 0, d = 0; d < this.n.length; d++ ) 0 < this.n[ d ].length && ( this.n[ c ] = this.n[ d ], c++ );
            this.n.length = c;
            this.aa = 0
        } else this.n = a, this.aa = b
    }

    function G( a ) {
        return a.aa >= a.n.length ? null : a.n[ a.aa ]
    }

    function Q( a ) {
        return a.n.length - a.aa
    }

    function R( a ) {
        var b = a.aa;
        b < a.n.length && b++;
        return new P( a.n, b )
    }
    P.prototype.toString = function() {
        for ( var a = "", b = this.aa; b < this.n.length; b++ ) "" !== this.n[ b ] && ( a += "/" + this.n[ b ] );
        return a || "/"
    };
    P.prototype.parent = function() {
        if ( this.aa >= this.n.length ) return null;
        for ( var a = [], b = this.aa; b < this.n.length - 1; b++ ) a.push( this.n[ b ] );
        return new P( a, 0 )
    };
    P.prototype.k = function( a ) {
        for ( var b = [], c = this.aa; c < this.n.length; c++ ) b.push( this.n[ c ] );
        if ( a instanceof P )
            for ( c = a.aa; c < a.n.length; c++ ) b.push( a.n[ c ] );
        else
            for ( a = a.split( "/" ), c = 0; c < a.length; c++ ) 0 < a[ c ].length && b.push( a[ c ] );
        return new P( b, 0 )
    };
    P.prototype.e = function() {
        return this.aa >= this.n.length
    };
    var S = new P( "" );

    function T( a, b ) {
        var c = G( a );
        if ( null === c ) return b;
        if ( c === G( b ) ) return T( R( a ), R( b ) );
        throw Error( "INTERNAL ERROR: innerPath (" + b + ") is not within outerPath (" + a + ")" );
    }
    P.prototype.ja = function( a ) {
        if ( Q( this ) !== Q( a ) ) return !1;
        for ( var b = this.aa, c = a.aa; b <= this.n.length; b++, c++ )
            if ( this.n[ b ] !== a.n[ c ] ) return !1;
        return !0
    };
    P.prototype.contains = function( a ) {
        var b = this.aa,
            c = a.aa;
        if ( Q( this ) > Q( a ) ) return !1;
        for ( ; b < this.n.length; ) {
            if ( this.n[ b ] !== a.n[ c ] ) return !1;
            ++b;
            ++c
        }
        return !0
    };

    function Ec() {
        this.children = {};
        this.dd = 0;
        this.value = null
    }

    function Fc( a, b, c ) {
        this.yd = a ? a : "";
        this.Oc = b ? b : null;
        this.D = c ? c : new Ec
    }

    function Gc( a, b ) {
        for ( var c = b instanceof P ? b : new P( b ), d = a, e; null !== ( e = G( c ) ); ) d = new Fc( e, d, v( d.D.children, e ) || new Ec ), c = R( c );
        return d
    }
    h = Fc.prototype;
    h.ta = function() {
        return this.D.value
    };

    function Hc( a, b ) {
        x( "undefined" !== typeof b, "Cannot set value to undefined" );
        a.D.value = b;
        Ic( a )
    }
    h.clear = function() {
        this.D.value = null;
        this.D.children = {};
        this.D.dd = 0;
        Ic( this )
    };
    h.pd = function() {
        return 0 < this.D.dd
    };
    h.e = function() {
        return null === this.ta() && !this.pd()
    };
    h.ca = function( a ) {
        var b = this;
        A( this.D.children, function( c, d ) {
            a( new Fc( d, b, c ) )
        } )
    };

    function Jc( a, b, c, d ) {
        c && !d && b( a );
        a.ca( function( a ) {
            Jc( a, b, !0, d )
        } );
        c && d && b( a )
    }

    function Kc( a, b ) {
        for ( var c = a.parent(); null !== c && !b( c ); ) c = c.parent()
    }
    h.path = function() {
        return new P( null === this.Oc ? this.yd : this.Oc.path() + "/" + this.yd )
    };
    h.name = function() {
        return this.yd
    };
    h.parent = function() {
        return this.Oc
    };

    function Ic( a ) {
        if ( null !== a.Oc ) {
            var b = a.Oc,
                c = a.yd,
                d = a.e(),
                e = u( b.D.children, c );
            d && e ? ( delete b.D.children[ c ], b.D.dd--, Ic( b ) ) : d || e || ( b.D.children[ c ] = a.D, b.D.dd++, Ic( b ) )
        }
    };

    function Lc( a, b ) {
        this.Ga = a;
        this.pa = b ? b : Mc
    }
    h = Lc.prototype;
    h.Ja = function( a, b ) {
        return new Lc( this.Ga, this.pa.Ja( a, b, this.Ga ).W( null, null, !1, null, null ) )
    };
    h.remove = function( a ) {
        return new Lc( this.Ga, this.pa.remove( a, this.Ga ).W( null, null, !1, null, null ) )
    };
    h.get = function( a ) {
        for ( var b, c = this.pa; !c.e(); ) {
            b = this.Ga( a, c.key );
            if ( 0 === b ) return c.value;
            0 > b ? c = c.left : 0 < b && ( c = c.right )
        }
        return null
    };

    function Nc( a, b ) {
        for ( var c, d = a.pa, e = null; !d.e(); ) {
            c = a.Ga( b, d.key );
            if ( 0 === c ) {
                if ( d.left.e() ) return e ? e.key : null;
                for ( d = d.left; !d.right.e(); ) d = d.right;
                return d.key
            }
            0 > c ? d = d.left : 0 < c && ( e = d, d = d.right )
        }
        throw Error( "Attempted to find predecessor key for a nonexistent key.  What gives?" );
    }
    h.e = function() {
        return this.pa.e()
    };
    h.count = function() {
        return this.pa.count()
    };
    h.Ic = function() {
        return this.pa.Ic()
    };
    h.Zb = function() {
        return this.pa.Zb()
    };
    h.Ba = function( a ) {
        return this.pa.Ba( a )
    };
    h.Aa = function( a ) {
        return new Oc( this.pa, null, this.Ga, !1, a )
    };
    h.rb = function( a, b ) {
        return new Oc( this.pa, a, this.Ga, !1, b )
    };
    h.Sb = function( a, b ) {
        return new Oc( this.pa, a, this.Ga, !0, b )
    };
    h.bf = function( a ) {
        return new Oc( this.pa, null, this.Ga, !0, a )
    };

    function Oc( a, b, c, d, e ) {
        this.qf = e || null;
        this.te = d;
        this.ac = [];
        for ( e = 1; !a.e(); )
            if ( e = b ? c( a.key, b ) : 1, d && ( e *= -1 ), 0 > e ) a = this.te ? a.left : a.right;
            else if ( 0 === e ) {
            this.ac.push( a );
            break
        } else this.ac.push( a ), a = this.te ? a.right : a.left
    }

    function U( a ) {
        if ( 0 === a.ac.length ) return null;
        var b = a.ac.pop(),
            c;
        c = a.qf ? a.qf( b.key, b.value ) : {
            key: b.key,
            value: b.value
        };
        if ( a.te )
            for ( b = b.left; !b.e(); ) a.ac.push( b ), b = b.right;
        else
            for ( b = b.right; !b.e(); ) a.ac.push( b ), b = b.left;
        return c
    }

    function Pc( a, b, c, d, e ) {
        this.key = a;
        this.value = b;
        this.color = null != c ? c : !0;
        this.left = null != d ? d : Mc;
        this.right = null != e ? e : Mc
    }
    h = Pc.prototype;
    h.W = function( a, b, c, d, e ) {
        return new Pc( null != a ? a : this.key, null != b ? b : this.value, null != c ? c : this.color, null != d ? d : this.left, null != e ? e : this.right )
    };
    h.count = function() {
        return this.left.count() + 1 + this.right.count()
    };
    h.e = function() {
        return !1
    };
    h.Ba = function( a ) {
        return this.left.Ba( a ) || a( this.key, this.value ) || this.right.Ba( a )
    };

    function Qc( a ) {
        return a.left.e() ? a : Qc( a.left )
    }
    h.Ic = function() {
        return Qc( this ).key
    };
    h.Zb = function() {
        return this.right.e() ? this.key : this.right.Zb()
    };
    h.Ja = function( a, b, c ) {
        var d, e;
        e = this;
        d = c( a, e.key );
        e = 0 > d ? e.W( null, null, null, e.left.Ja( a, b, c ), null ) : 0 === d ? e.W( null, b, null, null, null ) : e.W( null, null, null, null, e.right.Ja( a, b, c ) );
        return Rc( e )
    };

    function Sc( a ) {
        if ( a.left.e() ) return Mc;
        a.left.$() || a.left.left.$() || ( a = Tc( a ) );
        a = a.W( null, null, null, Sc( a.left ), null );
        return Rc( a )
    }
    h.remove = function( a, b ) {
        var c, d;
        c = this;
        if ( 0 > b( a, c.key ) ) c.left.e() || c.left.$() || c.left.left.$() || ( c = Tc( c ) ), c = c.W( null, null, null, c.left.remove( a, b ), null );
        else {
            c.left.$() && ( c = Uc( c ) );
            c.right.e() || c.right.$() || c.right.left.$() || ( c = Vc( c ), c.left.left.$() && ( c = Uc( c ), c = Vc( c ) ) );
            if ( 0 === b( a, c.key ) ) {
                if ( c.right.e() ) return Mc;
                d = Qc( c.right );
                c = c.W( d.key, d.value, null, null, Sc( c.right ) )
            }
            c = c.W( null, null, null, null, c.right.remove( a, b ) )
        }
        return Rc( c )
    };
    h.$ = function() {
        return this.color
    };

    function Rc( a ) {
        a.right.$() && !a.left.$() && ( a = Wc( a ) );
        a.left.$() && a.left.left.$() && ( a = Uc( a ) );
        a.left.$() && a.right.$() && ( a = Vc( a ) );
        return a
    }

    function Tc( a ) {
        a = Vc( a );
        a.right.left.$() && ( a = a.W( null, null, null, null, Uc( a.right ) ), a = Wc( a ), a = Vc( a ) );
        return a
    }

    function Wc( a ) {
        return a.right.W( null, null, a.color, a.W( null, null, !0, null, a.right.left ), null )
    }

    function Uc( a ) {
        return a.left.W( null, null, a.color, null, a.W( null, null, !0, a.left.right, null ) )
    }

    function Vc( a ) {
        return a.W( null, null, !a.color, a.left.W( null, null, !a.left.color, null, null ), a.right.W( null, null, !a.right.color, null, null ) )
    }

    function Xc() {}
    h = Xc.prototype;
    h.W = function() {
        return this
    };
    h.Ja = function( a, b ) {
        return new Pc( a, b, null )
    };
    h.remove = function() {
        return this
    };
    h.count = function() {
        return 0
    };
    h.e = function() {
        return !0
    };
    h.Ba = function() {
        return !1
    };
    h.Ic = function() {
        return null
    };
    h.Zb = function() {
        return null
    };
    h.$ = function() {
        return !1
    };
    var Mc = new Xc;

    function I( a, b ) {
        this.name = a;
        this.K = b
    }

    function Yc( a, b ) {
        return new I( a, b )
    };

    function Zc( a, b ) {
        this.A = a;
        x( null !== this.A, "LeafNode shouldn't be created with null value." );
        this.fa = b || K;
        $c( this.fa );
        this.wb = null
    }
    h = Zc.prototype;
    h.P = function() {
        return !0
    };
    h.O = function() {
        return this.fa
    };
    h.ib = function( a ) {
        return new Zc( this.A, a )
    };
    h.B = function( a ) {
        return ".priority" === a ? this.fa : K
    };
    h.da = function( a ) {
        return a.e() ? this : ".priority" === G( a ) ? this.fa : K
    };
    h.Y = function() {
        return !1
    };
    h.af = function() {
        return null
    };
    h.I = function( a, b ) {
        return ".priority" === a ? this.ib( b ) : K.I( a, b ).ib( this.fa )
    };
    h.L = function( a, b ) {
        var c = G( a );
        if ( null === c ) return b;
        x( ".priority" !== c || 1 === Q( a ), ".priority must be the last token in a path" );
        return this.I( c, K.L( R( a ), b ) )
    };
    h.e = function() {
        return !1
    };
    h.Ua = function() {
        return 0
    };
    h.N = function( a ) {
        return a && !this.O().e() ? {
            ".value": this.ta(),
            ".priority": this.O().N()
        } : this.ta()
    };
    h.hash = function() {
        if ( null === this.wb ) {
            var a = "";
            this.fa.e() || ( a += "priority:" + ad( this.fa.N() ) + ":" );
            var b = typeof this.A,
                a = a + ( b + ":" ),
                a = "number" === b ? a + Db( this.A ) : a + this.A;
            this.wb = lb( a )
        }
        return this.wb
    };
    h.ta = function() {
        return this.A
    };
    h.he = function( a ) {
        if ( a === K ) return 1;
        if ( a instanceof bd ) return -1;
        x( a.P(), "Unknown node type" );
        var b = typeof a.A,
            c = typeof this.A,
            d = Ia( cd, b ),
            e = Ia( cd, c );
        x( 0 <= d, "Unknown leaf type: " + b );
        x( 0 <= e, "Unknown leaf type: " + c );
        return d === e ? "object" === c ? 0 : this.A < a.A ? -1 : this.A === a.A ? 0 : 1 : e - d
    };
    var cd = [ "object", "boolean", "number", "string" ];
    Zc.prototype.Wd = function() {
        return this
    };
    Zc.prototype.Yb = function() {
        return !0
    };
    Zc.prototype.ja = function( a ) {
        return a === this ? !0 : a.P() ? this.A === a.A && this.fa.ja( a.fa ) : !1
    };
    Zc.prototype.toString = function() {
        return "string" === typeof this.A ? this.A : '"' + this.A + '"'
    };

    function dd( a, b ) {
        this.td = a;
        this.Wb = b
    }
    dd.prototype.get = function( a ) {
        var b = v( this.td, a );
        if ( !b ) throw Error( "No index defined for " + a );
        return b === hc ? null : b
    };

    function ed( a, b, c ) {
        var d = fd( a.td, function( d, f ) {
            var g = v( a.Wb, f );
            x( g, "Missing index implementation for " + f );
            if ( d === hc ) {
                if ( g.se( b.K ) ) {
                    for ( var k = [], l = c.Aa( Yc ), m = U( l ); m; ) m.name != b.name && k.push( m ), m = U( l );
                    k.push( b );
                    return gd( k, H( g ) )
                }
                return hc
            }
            g = c.get( b.name );
            k = d;
            g && ( k = k.remove( new I( b.name, g ) ) );
            return k.Ja( b, b.K )
        } );
        return new dd( d, a.Wb )
    }

    function hd( a, b, c ) {
        var d = fd( a.td, function( a ) {
            if ( a === hc ) return a;
            var d = c.get( b.name );
            return d ? a.remove( new I( b.name, d ) ) : a
        } );
        return new dd( d, a.Wb )
    }
    var id = new dd( {
        ".priority": hc
    }, {
        ".priority": L
    } );

    function bd( a, b, c ) {
        this.j = a;
        ( this.fa = b ) && $c( this.fa );
        this.sb = c;
        this.wb = null
    }
    h = bd.prototype;
    h.P = function() {
        return !1
    };
    h.O = function() {
        return this.fa || K
    };
    h.ib = function( a ) {
        return new bd( this.j, a, this.sb )
    };
    h.B = function( a ) {
        if ( ".priority" === a ) return this.O();
        a = this.j.get( a );
        return null === a ? K : a
    };
    h.da = function( a ) {
        var b = G( a );
        return null === b ? this : this.B( b ).da( R( a ) )
    };
    h.Y = function( a ) {
        return null !== this.j.get( a )
    };
    h.I = function( a, b ) {
        x( b, "We should always be passing snapshot nodes" );
        if ( ".priority" === a ) return this.ib( b );
        var c = new I( a, b ),
            d;
        b.e() ? ( d = this.j.remove( a ), c = hd( this.sb, c, this.j ) ) : ( d = this.j.Ja( a, b ), c = ed( this.sb, c, this.j ) );
        return new bd( d, this.fa, c )
    };
    h.L = function( a, b ) {
        var c = G( a );
        if ( null === c ) return b;
        x( ".priority" !== G( a ) || 1 === Q( a ), ".priority must be the last token in a path" );
        var d = this.B( c ).L( R( a ), b );
        return this.I( c, d )
    };
    h.e = function() {
        return this.j.e()
    };
    h.Ua = function() {
        return this.j.count()
    };
    var jd = /^(0|[1-9]\d*)$/;
    h = bd.prototype;
    h.N = function( a ) {
        if ( this.e() ) return null;
        var b = {},
            c = 0,
            d = 0,
            e = !0;
        this.ca( L, function( f, g ) {
            b[ f ] = g.N( a );
            c++;
            e && jd.test( f ) ? d = Math.max( d, Number( f ) ) : e = !1
        } );
        if ( !a && e && d < 2 * c ) {
            var f = [],
                g;
            for ( g in b ) f[ g ] = b[ g ];
            return f
        }
        a && !this.O().e() && ( b[ ".priority" ] = this.O().N() );
        return b
    };
    h.hash = function() {
        if ( null === this.wb ) {
            var a = "";
            this.O().e() || ( a += "priority:" + ad( this.O().N() ) + ":" );
            this.ca( L, function( b, c ) {
                var d = c.hash();
                "" !== d && ( a += ":" + b + ":" + d )
            } );
            this.wb = "" === a ? "" : lb( a )
        }
        return this.wb
    };
    h.af = function( a, b, c ) {
        return ( c = kd( this, c ) ) ? ( a = Nc( c, new I( a, b ) ) ) ? a.name : null : Nc( this.j, a )
    };

    function ld( a, b ) {
        var c;
        c = ( c = kd( a, b ) ) ? ( c = c.Ic() ) && c.name : a.j.Ic();
        return c ? new I( c, a.j.get( c ) ) : null
    }

    function md( a, b ) {
        var c;
        c = ( c = kd( a, b ) ) ? ( c = c.Zb() ) && c.name : a.j.Zb();
        return c ? new I( c, a.j.get( c ) ) : null
    }
    h.ca = function( a, b ) {
        var c = kd( this, a );
        return c ? c.Ba( function( a ) {
            return b( a.name, a.K )
        } ) : this.j.Ba( b )
    };
    h.Aa = function( a ) {
        return this.rb( a.Ae(), a )
    };
    h.rb = function( a, b ) {
        var c = kd( this, b );
        return c ? c.rb( a, function( a ) {
            return a
        } ) : this.j.rb( a.name, Yc )
    };
    h.bf = function( a ) {
        return this.Sb( a.ze(), a )
    };
    h.Sb = function( a, b ) {
        var c = kd( this, b );
        return c ? c.Sb( a, function( a ) {
            return a
        } ) : this.j.Sb( a.name, Yc )
    };
    h.he = function( a ) {
        return this.e() ? a.e() ? 0 : -1 : a.P() || a.e() ? 1 : a === kc ? -1 : 0
    };
    h.Wd = function( a ) {
        if ( a === mc || nd( this.sb.Wb, a.toString() ) ) return this;
        var b = this.sb,
            c = this.j;
        x( a !== mc, "KeyIndex always exists and isn't meant to be added to the IndexMap." );
        for ( var d = [], e = !1, c = c.Aa( Yc ), f = U( c ); f; ) e = e || a.se( f.K ), d.push( f ), f = U( c );
        d = e ? gd( d, H( a ) ) : hc;
        e = a.toString();
        c = od( b.Wb );
        c[ e ] = a;
        a = od( b.td );
        a[ e ] = d;
        return new bd( this.j, this.fa, new dd( a, c ) )
    };
    h.Yb = function( a ) {
        return a === mc || nd( this.sb.Wb, a.toString() )
    };
    h.ja = function( a ) {
        if ( a === this ) return !0;
        if ( a.P() ) return !1;
        if ( this.O().ja( a.O() ) && this.j.count() === a.j.count() ) {
            var b = this.Aa( L );
            a = a.Aa( L );
            for ( var c = U( b ), d = U( a ); c && d; ) {
                if ( c.name !== d.name || !c.K.ja( d.K ) ) return !1;
                c = U( b );
                d = U( a )
            }
            return null === c && null === d
        }
        return !1
    };

    function kd( a, b ) {
        return b === mc ? null : a.sb.get( b.toString() )
    }
    h.toString = function() {
        var a = "{",
            b = !0;
        this.ca( L, function( c, d ) {
            b ? b = !1 : a += ", ";
            a += '"' + c + '" : ' + d.toString()
        } );
        return a += "}"
    };

    function J( a, b ) {
        if ( null === a ) return K;
        var c = null;
        "object" === typeof a && ".priority" in a ? c = a[ ".priority" ] : "undefined" !== typeof b && ( c = b );
        x( null === c || "string" === typeof c || "number" === typeof c || "object" === typeof c && ".sv" in c, "Invalid priority type found: " + typeof c );
        "object" === typeof a && ".value" in a && null !== a[ ".value" ] && ( a = a[ ".value" ] );
        if ( "object" !== typeof a || ".sv" in a ) return new Zc( a, J( c ) );
        if ( a instanceof Array ) {
            var d = K,
                e = a;
            A( e, function( a, b ) {
                if ( u( e, b ) && "." !== b.substring( 0, 1 ) ) {
                    var c = J( a );
                    if ( c.P() || !c.e() ) d = d.I( b, c )
                }
            } );
            return d.ib( J( c ) )
        }
        var f = [],
            g = !1,
            k = a;
        va( k, function( a ) {
            if ( "string" !== typeof a || "." !== a.substring( 0, 1 ) ) {
                var b = J( k[ a ] );
                b.e() || ( g = g || !b.O().e(), f.push( new I( a, b ) ) )
            }
        } );
        var l = gd( f, ec, function( a ) {
            return a.name
        }, fc );
        if ( g ) {
            var m = gd( f, H( L ) );
            return new bd( l, J( c ), new dd( {
                ".priority": m
            }, {
                ".priority": L
            } ) )
        }
        return new bd( l, J( c ), id )
    }
    var pd = Math.log( 2 );

    function qd( a ) {
        this.count = parseInt( Math.log( a + 1 ) / pd, 10 );
        this.Ve = this.count - 1;
        this.Jf = a + 1 & parseInt( Array( this.count + 1 ).join( "1" ), 2 )
    }

    function rd( a ) {
        var b = !( a.Jf & 1 << a.Ve );
        a.Ve--;
        return b
    }

    function gd( a, b, c, d ) {
        function e( b, d ) {
            var f = d - b;
            if ( 0 == f ) return null;
            if ( 1 == f ) {
                var m = a[ b ],
                    r = c ? c( m ) : m;
                return new Pc( r, m.K, !1, null, null )
            }
            var m = parseInt( f / 2, 10 ) + b,
                f = e( b, m ),
                s = e( m + 1, d ),
                m = a[ m ],
                r = c ? c( m ) : m;
            return new Pc( r, m.K, !1, f, s )
        }
        a.sort( b );
        var f = function( b ) {
            function d( b, g ) {
                var k = r - b,
                    s = r;
                r -= b;
                var s = e( k + 1, s ),
                    k = a[ k ],
                    y = c ? c( k ) : k,
                    s = new Pc( y, k.K, g, null, s );
                f ? f.left = s : m = s;
                f = s
            }
            for ( var f = null, m = null, r = a.length, s = 0; s < b.count; ++s ) {
                var y = rd( b ),
                    N = Math.pow( 2, b.count - ( s + 1 ) );
                y ? d( N, !1 ) : ( d( N, !1 ), d( N, !0 ) )
            }
            return m
        }( new qd( a.length ) );
        return null !== f ? new Lc( d || b, f ) : new Lc( d || b )
    }

    function ad( a ) {
        return "number" === typeof a ? "number:" + Db( a ) : "string:" + a
    }

    function $c( a ) {
        if ( a.P() ) {
            var b = a.N();
            x( "string" === typeof b || "number" === typeof b || "object" === typeof b && u( b, ".sv" ), "Priority must be a string or number." )
        } else x( a === kc || a.e(), "priority of unexpected type." );
        x( a === kc || a.O().e(), "Priority nodes can't have a priority of their own." )
    }
    var K = new bd( new Lc( fc ), null, id );

    function sd() {
        bd.call( this, new Lc( fc ), K, id )
    }
    na( sd, bd );
    h = sd.prototype;
    h.he = function( a ) {
        return a === this ? 0 : 1
    };
    h.ja = function( a ) {
        return a === this
    };
    h.O = function() {
        throw ib( "Why is this called?" );
    };
    h.B = function() {
        return K
    };
    h.e = function() {
        return !1
    };
    var kc = new sd,
        ic = new I( "[MIN_NAME]", K );

    function C( a, b, c ) {
        this.D = a;
        this.U = b;
        this.m = c
    }
    C.prototype.N = function() {
        D( "Firebase.DataSnapshot.val", 0, 0, arguments.length );
        return this.D.N()
    };
    C.prototype.val = C.prototype.N;
    C.prototype.Xe = function() {
        D( "Firebase.DataSnapshot.exportVal", 0, 0, arguments.length );
        return this.D.N( !0 )
    };
    C.prototype.exportVal = C.prototype.Xe;
    C.prototype.Qf = function() {
        D( "Firebase.DataSnapshot.exists", 0, 0, arguments.length );
        return !this.D.e()
    };
    C.prototype.exists = C.prototype.Qf;
    C.prototype.k = function( a ) {
        D( "Firebase.DataSnapshot.child", 0, 1, arguments.length );
        ga( a ) && ( a = String( a ) );
        Zb( "Firebase.DataSnapshot.child", a );
        var b = new P( a ),
            c = this.U.k( b );
        return new C( this.D.da( b ), c, L )
    };
    C.prototype.child = C.prototype.k;
    C.prototype.Y = function( a ) {
        D( "Firebase.DataSnapshot.hasChild", 1, 1, arguments.length );
        Zb( "Firebase.DataSnapshot.hasChild", a );
        var b = new P( a );
        return !this.D.da( b ).e()
    };
    C.prototype.hasChild = C.prototype.Y;
    C.prototype.O = function() {
        D( "Firebase.DataSnapshot.getPriority", 0, 0, arguments.length );
        return this.D.O().N()
    };
    C.prototype.getPriority = C.prototype.O;
    C.prototype.forEach = function( a ) {
        D( "Firebase.DataSnapshot.forEach", 1, 1, arguments.length );
        F( "Firebase.DataSnapshot.forEach", 1, a, !1 );
        if ( this.D.P() ) return !1;
        var b = this;
        return !!this.D.ca( this.m, function( c, d ) {
            return a( new C( d, b.U.k( c ), L ) )
        } )
    };
    C.prototype.forEach = C.prototype.forEach;
    C.prototype.pd = function() {
        D( "Firebase.DataSnapshot.hasChildren", 0, 0, arguments.length );
        return this.D.P() ? !1 : !this.D.e()
    };
    C.prototype.hasChildren = C.prototype.pd;
    C.prototype.name = function() {
        z( "Firebase.DataSnapshot.name() being deprecated. Please use Firebase.DataSnapshot.key() instead." );
        D( "Firebase.DataSnapshot.name", 0, 0, arguments.length );
        return this.key()
    };
    C.prototype.name = C.prototype.name;
    C.prototype.key = function() {
        D( "Firebase.DataSnapshot.key", 0, 0, arguments.length );
        return this.U.key()
    };
    C.prototype.key = C.prototype.key;
    C.prototype.Ua = function() {
        D( "Firebase.DataSnapshot.numChildren", 0, 0, arguments.length );
        return this.D.Ua()
    };
    C.prototype.numChildren = C.prototype.Ua;
    C.prototype.hc = function() {
        D( "Firebase.DataSnapshot.ref", 0, 0, arguments.length );
        return this.U
    };
    C.prototype.ref = C.prototype.hc;

    function td( a ) {
        x( ea( a ) && 0 < a.length, "Requires a non-empty array" );
        this.Bf = a;
        this.Gc = {}
    }
    td.prototype.Td = function( a, b ) {
        for ( var c = this.Gc[ a ] || [], d = 0; d < c.length; d++ ) c[ d ].sc.apply( c[ d ].Ha, Array.prototype.slice.call( arguments, 1 ) )
    };
    td.prototype.zb = function( a, b, c ) {
        ud( this, a );
        this.Gc[ a ] = this.Gc[ a ] || [];
        this.Gc[ a ].push( {
            sc: b,
            Ha: c
        } );
        ( a = this.pe( a ) ) && b.apply( c, a )
    };
    td.prototype.bc = function( a, b, c ) {
        ud( this, a );
        a = this.Gc[ a ] || [];
        for ( var d = 0; d < a.length; d++ )
            if ( a[ d ].sc === b && ( !c || c === a[ d ].Ha ) ) {
                a.splice( d, 1 );
                break
            }
    };

    function ud( a, b ) {
        x( Oa( a.Bf, function( a ) {
            return a === b
        } ), "Unknown event: " + b )
    };

    function vd() {
        td.call( this, [ "visible" ] );
        var a, b;
        "undefined" !== typeof document && "undefined" !== typeof document.addEventListener && ( "undefined" !== typeof document.hidden ? ( b = "visibilitychange", a = "hidden" ) : "undefined" !== typeof document.mozHidden ? ( b = "mozvisibilitychange", a = "mozHidden" ) : "undefined" !== typeof document.msHidden ? ( b = "msvisibilitychange", a = "msHidden" ) : "undefined" !== typeof document.webkitHidden && ( b = "webkitvisibilitychange", a = "webkitHidden" ) );
        this.qc = !0;
        if ( b ) {
            var c = this;
            document.addEventListener( b, function() {
                var b = !document[ a ];
                b !== c.qc && ( c.qc = b, c.Td( "visible", b ) )
            }, !1 )
        }
    }
    na( vd, td );
    ca( vd );
    vd.prototype.pe = function( a ) {
        x( "visible" === a, "Unknown event type: " + a );
        return [ this.qc ]
    };

    function wd() {
        td.call( this, [ "online" ] );
        this.Lc = !0;
        if ( "undefined" !== typeof window && "undefined" !== typeof window.addEventListener ) {
            var a = this;
            window.addEventListener( "online", function() {
                a.Lc || a.Td( "online", !0 );
                a.Lc = !0
            }, !1 );
            window.addEventListener( "offline", function() {
                a.Lc && a.Td( "online", !1 );
                a.Lc = !1
            }, !1 )
        }
    }
    na( wd, td );
    ca( wd );
    wd.prototype.pe = function( a ) {
        x( "online" === a, "Unknown event type: " + a );
        return [ this.Lc ]
    };

    function A( a, b ) {
        for ( var c in a ) b.call( void 0, a[ c ], c, a )
    }

    function fd( a, b ) {
        var c = {},
            d;
        for ( d in a ) c[ d ] = b.call( void 0, a[ d ], d, a );
        return c
    }

    function Mb( a, b ) {
        for ( var c in a )
            if ( !b.call( void 0, a[ c ], c, a ) ) return !1;
        return !0
    }

    function Kb( a ) {
        var b = 0,
            c;
        for ( c in a ) b++;
        return b
    }

    function Lb( a ) {
        for ( var b in a ) return b
    }

    function xd( a ) {
        var b = [],
            c = 0,
            d;
        for ( d in a ) b[ c++ ] = a[ d ];
        return b
    }

    function yd( a ) {
        var b = [],
            c = 0,
            d;
        for ( d in a ) b[ c++ ] = d;
        return b
    }

    function nd( a, b ) {
        for ( var c in a )
            if ( a[ c ] == b ) return !0;
        return !1
    }

    function zd( a, b, c ) {
        for ( var d in a )
            if ( b.call( c, a[ d ], d, a ) ) return d
    }

    function Ad( a, b ) {
        var c = zd( a, b, void 0 );
        return c && a[ c ]
    }

    function Bd( a ) {
        for ( var b in a ) return !1;
        return !0
    }

    function Cd( a, b ) {
        return b in a ? a[ b ] : void 0
    }

    function od( a ) {
        var b = {},
            c;
        for ( c in a ) b[ c ] = a[ c ];
        return b
    }
    var Dd = "constructor hasOwnProperty isPrototypeOf propertyIsEnumerable toLocaleString toString valueOf".split( " " );

    function Ed( a, b ) {
        for ( var c, d, e = 1; e < arguments.length; e++ ) {
            d = arguments[ e ];
            for ( c in d ) a[ c ] = d[ c ];
            for ( var f = 0; f < Dd.length; f++ ) c = Dd[ f ], Object.prototype.hasOwnProperty.call( d, c ) && ( a[ c ] = d[ c ] )
        }
    };

    function Fd() {
        this.wc = {}
    }

    function Gd( a, b, c ) {
        n( c ) || ( c = 1 );
        u( a.wc, b ) || ( a.wc[ b ] = 0 );
        a.wc[ b ] += c
    }
    Fd.prototype.get = function() {
        return od( this.wc )
    };

    function Hd( a ) {
        this.Kf = a;
        this.vd = null
    }
    Hd.prototype.get = function() {
        var a = this.Kf.get(),
            b = od( a );
        if ( this.vd )
            for ( var c in this.vd ) b[ c ] -= this.vd[ c ];
        this.vd = a;
        return b
    };

    function Id( a, b ) {
        this.uf = {};
        this.Nd = new Hd( a );
        this.S = b;
        var c = 1E4 + 2E4 * Math.random();
        setTimeout( q( this.nf, this ), Math.floor( c ) )
    }
    Id.prototype.nf = function() {
        var a = this.Nd.get(),
            b = {},
            c = !1,
            d;
        for ( d in a ) 0 < a[ d ] && u( this.uf, d ) && ( b[ d ] = a[ d ], c = !0 );
        c && ( a = this.S, a.ia && ( b = {
            c: b
        }, a.f( "reportStats", b ), a.wa( "s", b ) ) );
        setTimeout( q( this.nf, this ), Math.floor( 6E5 * Math.random() ) )
    };
    var Jd = {},
        Kd = {};

    function Ld( a ) {
        a = a.toString();
        Jd[ a ] || ( Jd[ a ] = new Fd );
        return Jd[ a ]
    }

    function Md( a, b ) {
        var c = a.toString();
        Kd[ c ] || ( Kd[ c ] = b() );
        return Kd[ c ]
    };
    var Nd = null;
    "undefined" !== typeof MozWebSocket ? Nd = MozWebSocket : "undefined" !== typeof WebSocket && ( Nd = WebSocket );

    function Od( a, b, c ) {
        this.ie = a;
        this.f = rb( this.ie );
        this.frames = this.Cc = null;
        this.kb = this.lb = this.Oe = 0;
        this.Qa = Ld( b );
        this.Za = ( b.Cb ? "wss://" : "ws://" ) + b.Ka + "/.ws?v=5";
        "undefined" !== typeof location && location.href && -1 !== location.href.indexOf( "firebaseio.com" ) && ( this.Za += "&r=f" );
        b.host !== b.Ka && ( this.Za = this.Za + "&ns=" + b.yb );
        c && ( this.Za = this.Za + "&s=" + c )
    }
    var Pd;
    Od.prototype.open = function( a, b ) {
        this.fb = b;
        this.cg = a;
        this.f( "Websocket connecting to " + this.Za );
        this.zc = !1;
        Aa.set( "previous_websocket_failure", !0 );
        try {
            this.oa = new Nd( this.Za )
        } catch ( c ) {
            this.f( "Error instantiating WebSocket." );
            var d = c.message || c.data;
            d && this.f( d );
            this.eb();
            return
        }
        var e = this;
        this.oa.onopen = function() {
            e.f( "Websocket connected." );
            e.zc = !0
        };
        this.oa.onclose = function() {
            e.f( "Websocket connection was disconnected." );
            e.oa = null;
            e.eb()
        };
        this.oa.onmessage = function( a ) {
            if ( null !== e.oa )
                if ( a = a.data, e.kb += a.length, Gd( e.Qa, "bytes_received", a.length ), Qd( e ), null !== e.frames ) Rd( e, a );
                else {
                    a: {
                        x( null === e.frames, "We already have a frame buffer" );
                        if ( 6 >= a.length ) {
                            var b = Number( a );
                            if ( !isNaN( b ) ) {
                                e.Oe = b;
                                e.frames = [];
                                a = null;
                                break a
                            }
                        }
                        e.Oe = 1;
                        e.frames = []
                    }
                    null !== a && Rd( e, a )
                }
        };
        this.oa.onerror = function( a ) {
            e.f( "WebSocket error.  Closing connection." );
            ( a = a.message || a.data ) && e.f( a );
            e.eb()
        }
    };
    Od.prototype.start = function() {};
    Od.isAvailable = function() {
        var a = !1;
        if ( "undefined" !== typeof navigator && navigator.userAgent ) {
            var b = navigator.userAgent.match( /Android ([0-9]{0,}\.[0-9]{0,})/ );
            b && 1 < b.length && 4.4 > parseFloat( b[ 1 ] ) && ( a = !0 )
        }
        return !a && null !== Nd && !Pd
    };
    Od.responsesRequiredToBeHealthy = 2;
    Od.healthyTimeout = 3E4;
    h = Od.prototype;
    h.wd = function() {
        Aa.remove( "previous_websocket_failure" )
    };

    function Rd( a, b ) {
        a.frames.push( b );
        if ( a.frames.length == a.Oe ) {
            var c = a.frames.join( "" );
            a.frames = null;
            c = ua( c );
            a.cg( c )
        }
    }
    h.send = function( a ) {
        Qd( this );
        a = t( a );
        this.lb += a.length;
        Gd( this.Qa, "bytes_sent", a.length );
        a = Bb( a, 16384 );
        1 < a.length && this.oa.send( String( a.length ) );
        for ( var b = 0; b < a.length; b++ ) this.oa.send( a[ b ] )
    };
    h.Yc = function() {
        this.ub = !0;
        this.Cc && ( clearInterval( this.Cc ), this.Cc = null );
        this.oa && ( this.oa.close(), this.oa = null )
    };
    h.eb = function() {
        this.ub || ( this.f( "WebSocket is closing itself" ), this.Yc(), this.fb && ( this.fb( this.zc ), this.fb = null ) )
    };
    h.close = function() {
        this.ub || ( this.f( "WebSocket is being closed" ), this.Yc() )
    };

    function Qd( a ) {
        clearInterval( a.Cc );
        a.Cc = setInterval( function() {
            a.oa && a.oa.send( "0" );
            Qd( a )
        }, Math.floor( 45E3 ) )
    };

    function Sd( a ) {
        this.cc = a;
        this.Fd = [];
        this.Mb = 0;
        this.ge = -1;
        this.Ab = null
    }

    function Td( a, b, c ) {
        a.ge = b;
        a.Ab = c;
        a.ge < a.Mb && ( a.Ab(), a.Ab = null )
    }

    function Ud( a, b, c ) {
        for ( a.Fd[ b ] = c; a.Fd[ a.Mb ]; ) {
            var d = a.Fd[ a.Mb ];
            delete a.Fd[ a.Mb ];
            for ( var e = 0; e < d.length; ++e )
                if ( d[ e ] ) {
                    var f = a;
                    Fb( function() {
                        f.cc( d[ e ] )
                    } )
                }
            if ( a.Mb === a.ge ) {
                a.Ab && ( clearTimeout( a.Ab ), a.Ab(), a.Ab = null );
                break
            }
            a.Mb++
        }
    };

    function Vd() {
        this.set = {}
    }
    h = Vd.prototype;
    h.add = function( a, b ) {
        this.set[ a ] = null !== b ? b : !0
    };
    h.contains = function( a ) {
        return u( this.set, a )
    };
    h.get = function( a ) {
        return this.contains( a ) ? this.set[ a ] : void 0
    };
    h.remove = function( a ) {
        delete this.set[ a ]
    };
    h.clear = function() {
        this.set = {}
    };
    h.e = function() {
        return Bd( this.set )
    };
    h.count = function() {
        return Kb( this.set )
    };

    function Wd( a, b ) {
        A( a.set, function( a, d ) {
            b( d, a )
        } )
    };

    function Xd( a, b, c ) {
        this.ie = a;
        this.f = rb( a );
        this.kb = this.lb = 0;
        this.Qa = Ld( b );
        this.Kd = c;
        this.zc = !1;
        this.bd = function( a ) {
            b.host !== b.Ka && ( a.ns = b.yb );
            var c = [],
                f;
            for ( f in a ) a.hasOwnProperty( f ) && c.push( f + "=" + a[ f ] );
            return ( b.Cb ? "https://" : "http://" ) + b.Ka + "/.lp?" + c.join( "&" )
        }
    }
    var Yd, Zd;
    Xd.prototype.open = function( a, b ) {
        this.Ue = 0;
        this.ea = b;
        this.gf = new Sd( a );
        this.ub = !1;
        var c = this;
        this.ob = setTimeout( function() {
            c.f( "Timed out trying to connect." );
            c.eb();
            c.ob = null
        }, Math.floor( 3E4 ) );
        wb( function() {
            if ( !c.ub ) {
                c.Na = new $d( function( a, b, d, k, l ) {
                    ae( c, arguments );
                    if ( c.Na )
                        if ( c.ob && ( clearTimeout( c.ob ), c.ob = null ), c.zc = !0, "start" == a ) c.id = b, c.mf = d;
                        else if ( "close" === a ) b ? ( c.Na.Jd = !1, Td( c.gf, b, function() {
                        c.eb()
                    } ) ) : c.eb();
                    else throw Error( "Unrecognized command received: " + a );
                }, function( a, b ) {
                    ae( c, arguments );
                    Ud( c.gf, a, b )
                }, function() {
                    c.eb()
                }, c.bd );
                var a = {
                    start: "t"
                };
                a.ser = Math.floor( 1E8 * Math.random() );
                c.Na.Ud && ( a.cb = c.Na.Ud );
                a.v = "5";
                c.Kd && ( a.s = c.Kd );
                "undefined" !== typeof location && location.href && -1 !== location.href.indexOf( "firebaseio.com" ) && ( a.r = "f" );
                a = c.bd( a );
                c.f( "Connecting via long-poll to " + a );
                be( c.Na, a, function() {} )
            }
        } )
    };
    Xd.prototype.start = function() {
        var a = this.Na,
            b = this.mf;
        a.Xf = this.id;
        a.Yf = b;
        for ( a.Zd = !0; ce( a ); );
        a = this.id;
        b = this.mf;
        this.$b = document.createElement( "iframe" );
        var c = {
            dframe: "t"
        };
        c.id = a;
        c.pw = b;
        this.$b.src = this.bd( c );
        this.$b.style.display = "none";
        document.body.appendChild( this.$b )
    };
    Xd.isAvailable = function() {
        return !Zd && !( "object" === typeof window && window.chrome && window.chrome.extension && !/^chrome/.test( window.location.href ) ) && !( "object" === typeof Windows && "object" === typeof Windows.zg ) && ( Yd || !0 )
    };
    h = Xd.prototype;
    h.wd = function() {};
    h.Yc = function() {
        this.ub = !0;
        this.Na && ( this.Na.close(), this.Na = null );
        this.$b && ( document.body.removeChild( this.$b ), this.$b = null );
        this.ob && ( clearTimeout( this.ob ), this.ob = null )
    };
    h.eb = function() {
        this.ub || ( this.f( "Longpoll is closing itself" ), this.Yc(), this.ea && ( this.ea( this.zc ), this.ea = null ) )
    };
    h.close = function() {
        this.ub || ( this.f( "Longpoll is being closed." ), this.Yc() )
    };
    h.send = function( a ) {
        a = t( a );
        this.lb += a.length;
        Gd( this.Qa, "bytes_sent", a.length );
        a = mb( a );
        a = fb( a, !0 );
        a = Bb( a, 1840 );
        for ( var b = 0; b < a.length; b++ ) {
            var c = this.Na;
            c.Qc.push( {
                og: this.Ue,
                wg: a.length,
                We: a[ b ]
            } );
            c.Zd && ce( c );
            this.Ue++
        }
    };

    function ae( a, b ) {
        var c = t( b ).length;
        a.kb += c;
        Gd( a.Qa, "bytes_received", c )
    }

    function $d( a, b, c, d ) {
        this.bd = d;
        this.fb = c;
        this.Fe = new Vd;
        this.Qc = [];
        this.ke = Math.floor( 1E8 * Math.random() );
        this.Jd = !0;
        this.Ud = hb();
        window[ "pLPCommand" + this.Ud ] = a;
        window[ "pRTLPCB" + this.Ud ] = b;
        a = document.createElement( "iframe" );
        a.style.display = "none";
        if ( document.body ) {
            document.body.appendChild( a );
            try {
                a.contentWindow.document || kb( "No IE domain setting required" )
            } catch ( e ) {
                a.src = "javascript:void((function(){document.open();document.domain='" + document.domain + "';document.close();})())"
            }
        } else throw "Document body has not initialized. Wait to initialize Firebase until after the document is ready.";
        a.contentDocument ? a.$a = a.contentDocument : a.contentWindow ? a.$a = a.contentWindow.document : a.document && ( a.$a = a.document );
        this.va = a;
        a = "";
        this.va.src && "javascript:" === this.va.src.substr( 0, 11 ) && ( a = '<script>document.domain="' + document.domain + '";\x3c/script>' );
        a = "<html><body>" + a + "</body></html>";
        try {
            this.va.$a.open(), this.va.$a.write( a ), this.va.$a.close()
        } catch ( f ) {
            kb( "frame writing exception" ), f.stack && kb( f.stack ), kb( f )
        }
    }
    $d.prototype.close = function() {
        this.Zd = !1;
        if ( this.va ) {
            this.va.$a.body.innerHTML = "";
            var a = this;
            setTimeout( function() {
                null !== a.va && ( document.body.removeChild( a.va ), a.va = null )
            }, Math.floor( 0 ) )
        }
        var b = this.fb;
        b && ( this.fb = null, b() )
    };

    function ce( a ) {
        if ( a.Zd && a.Jd && a.Fe.count() < ( 0 < a.Qc.length ? 2 : 1 ) ) {
            a.ke++;
            var b = {};
            b.id = a.Xf;
            b.pw = a.Yf;
            b.ser = a.ke;
            for ( var b = a.bd( b ), c = "", d = 0; 0 < a.Qc.length; )
                if ( 1870 >= a.Qc[ 0 ].We.length + 30 + c.length ) {
                    var e = a.Qc.shift(),
                        c = c + "&seg" + d + "=" + e.og + "&ts" + d + "=" + e.wg + "&d" + d + "=" + e.We;
                    d++
                } else break;
            de( a, b + c, a.ke );
            return !0
        }
        return !1
    }

    function de( a, b, c ) {
        function d() {
            a.Fe.remove( c );
            ce( a )
        }
        a.Fe.add( c );
        var e = setTimeout( d, Math.floor( 25E3 ) );
        be( a, b, function() {
            clearTimeout( e );
            d()
        } )
    }

    function be( a, b, c ) {
        setTimeout( function() {
            try {
                if ( a.Jd ) {
                    var d = a.va.$a.createElement( "script" );
                    d.type = "text/javascript";
                    d.async = !0;
                    d.src = b;
                    d.onload = d.onreadystatechange = function() {
                        var a = d.readyState;
                        a && "loaded" !== a && "complete" !== a || ( d.onload = d.onreadystatechange = null, d.parentNode && d.parentNode.removeChild( d ), c() )
                    };
                    d.onerror = function() {
                        kb( "Long-poll script failed to load: " + b );
                        a.Jd = !1;
                        a.close()
                    };
                    a.va.$a.body.appendChild( d )
                }
            } catch ( e ) {}
        }, Math.floor( 1 ) )
    };

    function ee( a ) {
        fe( this, a )
    }
    var ge = [ Xd, Od ];

    function fe( a, b ) {
        var c = Od && Od.isAvailable(),
            d = c && !( Aa.ff || !0 === Aa.get( "previous_websocket_failure" ) );
        b.yg && ( c || z( "wss:// URL used, but browser isn't known to support websockets.  Trying anyway." ), d = !0 );
        if ( d ) a.$c = [ Od ];
        else {
            var e = a.$c = [];
            Cb( ge, function( a, b ) {
                b && b.isAvailable() && e.push( b )
            } )
        }
    }

    function he( a ) {
        if ( 0 < a.$c.length ) return a.$c[ 0 ];
        throw Error( "No transports available" );
    };

    function ie( a, b, c, d, e, f ) {
        this.id = a;
        this.f = rb( "c:" + this.id + ":" );
        this.cc = c;
        this.Kc = d;
        this.ea = e;
        this.De = f;
        this.Q = b;
        this.Ed = [];
        this.Se = 0;
        this.xf = new ee( b );
        this.Pa = 0;
        this.f( "Connection created" );
        je( this )
    }

    function je( a ) {
        var b = he( a.xf );
        a.J = new b( "c:" + a.id + ":" + a.Se++, a.Q );
        a.He = b.responsesRequiredToBeHealthy || 0;
        var c = ke( a, a.J ),
            d = le( a, a.J );
        a.ad = a.J;
        a.Xc = a.J;
        a.C = null;
        a.vb = !1;
        setTimeout( function() {
            a.J && a.J.open( c, d )
        }, Math.floor( 0 ) );
        b = b.healthyTimeout || 0;
        0 < b && ( a.rd = setTimeout( function() {
            a.rd = null;
            a.vb || ( a.J && 102400 < a.J.kb ? ( a.f( "Connection exceeded healthy timeout but has received " + a.J.kb + " bytes.  Marking connection healthy." ), a.vb = !0, a.J.wd() ) : a.J && 10240 < a.J.lb ? a.f( "Connection exceeded healthy timeout but has sent " + a.J.lb + " bytes.  Leaving connection alive." ) : ( a.f( "Closing unhealthy connection after timeout." ), a.close() ) )
        }, Math.floor( b ) ) )
    }

    function le( a, b ) {
        return function( c ) {
            b === a.J ? ( a.J = null, c || 0 !== a.Pa ? 1 === a.Pa && a.f( "Realtime connection lost." ) : ( a.f( "Realtime connection failed." ), "s-" === a.Q.Ka.substr( 0, 2 ) && ( Aa.remove( "host:" + a.Q.host ), a.Q.Ka = a.Q.host ) ), a.close() ) : b === a.C ? ( a.f( "Secondary connection lost." ), c = a.C, a.C = null, a.ad !== c && a.Xc !== c || a.close() ) : a.f( "closing an old connection" )
        }
    }

    function ke( a, b ) {
        return function( c ) {
            if ( 2 != a.Pa )
                if ( b === a.Xc ) {
                    var d = zb( "t", c );
                    c = zb( "d", c );
                    if ( "c" == d ) {
                        if ( d = zb( "t", c ), "d" in c )
                            if ( c = c.d, "h" === d ) {
                                var d = c.ts,
                                    e = c.v,
                                    f = c.h;
                                a.Kd = c.s;
                                Da( a.Q, f );
                                0 == a.Pa && ( a.J.start(), me( a, a.J, d ), "5" !== e && z( "Protocol version mismatch detected" ), c = a.xf, ( c = 1 < c.$c.length ? c.$c[ 1 ] : null ) && ne( a, c ) )
                            } else if ( "n" === d ) {
                            a.f( "recvd end transmission on primary" );
                            a.Xc = a.C;
                            for ( c = 0; c < a.Ed.length; ++c ) a.Bd( a.Ed[ c ] );
                            a.Ed = [];
                            oe( a )
                        } else "s" === d ? ( a.f( "Connection shutdown command received. Shutting down..." ), a.De && ( a.De( c ), a.De = null ), a.ea = null, a.close() ) : "r" === d ? ( a.f( "Reset packet received.  New host: " + c ), Da( a.Q, c ), 1 === a.Pa ? a.close() : ( pe( a ), je( a ) ) ) : "e" === d ? sb( "Server Error: " + c ) : "o" === d ? ( a.f( "got pong on primary." ), qe( a ), re( a ) ) : sb( "Unknown control packet command: " + d )
                    } else "d" == d && a.Bd( c )
                } else if ( b === a.C )
                if ( d = zb( "t", c ), c = zb( "d", c ), "c" == d ) "t" in c && ( c = c.t, "a" === c ? se( a ) : "r" === c ? ( a.f( "Got a reset on secondary, closing it" ), a.C.close(), a.ad !== a.C && a.Xc !== a.C || a.close() ) : "o" === c && ( a.f( "got pong on secondary." ), a.tf--, se( a ) ) );
                else if ( "d" == d ) a.Ed.push( c );
            else throw Error( "Unknown protocol layer: " + d );
            else a.f( "message on old connection" )
        }
    }
    ie.prototype.wa = function( a ) {
        te( this, {
            t: "d",
            d: a
        } )
    };

    function oe( a ) {
        a.ad === a.C && a.Xc === a.C && ( a.f( "cleaning up and promoting a connection: " + a.C.ie ), a.J = a.C, a.C = null )
    }

    function se( a ) {
        0 >= a.tf ? ( a.f( "Secondary connection is healthy." ), a.vb = !0, a.C.wd(), a.C.start(), a.f( "sending client ack on secondary" ), a.C.send( {
            t: "c",
            d: {
                t: "a",
                d: {}
            }
        } ), a.f( "Ending transmission on primary" ), a.J.send( {
            t: "c",
            d: {
                t: "n",
                d: {}
            }
        } ), a.ad = a.C, oe( a ) ) : ( a.f( "sending ping on secondary." ), a.C.send( {
            t: "c",
            d: {
                t: "p",
                d: {}
            }
        } ) )
    }
    ie.prototype.Bd = function( a ) {
        qe( this );
        this.cc( a )
    };

    function qe( a ) {
        a.vb || ( a.He--, 0 >= a.He && ( a.f( "Primary connection is healthy." ), a.vb = !0, a.J.wd() ) )
    }

    function ne( a, b ) {
        a.C = new b( "c:" + a.id + ":" + a.Se++, a.Q, a.Kd );
        a.tf = b.responsesRequiredToBeHealthy || 0;
        a.C.open( ke( a, a.C ), le( a, a.C ) );
        setTimeout( function() {
            a.C && ( a.f( "Timed out trying to upgrade." ), a.C.close() )
        }, Math.floor( 6E4 ) )
    }

    function me( a, b, c ) {
        a.f( "Realtime connection established." );
        a.J = b;
        a.Pa = 1;
        a.Kc && ( a.Kc( c ), a.Kc = null );
        0 === a.He ? ( a.f( "Primary connection is healthy." ), a.vb = !0 ) : setTimeout( function() {
            re( a )
        }, Math.floor( 5E3 ) )
    }

    function re( a ) {
        a.vb || 1 !== a.Pa || ( a.f( "sending ping on primary." ), te( a, {
            t: "c",
            d: {
                t: "p",
                d: {}
            }
        } ) )
    }

    function te( a, b ) {
        if ( 1 !== a.Pa ) throw "Connection is not connected";
        a.ad.send( b )
    }
    ie.prototype.close = function() {
        2 !== this.Pa && ( this.f( "Closing realtime connection." ), this.Pa = 2, pe( this ), this.ea && ( this.ea(), this.ea = null ) )
    };

    function pe( a ) {
        a.f( "Shutting down all connections" );
        a.J && ( a.J.close(), a.J = null );
        a.C && ( a.C.close(), a.C = null );
        a.rd && ( clearTimeout( a.rd ), a.rd = null )
    };

    function ue( a ) {
        var b = {},
            c = {},
            d = {},
            e = "";
        try {
            var f = a.split( "." ),
                b = ua( jb( f[ 0 ] ) || "" ),
                c = ua( jb( f[ 1 ] ) || "" ),
                e = f[ 2 ],
                d = c.d || {};
            delete c.d
        } catch ( g ) {}
        return {
            Bg: b,
            fe: c,
            data: d,
            sg: e
        }
    }

    function ve( a ) {
        a = ue( a ).fe;
        return "object" === typeof a && a.hasOwnProperty( "iat" ) ? v( a, "iat" ) : null
    }

    function we( a ) {
        a = ue( a );
        var b = a.fe;
        return !!a.sg && !!b && "object" === typeof b && b.hasOwnProperty( "iat" )
    };

    function xe( a, b, c, d ) {
        this.id = ye++;
        this.f = rb( "p:" + this.id + ":" );
        this.Eb = !0;
        this.ua = {};
        this.la = [];
        this.Nc = 0;
        this.Jc = [];
        this.ia = !1;
        this.Va = 1E3;
        this.xd = 3E5;
        this.Cd = b;
        this.Ad = c;
        this.Ee = d;
        this.Q = a;
        this.Ke = null;
        this.Tc = {};
        this.ng = 0;
        this.Dc = this.ue = null;
        ze( this, 0 );
        vd.Qb().zb( "visible", this.fg, this ); - 1 === a.host.indexOf( "fblocal" ) && wd.Qb().zb( "online", this.dg, this )
    }
    var ye = 0,
        Ae = 0;
    h = xe.prototype;
    h.wa = function( a, b, c ) {
        var d = ++this.ng;
        a = {
            r: d,
            a: a,
            b: b
        };
        this.f( t( a ) );
        x( this.ia, "sendRequest call when we're not connected not allowed." );
        this.La.wa( a );
        c && ( this.Tc[ d ] = c )
    };

    function Be( a, b, c, d, e ) {
        var f = b.Da(),
            g = b.path.toString();
        a.f( "Listen called for " + g + " " + f );
        a.ua[ g ] = a.ua[ g ] || {};
        x( !a.ua[ g ][ f ], "listen() called twice for same path/queryId." );
        b = {
            H: e,
            qd: c,
            kg: Dc( b ),
            tag: d
        };
        a.ua[ g ][ f ] = b;
        a.ia && Ce( a, g, f, b )
    }

    function Ce( a, b, c, d ) {
        a.f( "Listen on " + b + " for " + c );
        var e = {
            p: b
        };
        d.tag && ( e.q = d.kg, e.t = d.tag );
        e.h = d.qd();
        a.wa( "q", e, function( e ) {
            if ( ( a.ua[ b ] && a.ua[ b ][ c ] ) === d ) {
                a.f( "listen response", e );
                var g = e.s;
                "ok" !== g && De( a, b, c );
                e = e.d;
                d.H && d.H( g, e )
            }
        } )
    }
    h.T = function( a, b, c ) {
        this.Lb = {
            Mf: a,
            Ye: !1,
            sc: b,
            cd: c
        };
        this.f( "Authenticating using credential: " + a );
        Ee( this );
        ( b = 40 == a.length ) || ( a = ue( a ).fe, b = "object" === typeof a && !0 === v( a, "admin" ) );
        b && ( this.f( "Admin auth credential detected.  Reducing max reconnect time." ), this.xd = 3E4 )
    };
    h.Pe = function( a ) {
        delete this.Lb;
        this.ia && this.wa( "unauth", {}, function( b ) {
            a( b.s, b.d )
        } )
    };

    function Ee( a ) {
        var b = a.Lb;
        a.ia && b && a.wa( "auth", {
            cred: b.Mf
        }, function( c ) {
            var d = c.s;
            c = c.d || "error";
            "ok" !== d && a.Lb === b && delete a.Lb;
            b.Ye ? "ok" !== d && b.cd && b.cd( d, c ) : ( b.Ye = !0, b.sc && b.sc( d, c ) )
        } )
    }

    function Fe( a, b, c, d ) {
        a.ia ? Ge( a, "o", b, c, d ) : a.Jc.push( {
            Pc: b,
            action: "o",
            data: c,
            H: d
        } )
    }

    function He( a, b, c, d ) {
        a.ia ? Ge( a, "om", b, c, d ) : a.Jc.push( {
            Pc: b,
            action: "om",
            data: c,
            H: d
        } )
    }
    h.Ce = function( a, b ) {
        this.ia ? Ge( this, "oc", a, null, b ) : this.Jc.push( {
            Pc: a,
            action: "oc",
            data: null,
            H: b
        } )
    };

    function Ge( a, b, c, d, e ) {
        c = {
            p: c,
            d: d
        };
        a.f( "onDisconnect " + b, c );
        a.wa( b, c, function( a ) {
            e && setTimeout( function() {
                e( a.s, a.d )
            }, Math.floor( 0 ) )
        } )
    }
    h.put = function( a, b, c, d ) {
        Ie( this, "p", a, b, c, d )
    };

    function Ke( a, b, c, d ) {
        Ie( a, "m", b, c, d, void 0 )
    }

    function Ie( a, b, c, d, e, f ) {
        d = {
            p: c,
            d: d
        };
        n( f ) && ( d.h = f );
        a.la.push( {
            action: b,
            of: d,
            H: e
        } );
        a.Nc++;
        b = a.la.length - 1;
        a.ia ? Le( a, b ) : a.f( "Buffering put: " + c )
    }

    function Le( a, b ) {
        var c = a.la[ b ].action,
            d = a.la[ b ].of,
            e = a.la[ b ].H;
        a.la[ b ].lg = a.ia;
        a.wa( c, d, function( d ) {
            a.f( c + " response", d );
            delete a.la[ b ];
            a.Nc--;
            0 === a.Nc && ( a.la = [] );
            e && e( d.s, d.d )
        } )
    }
    h.Bd = function( a ) {
        if ( "r" in a ) {
            this.f( "from server: " + t( a ) );
            var b = a.r,
                c = this.Tc[ b ];
            c && ( delete this.Tc[ b ], c( a.b ) )
        } else {
            if ( "error" in a ) throw "A server-side error has occurred: " + a.error;
            "a" in a && ( b = a.a, c = a.b, this.f( "handleServerMessage", b, c ), "d" === b ? this.Cd( c.p, c.d, !1, c.t ) : "m" === b ? this.Cd( c.p, c.d, !0, c.t ) : "c" === b ? Me( this, c.p, c.q ) : "ac" === b ? ( a = c.s, b = c.d, c = this.Lb, delete this.Lb, c && c.cd && c.cd( a, b ) ) : "sd" === b ? this.Ke ? this.Ke( c ) : "msg" in c && "undefined" !== typeof console && console.log( "FIREBASE: " + c.msg.replace( "\n", "\nFIREBASE: " ) ) : sb( "Unrecognized action received from server: " + t( b ) + "\nAre you using the latest client?" ) )
        }
    };
    h.Kc = function( a ) {
        this.f( "connection ready" );
        this.ia = !0;
        this.Dc = ( new Date ).getTime();
        this.Ee( {
            serverTimeOffset: a - ( new Date ).getTime()
        } );
        Ne( this );
        this.Ad( !0 )
    };

    function ze( a, b ) {
        x( !a.La, "Scheduling a connect when we're already connected/ing?" );
        a.Nb && clearTimeout( a.Nb );
        a.Nb = setTimeout( function() {
            a.Nb = null;
            Oe( a )
        }, Math.floor( b ) )
    }
    h.fg = function( a ) {
        a && !this.qc && this.Va === this.xd && ( this.f( "Window became visible.  Reducing delay." ), this.Va = 1E3, this.La || ze( this, 0 ) );
        this.qc = a
    };
    h.dg = function( a ) {
        a ? ( this.f( "Browser went online.  Reconnecting." ), this.Va = 1E3, this.Eb = !0, this.La || ze( this, 0 ) ) : ( this.f( "Browser went offline.  Killing connection; don't reconnect." ), this.Eb = !1, this.La && this.La.close() )
    };
    h.jf = function() {
        this.f( "data client disconnected" );
        this.ia = !1;
        this.La = null;
        for ( var a = 0; a < this.la.length; a++ ) {
            var b = this.la[ a ];
            b && "h" in b.of && b.lg && ( b.H && b.H( "disconnect" ), delete this.la[ a ], this.Nc-- )
        }
        0 === this.Nc && ( this.la = [] );
        if ( this.Eb ) this.qc ? this.Dc && ( 3E4 < ( new Date ).getTime() - this.Dc && ( this.Va = 1E3 ), this.Dc = null ) : ( this.f( "Window isn't visible.  Delaying reconnect." ), this.Va = this.xd, this.ue = ( new Date ).getTime() ), a = Math.max( 0, this.Va - ( ( new Date ).getTime() - this.ue ) ), a *= Math.random(), this.f( "Trying to reconnect in " + a + "ms" ), ze( this, a ), this.Va = Math.min( this.xd, 1.3 * this.Va );
        else
            for ( var c in this.Tc ) delete this.Tc[ c ];
        this.Ad( !1 )
    };

    function Oe( a ) {
        if ( a.Eb ) {
            a.f( "Making a connection attempt" );
            a.ue = ( new Date ).getTime();
            a.Dc = null;
            var b = q( a.Bd, a ),
                c = q( a.Kc, a ),
                d = q( a.jf, a ),
                e = a.id + ":" + Ae++;
            a.La = new ie( e, a.Q, b, c, d, function( b ) {
                z( b + " (" + a.Q.toString() + ")" );
                a.Eb = !1
            } )
        }
    }
    h.tb = function() {
        this.Eb = !1;
        this.La ? this.La.close() : ( this.Nb && ( clearTimeout( this.Nb ), this.Nb = null ), this.ia && this.jf() )
    };
    h.kc = function() {
        this.Eb = !0;
        this.Va = 1E3;
        this.La || ze( this, 0 )
    };

    function Me( a, b, c ) {
        c = c ? La( c, function( a ) {
            return Ab( a )
        } ).join( "$" ) : "default";
        ( a = De( a, b, c ) ) && a.H && a.H( "permission_denied" )
    }

    function De( a, b, c ) {
        b = ( new P( b ) ).toString();
        var d = a.ua[ b ][ c ];
        delete a.ua[ b ][ c ];
        0 === Kb( a.ua[ b ] ) && delete a.ua[ b ];
        return d
    }

    function Ne( a ) {
        Ee( a );
        A( a.ua, function( b, d ) {
            A( b, function( b, c ) {
                Ce( a, d, c, b )
            } )
        } );
        for ( var b = 0; b < a.la.length; b++ ) a.la[ b ] && Le( a, b );
        for ( ; a.Jc.length; ) b = a.Jc.shift(), Ge( a, b.action, b.Pc, b.data, b.H )
    };

    function Pe() {
        this.j = this.A = null
    }
    Pe.prototype.ic = function( a, b ) {
        if ( a.e() ) this.A = b, this.j = null;
        else if ( null !== this.A ) this.A = this.A.L( a, b );
        else {
            null == this.j && ( this.j = new Vd );
            var c = G( a );
            this.j.contains( c ) || this.j.add( c, new Pe );
            c = this.j.get( c );
            a = R( a );
            c.ic( a, b )
        }
    };

    function Qe( a, b ) {
        if ( b.e() ) return a.A = null, a.j = null, !0;
        if ( null !== a.A ) {
            if ( a.A.P() ) return !1;
            var c = a.A;
            a.A = null;
            c.ca( L, function( b, c ) {
                a.ic( new P( b ), c )
            } );
            return Qe( a, b )
        }
        return null !== a.j ? ( c = G( b ), b = R( b ), a.j.contains( c ) && Qe( a.j.get( c ), b ) && a.j.remove( c ), a.j.e() ? ( a.j = null, !0 ) : !1 ) : !0
    }

    function Re( a, b, c ) {
        null !== a.A ? c( b, a.A ) : a.ca( function( a, e ) {
            var f = new P( b.toString() + "/" + a );
            Re( e, f, c )
        } )
    }
    Pe.prototype.ca = function( a ) {
        null !== this.j && Wd( this.j, function( b, c ) {
            a( b, c )
        } )
    };

    function Se() {
        this.Wc = K
    }
    Se.prototype.toString = function() {
        return this.Wc.toString()
    };

    function Te() {
        this.qb = []
    }

    function Ue( a, b ) {
        for ( var c = null, d = 0; d < b.length; d++ ) {
            var e = b[ d ],
                f = e.Rb();
            null === c || f.ja( c.Rb() ) || ( a.qb.push( c ), c = null );
            null === c && ( c = new Ve( f ) );
            c.add( e )
        }
        c && a.qb.push( c )
    }

    function Cc( a, b, c ) {
        Ue( a, c );
        We( a, function( a ) {
            return a.ja( b )
        } )
    }

    function Xe( a, b, c ) {
        Ue( a, c );
        We( a, function( a ) {
            return a.contains( b ) || b.contains( a )
        } )
    }

    function We( a, b ) {
        for ( var c = !0, d = 0; d < a.qb.length; d++ ) {
            var e = a.qb[ d ];
            if ( e )
                if ( e = e.Rb(), b( e ) ) {
                    for ( var e = a.qb[ d ], f = 0; f < e.od.length; f++ ) {
                        var g = e.od[ f ];
                        if ( null !== g ) {
                            e.od[ f ] = null;
                            var k = g.Pb();
                            ob && kb( "event: " + g.toString() );
                            Fb( k )
                        }
                    }
                    a.qb[ d ] = null
                } else c = !1
        }
        c && ( a.qb = [] )
    }

    function Ve( a ) {
        this.Ca = a;
        this.od = []
    }
    Ve.prototype.add = function( a ) {
        this.od.push( a )
    };
    Ve.prototype.Rb = function() {
        return this.Ca
    };
    var Ye = "auth.firebase.com";

    function Ze( a, b, c ) {
        this.ed = a || {};
        this.Sd = b || {};
        this.lc = c || {};
        this.ed.remember || ( this.ed.remember = "default" )
    }
    var $e = [ "remember", "redirectTo" ];

    function af( a ) {
        var b = {},
            c = {};
        va( a || {}, function( a, e ) {
            0 <= Ia( $e, a ) ? b[ a ] = e : c[ a ] = e
        } );
        return new Ze( b, {}, c )
    };
    var bf = {
        NETWORK_ERROR: "Unable to contact the Firebase server.",
        SERVER_ERROR: "An unknown server error occurred.",
        TRANSPORT_UNAVAILABLE: "There are no login transports available for the requested method.",
        REQUEST_INTERRUPTED: "The browser redirected the page before the login request could complete.",
        USER_CANCELLED: "The user cancelled authentication."
    };

    function V( a ) {
        var b = Error( v( bf, a ), a );
        b.code = a;
        return b
    };

    function cf() {
        var a = window.opener.frames,
            b;
        for ( b = a.length - 1; 0 <= b; b-- ) try {
            if ( a[ b ].location.protocol === window.location.protocol && a[ b ].location.host === window.location.host && "__winchan_relay_frame" === a[ b ].name ) return a[ b ]
        } catch ( c ) {}
        return null
    }

    function df( a, b, c ) {
        a.attachEvent ? a.attachEvent( "on" + b, c ) : a.addEventListener && a.addEventListener( b, c, !1 )
    }

    function ef( a, b, c ) {
        a.detachEvent ? a.detachEvent( "on" + b, c ) : a.removeEventListener && a.removeEventListener( b, c, !1 )
    }

    function ff( a ) {
        /^https?:\/\//.test( a ) || ( a = window.location.href );
        var b = /^(https?:\/\/[\-_a-zA-Z\.0-9:]+)/.exec( a );
        return b ? b[ 1 ] : a
    }

    function gf( a ) {
        var b = "";
        try {
            a = a.replace( "#", "" );
            var c = {},
                d = a.replace( /^\?/, "" ).split( "&" );
            for ( a = 0; a < d.length; a++ )
                if ( d[ a ] ) {
                    var e = d[ a ].split( "=" );
                    c[ e[ 0 ] ] = e[ 1 ]
                }
            c && u( c, "__firebase_request_key" ) && ( b = v( c, "__firebase_request_key" ) )
        } catch ( f ) {}
        return b
    }

    function hf( a ) {
        var b = [],
            c;
        for ( c in a )
            if ( u( a, c ) ) {
                var d = v( a, c );
                if ( ea( d ) )
                    for ( var e = 0; e < d.length; e++ ) b.push( encodeURIComponent( c ) + "=" + encodeURIComponent( d[ e ] ) );
                else b.push( encodeURIComponent( c ) + "=" + encodeURIComponent( v( a, c ) ) )
            }
        return b.join( "&" )
    }

    function jf() {
        var a = ub( Ye );
        return a.scheme + "://" + a.host + "/v2"
    };

    function kf() {
        return !!( window.cordova || window.phonegap || window.PhoneGap ) && /ios|iphone|ipod|ipad|android|blackberry|iemobile/i.test( navigator.userAgent )
    }

    function lf() {
        var a = navigator.userAgent;
        if ( "Microsoft Internet Explorer" === navigator.appName ) {
            if ( ( a = a.match( /MSIE ([0-9]{1,}[\.0-9]{0,})/ ) ) && 1 < a.length ) return 8 <= parseFloat( a[ 1 ] )
        } else if ( -1 < a.indexOf( "Trident" ) && ( a = a.match( /rv:([0-9]{2,2}[\.0-9]{0,})/ ) ) && 1 < a.length ) return 8 <= parseFloat( a[ 1 ] );
        return !1
    };

    function mf( a ) {
        a = a || {};
        a.method || ( a.method = "GET" );
        a.headers || ( a.headers = {} );
        a.headers.content_type || ( a.headers.content_type = "application/json" );
        a.headers.content_type = a.headers.content_type.toLowerCase();
        this.options = a
    }
    mf.prototype.open = function( a, b, c ) {
        function d() {
            c && ( c( V( "REQUEST_INTERRUPTED" ) ), c = null )
        }
        var e = new XMLHttpRequest,
            f = this.options.method.toUpperCase(),
            g;
        df( window, "beforeunload", d );
        e.onreadystatechange = function() {
            if ( c && 4 === e.readyState ) {
                var a;
                if ( 200 <= e.status && 300 > e.status ) {
                    try {
                        a = ua( e.responseText )
                    } catch ( b ) {}
                    c( null, a )
                } else 500 <= e.status && 600 > e.status ? c( V( "SERVER_ERROR" ) ) : c( V( "NETWORK_ERROR" ) );
                c = null;
                ef( window, "beforeunload", d )
            }
        };
        if ( "GET" === f ) a += ( /\?/.test( a ) ? "" : "?" ) + hf( b ), g = null;
        else {
            var k = this.options.headers.content_type;
            "application/json" === k && ( g = t( b ) );
            "application/x-www-form-urlencoded" === k && ( g = hf( b ) )
        }
        e.open( f, a, !0 );
        a = {
            "X-Requested-With": "XMLHttpRequest",
            Accept: "application/json;text/plain"
        };
        Ed( a, this.options.headers );
        for ( var l in a ) e.setRequestHeader( l, a[ l ] );
        e.send( g )
    };
    mf.isAvailable = function() {
        return !!window.XMLHttpRequest && "string" === typeof( new XMLHttpRequest ).responseType && ( !( navigator.userAgent.match( /MSIE/ ) || navigator.userAgent.match( /Trident/ ) ) || lf() )
    };
    mf.prototype.uc = function() {
        return "json"
    };

    function nf( a ) {
        a = a || {};
        this.Uc = Ha() + Ha() + Ha();
        this.kf = a || {}
    }
    nf.prototype.open = function( a, b, c ) {
        function d() {
            c && ( c( V( "USER_CANCELLED" ) ), c = null )
        }
        var e = this,
            f = ub( Ye ),
            g;
        b.requestId = this.Uc;
        b.redirectTo = f.scheme + "://" + f.host + "/blank/page.html";
        a += /\?/.test( a ) ? "" : "?";
        a += hf( b );
        ( g = window.open( a, "_blank", "location=no" ) ) && ha( g.addEventListener ) ? ( g.addEventListener( "loadstart", function( a ) {
            var b;
            if ( b = a && a.url ) a: {
                var f = a.url;
                try {
                    var r = document.createElement( "a" );
                    r.href = f;
                    b = r.host === ub( Ye ).host && "/blank/page.html" === r.pathname;
                    break a
                } catch ( s ) {}
                b = !1
            }
            b && ( a = gf( a.url ), g.removeEventListener( "exit", d ), g.close(), a = new Ze( null, null, {
                requestId: e.Uc,
                requestKey: a
            } ), e.kf.requestWithCredential( "/auth/session", a, c ), c = null )
        } ), g.addEventListener( "exit", d ) ) : c( V( "TRANSPORT_UNAVAILABLE" ) )
    };
    nf.isAvailable = function() {
        return kf()
    };
    nf.prototype.uc = function() {
        return "redirect"
    };

    function of( a ) {
        a = a || {};
        if ( !a.window_features || -1 !== navigator.userAgent.indexOf( "Fennec/" ) || -1 !== navigator.userAgent.indexOf( "Firefox/" ) && -1 !== navigator.userAgent.indexOf( "Android" ) ) a.window_features = void 0;
        a.window_name || ( a.window_name = "_blank" );
        a.relay_url || ( a.relay_url = jf() + "/auth/channel" );
        this.options = a
    }
    of.prototype.open = function( a, b, c ) {
        function d( a ) {
            g && ( document.body.removeChild( g ), g = void 0 );
            r && ( r = clearInterval( r ) );
            ef( window, "message", e );
            ef( window, "unload", d );
            if ( m && !a ) try {
                m.close()
            } catch ( b ) {
                k.postMessage( "die", l )
            }
            m = k = void 0
        }

        function e( a ) {
            if ( a.origin === l ) try {
                var b = ua( a.data );
                "ready" === b.a ? k.postMessage( s, l ) : "error" === b.a ? ( d( !1 ), c && ( c( b.d ), c = null ) ) : "response" === b.a && ( d( b.forceKeepWindowOpen ), c && ( c( null, b.d ), c = null ) )
            } catch ( e ) {}
        }
        var f = lf(),
            g, k, l = ff( a );
        if ( l !== ff( this.options.relay_url ) ) c && setTimeout( function() {
            c( Error( "invalid arguments: origin of url and relay_url must match" ) )
        }, 0 );
        else {
            f && ( g = document.createElement( "iframe" ), g.setAttribute( "src", this.options.relay_url ), g.style.display = "none", g.setAttribute( "name", "__winchan_relay_frame" ), document.body.appendChild( g ), k = g.contentWindow );
            a += ( /\?/.test( a ) ? "" : "?" ) + hf( b );
            var m = window.open( a, this.options.window_name, this.options.window_features );
            k || ( k = m );
            var r = setInterval( function() {
                    m && m.closed && ( d( !1 ), c && ( c( V( "USER_CANCELLED" ) ), c = null ) )
                }, 500 ),
                s = t( {
                    a: "request",
                    d: b
                } );
            df( window, "unload", d );
            df( window, "message", e )
        }
    };
    of.isAvailable = function() {
        return "postMessage" in window && !/^file:\//.test( location.href ) && !( kf() || navigator.userAgent.match( /Windows Phone/ ) || window.Windows && /^ms-appx:/.test( location.href ) || navigator.userAgent.match( /(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)/i ) || navigator.userAgent.match( /CriOS/ ) || navigator.userAgent.match( /Twitter for iPhone/ ) || navigator.userAgent.match( /FBAN\/FBIOS/ ) || window.navigator.standalone ) && !navigator.userAgent.match( /PhantomJS/ )
    };
    of.prototype.uc = function() {
        return "popup"
    };

    function pf( a ) {
        a = a || {};
        a.callback_parameter || ( a.callback_parameter = "callback" );
        this.options = a;
        window.__firebase_auth_jsonp = window.__firebase_auth_jsonp || {}
    }
    pf.prototype.open = function( a, b, c ) {
        function d() {
            c && ( c( V( "REQUEST_INTERRUPTED" ) ), c = null )
        }

        function e() {
            setTimeout( function() {
                window.__firebase_auth_jsonp[ f ] = void 0;
                Bd( window.__firebase_auth_jsonp ) && ( window.__firebase_auth_jsonp = void 0 );
                try {
                    var a = document.getElementById( f );
                    a && a.parentNode.removeChild( a )
                } catch ( b ) {}
            }, 1 );
            ef( window, "beforeunload", d )
        }
        var f = "fn" + ( new Date ).getTime() + Math.floor( 99999 * Math.random() );
        b[ this.options.callback_parameter ] = "__firebase_auth_jsonp." + f;
        a += ( /\?/.test( a ) ? "" : "?" ) + hf( b );
        df( window, "beforeunload", d );
        window.__firebase_auth_jsonp[ f ] = function( a ) {
            c && ( c( null, a ), c = null );
            e()
        };
        qf( f, a, c )
    };

    function qf( a, b, c ) {
        setTimeout( function() {
            try {
                var d = document.createElement( "script" );
                d.type = "text/javascript";
                d.id = a;
                d.async = !0;
                d.src = b;
                d.onerror = function() {
                    var b = document.getElementById( a );
                    null !== b && b.parentNode.removeChild( b );
                    c && c( V( "NETWORK_ERROR" ) )
                };
                var e = document.getElementsByTagName( "head" );
                ( e && 0 != e.length ? e[ 0 ] : document.documentElement ).appendChild( d )
            } catch ( f ) {
                c && c( V( "NETWORK_ERROR" ) )
            }
        }, 0 )
    }
    pf.isAvailable = function() {
        return !kf()
    };
    pf.prototype.uc = function() {
        return "json"
    };

    function rf( a, b ) {
        this.Ge = [ "session", a.Gd, a.yb ].join( ":" );
        this.Pd = b
    }
    rf.prototype.set = function( a, b ) {
        if ( !b )
            if ( this.Pd.length ) b = this.Pd[ 0 ];
            else throw Error( "fb.login.SessionManager : No storage options available!" );
        b.set( this.Ge, a )
    };
    rf.prototype.get = function() {
        var a = La( this.Pd, q( this.Tf, this ) ),
            a = Ka( a, function( a ) {
                return null !== a
            } );
        Ta( a, function( a, c ) {
            return ve( c.token ) - ve( a.token )
        } );
        return 0 < a.length ? a.shift() : null
    };
    rf.prototype.Tf = function( a ) {
        try {
            var b = a.get( this.Ge );
            if ( b && b.token ) return b
        } catch ( c ) {}
        return null
    };
    rf.prototype.clear = function() {
        var a = this;
        Ja( this.Pd, function( b ) {
            b.remove( a.Ge )
        } )
    };

    function sf( a ) {
        a = a || {};
        this.Uc = Ha() + Ha() + Ha();
        this.kf = a || {}
    }
    sf.prototype.open = function( a, b ) {
        Ba.set( "redirect_request_id", this.Uc );
        b.requestId = this.Uc;
        b.redirectTo = b.redirectTo || window.location.href;
        a += ( /\?/.test( a ) ? "" : "?" ) + hf( b );
        window.location = a
    };
    sf.isAvailable = function() {
        return !/^file:\//.test( location.href ) && !kf()
    };
    sf.prototype.uc = function() {
        return "redirect"
    };

    function tf( a, b, c, d ) {
        td.call( this, [ "auth_status" ] );
        this.Q = a;
        this.Re = b;
        this.xg = c;
        this.Be = d;
        this.mc = new rf( a, [ Aa, Ba ] );
        this.jb = null;
        uf( this )
    }
    na( tf, td );
    h = tf.prototype;
    h.ne = function() {
        return this.jb || null
    };

    function uf( a ) {
        Ba.get( "redirect_request_id" ) && vf( a );
        var b = a.mc.get();
        b && b.token ? ( wf( a, b ), a.Re( b.token, function( c, d ) {
            xf( a, c, d, !1, b.token, b )
        }, function( b, d ) {
            yf( a, "resumeSession()", b, d )
        } ) ) : wf( a, null )
    }

    function zf( a, b, c, d, e, f ) {
        "firebaseio-demo.com" === a.Q.domain && z( "Firebase authentication is not supported on demo Firebases (*.firebaseio-demo.com). To secure your Firebase, create a production Firebase at https://www.firebase.com." );
        a.Re( b, function( f, k ) {
            xf( a, f, k, !0, b, c, d || {}, e )
        }, function( b, c ) {
            yf( a, "auth()", b, c, f )
        } )
    }

    function Af( a, b ) {
        a.mc.clear();
        wf( a, null );
        a.xg( function( a, d ) {
            if ( "ok" === a ) B( b, null );
            else {
                var e = ( a || "error" ).toUpperCase(),
                    f = e;
                d && ( f += ": " + d );
                f = Error( f );
                f.code = e;
                B( b, f )
            }
        } )
    }

    function xf( a, b, c, d, e, f, g, k ) {
        "ok" === b ? ( d && ( b = c.auth, f.auth = b, f.expires = c.expires, f.token = we( e ) ? e : "", c = null, b && u( b, "uid" ) ? c = v( b, "uid" ) : u( f, "uid" ) && ( c = v( f, "uid" ) ), f.uid = c, c = "custom", b && u( b, "provider" ) ? c = v( b, "provider" ) : u( f, "provider" ) && ( c = v( f, "provider" ) ), f.provider = c, a.mc.clear(), we( e ) && ( g = g || {}, c = Aa, "sessionOnly" === g.remember && ( c = Ba ), "none" !== g.remember && a.mc.set( f, c ) ), wf( a, f ) ), B( k, null, f ) ) : ( a.mc.clear(), wf( a, null ), f = a = ( b || "error" ).toUpperCase(), c && ( f += ": " + c ), f = Error( f ), f.code = a, B( k, f ) )
    }

    function yf( a, b, c, d, e ) {
        z( b + " was canceled: " + d );
        a.mc.clear();
        wf( a, null );
        a = Error( d );
        a.code = c.toUpperCase();
        B( e, a )
    }

    function Bf( a, b, c, d, e ) {
        Cf( a );
        var f = [ mf, pf ];
        c = new Ze( d || {}, {}, c || {} );
        Df( a, f, "/auth/" + b, c, e )
    }

    function Ef( a, b, c, d ) {
        Cf( a );
        var e = [ of, nf ];
        c = af( c );
        "anonymous" === b || "password" === b ? setTimeout( function() {
            B( d, V( "TRANSPORT_UNAVAILABLE" ) )
        }, 0 ) : ( c.Sd.window_features = "menubar=yes,modal=yes,alwaysRaised=yeslocation=yes,resizable=yes,scrollbars=yes,status=yes,height=625,width=625,top=" + ( "object" === typeof screen ? .5 * ( screen.height - 625 ) : 0 ) + ",left=" + ( "object" === typeof screen ? .5 * ( screen.width - 625 ) : 0 ), c.Sd.relay_url = jf() + "/" + a.Q.yb + "/auth/channel", c.Sd.requestWithCredential = q( a.Vc, a ), Df( a, e, "/auth/" + b, c, d ) )
    }

    function vf( a ) {
        var b = Ba.get( "redirect_request_id" );
        if ( b ) {
            var c = Ba.get( "redirect_client_options" );
            Ba.remove( "redirect_request_id" );
            Ba.remove( "redirect_client_options" );
            var d = [ mf, pf ],
                b = {
                    requestId: b,
                    requestKey: gf( document.location.hash )
                },
                c = new Ze( c, {}, b );
            try {
                document.location.hash = document.location.hash.replace( /&__firebase_request_key=([a-zA-z0-9]*)/, "" )
            } catch ( e ) {}
            Df( a, d, "/auth/session", c )
        }
    }
    h.je = function( a, b ) {
        Cf( this );
        var c = af( a );
        c.lc._method = "POST";
        this.Vc( "/users", c, function( a, c ) {
            a ? B( b, a ) : B( b, a, c )
        } )
    };
    h.Ie = function( a, b ) {
        var c = this;
        Cf( this );
        var d = "/users/" + encodeURIComponent( a.email ),
            e = af( a );
        e.lc._method = "DELETE";
        this.Vc( d, e, function( a, d ) {
            !a && d && d.uid && c.jb && c.jb.uid && c.jb.uid === d.uid && Af( c );
            B( b, a )
        } )
    };
    h.ee = function( a, b ) {
        Cf( this );
        var c = "/users/" + encodeURIComponent( a.email ) + "/password",
            d = af( a );
        d.lc._method = "PUT";
        d.lc.password = a.newPassword;
        this.Vc( c, d, function( a ) {
            B( b, a )
        } )
    };
    h.Je = function( a, b ) {
        Cf( this );
        var c = "/users/" + encodeURIComponent( a.email ) + "/password",
            d = af( a );
        d.lc._method = "POST";
        this.Vc( c, d, function( a ) {
            B( b, a )
        } )
    };
    h.Vc = function( a, b, c ) {
        Ff( this, [ mf, pf ], a, b, c )
    };

    function Df( a, b, c, d, e ) {
        Ff( a, b, c, d, function( b, c ) {
            !b && c && c.token && c.uid ? zf( a, c.token, c, d.ed, function( a, b ) {
                a ? B( e, a ) : B( e, null, b )
            } ) : B( e, b || V( "UNKNOWN_ERROR" ) )
        } )
    }

    function Ff( a, b, c, d, e ) {
        b = Ka( b, function( a ) {
            return "function" === typeof a.isAvailable && a.isAvailable()
        } );
        0 === b.length ? setTimeout( function() {
            B( e, V( "TRANSPORT_UNAVAILABLE" ) )
        }, 0 ) : ( b = new( b.shift() )( d.Sd ), d = wa( d.lc ), d.v = "js-2.0.6", d.transport = b.uc(), d.suppress_status_codes = !0, a = jf() + "/" + a.Q.yb + c, b.open( a, d, function( a, b ) {
            if ( a ) B( e, a );
            else if ( b && b.error ) {
                var c = Error( b.error.message );
                c.code = b.error.code;
                c.details = b.error.details;
                B( e, c )
            } else B( e, null, b )
        } ) )
    }

    function wf( a, b ) {
        var c = null !== a.jb || null !== b;
        a.jb = b;
        c && a.Td( "auth_status", b );
        a.Be( null !== b )
    }
    h.pe = function( a ) {
        x( "auth_status" === a, 'initial event must be of type "auth_status"' );
        return [ this.jb ]
    };

    function Cf( a ) {
        var b = a.Q;
        if ( "firebaseio.com" !== b.domain && "firebaseio-demo.com" !== b.domain && "auth.firebase.com" === Ye ) throw Error( "This custom Firebase server ('" + a.Q.domain + "') does not support delegated login." );
    };

    function Gf( a, b ) {
        return a && "object" === typeof a ? ( x( ".sv" in a, "Unexpected leaf node or priority contents" ), b[ a[ ".sv" ] ] ) : a
    }

    function Hf( a, b ) {
        var c = new Pe;
        Re( a, new P( "" ), function( a, e ) {
            c.ic( a, If( e, b ) )
        } );
        return c
    }

    function If( a, b ) {
        var c = a.O().N(),
            c = Gf( c, b ),
            d;
        if ( a.P() ) {
            var e = Gf( a.ta(), b );
            return e !== a.ta() || c !== a.O().N() ? new Zc( e, J( c ) ) : a
        }
        d = a;
        c !== a.O().N() && ( d = d.ib( new Zc( c ) ) );
        a.ca( L, function( a, c ) {
            var e = If( c, b );
            e !== c && ( d = d.I( a, e ) )
        } );
        return d
    };

    function W( a, b, c, d ) {
        this.type = a;
        this.Wa = b;
        this.nb = c;
        this.Rc = null;
        this.$f = d
    };

    function Jf() {}
    var Kf = new Jf;

    function Lf( a, b, c, d ) {
        var e, f;
        f = X( c );
        e = X( b );
        if ( d.e() ) return c.u ? ( a = [], e ? e.ja( f ) || ( e.P() ? a = Mf( f ) : f.P() ? ( a = [], e.P() || e.e() || a.push( new W( "children_removed", e ) ) ) : a = Nf( e, f ), a.push( new W( "value", f ) ) ) : ( a = Mf( f ), a.push( new W( "value", f ) ) ), 0 !== a.length || b.u || a.push( new W( "value", f ) ), a ) : e ? Nf( e, f ) : Mf( f );
        if ( ".priority" === G( d ) ) return !c.u || e && e.ja( f ) ? [] : [ new W( "value", f ) ];
        if ( c.u || 1 === Q( d ) ) return e = G( d ), f = f.B( e ), a.kd( b, c, e, f );
        e = G( d );
        return f.Y( e ) ? ( f = f.B( e ), a.kd( b, c, e, f ) ) : []
    }
    Jf.prototype.kd = function( a, b, c, d ) {
        ( a = X( a ) ) ? a.Y( c ) ? ( a = a.B( c ), c = a.ja( d ) ? [] : d.e() ? [ new W( "child_removed", a, c ) ] : [ new W( "child_changed", d, c, a ) ] ) : c = d.e() ? [] : [ new W( "child_added", d, c ) ]: c = d.e() ? [] : [ new W( "child_added", d, c ) ];
        0 < c.length && b.u && c.push( new W( "value", X( b ) ) );
        return c
    };

    function Mf( a ) {
        var b = [];
        a.P() || a.e() || b.push( new W( "children_added", a ) );
        return b
    }

    function Nf( a, b ) {
        var c = [],
            d = [],
            e = [],
            f = [],
            g = {},
            k = {},
            l, m, r, s;
        l = a.Aa( L );
        r = U( l );
        m = b.Aa( L );
        s = U( m );
        for ( var y = H( L ); null !== r || null !== s; ) {
            var N;
            N = r ? s ? y( r, s ) : -1 : 1;
            0 > N ? ( N = v( g, r.name ), n( N ) ? ( f.push( d[ N ] ), d[ N ] = null ) : ( k[ r.name ] = e.length, e.push( r ) ), r = U( l ) ) : ( 0 < N ? ( N = v( k, s.name ), n( N ) ? ( f.push( s ), e[ N ] = null ) : ( g[ s.name ] = d.length, d.push( s ) ) ) : ( ( r = r.K.hash() !== s.K.hash() ) && f.push( s ), r = U( l ) ), s = U( m ) )
        }
        for ( g = 0; g < e.length; g++ )( k = e[ g ] ) && c.push( new W( "child_removed", k.K, k.name ) );
        for ( g = 0; g < d.length; g++ )( e = d[ g ] ) && c.push( new W( "child_added", e.K, e.name ) );
        for ( g = 0; g < f.length; g++ ) d = f[ g ], c.push( new W( "child_changed", d.K, d.name, a.B( d.name ) ) );
        return c
    }

    function Of( a, b, c ) {
        this.bb = a;
        this.Ma = c;
        this.m = b
    }
    na( Of, Jf );
    Of.prototype.kd = function( a, b, c, d ) {
        var e = X( a ) || K,
            f = X( b ) || K;
        if ( e.Ua() < this.bb || f.Ua() < this.bb ) return Of.oc.kd.call( this, a, b, c, d );
        x( !e.P() && !f.P(), "If it's a leaf node, we should have hit the above case." );
        a = [];
        var g = e.B( c );
        g.e() ? f.Y( c ) && ( e = this.Ma ? ld( e, this.m ) : md( e, this.m ), a.push( new W( "child_removed", e.K, e.name ) ), a.push( new W( "child_added", d, c ) ) ) : f.Y( c ) ? d.ja( g ) || a.push( new W( "child_changed", d, c, e.B( c ) ) ) : ( a.push( new W( "child_removed", g, c ) ), e = this.Ma ? ld( f, this.m ) : md( f, this.m ), a.push( new W( "child_added", e.K, e.name ) ) );
        0 < a.length && b.u && a.push( new W( "value", f ) );
        return a
    };

    function Pf() {}
    h = Pf.prototype;
    h.Xa = function( a, b, c, d ) {
        var e;
        if ( b.type === Qf ) {
            if ( b.source.$e ) return this.Fa( a, b.path, b.Oa, c, d );
            x( b.source.Ze, "Unknown source." );
            e = b.source.wf;
            return this.Sa( a, b.path, b.Oa, c, d, e )
        }
        if ( b.type === Rf ) {
            if ( b.source.$e ) return this.ae( a, b.path, b.children, c, d );
            x( b.source.Ze, "Unknown source." );
            e = b.source.wf;
            return this.$d( a, b.path, b.children, c, d, e )
        }
        if ( b.type === Sf ) {
            if ( b.sf ) a: {
                var f = b.path;
                Tf( this, a );
                b = a.u;
                e = a.X;
                if ( a.F ) {
                    x( a.u, "Must have event snap if we have server snap" );
                    var g = c.Ya( f, a.u, a.F );
                    if ( g )
                        if ( b = a.u.L( f, g ), f.e() ) b = this.G( b );
                        else {
                            e = G( f );
                            b = b.B( e );
                            a = this.Ra( a, e, b, a.F, a.o, c, d );
                            break a
                        }
                } else if ( a.o )
                    if ( a.u )( d = c.Ob() ) ? b = this.G( d ) : ( c = c.Ya( f, a.u, a.o ) ) && ( b = this.G( b.L( f, c ) ) );
                    else {
                        if ( x( a.X, "We must at least have complete children" ), x( !f.e(), "If the path were empty, we would have an event snap from the set" ), c = c.Ya( f, a.X, a.o ) ) e = a.X.L( f, c ), e = this.G( e )
                    } else if ( a.u )( c = c.Ob() ) && ( b = this.G( c ) );
                else if ( a.X ) {
                    x( !f.e(), "If the path was empty, we would have an event snap" );
                    g = G( f );
                    if ( a.X.Y( g ) ) {
                        a = ( b = c.Ib.Ob( c.Gb.k( g ) ) ) ? this.Ra( a, g, b, a.F, a.o, c, d ) : this.Ra( a, g, K, a.F, a.o, c, null );
                        break a
                    }
                    x( 1 < Q( f ), "Must be a deep set being reverted" )
                }
                a = new Uf( a.F, a.o, b, e )
            } else a = this.Ea( a, b.path, c, d );
            return a
        }
        if ( b.type === Vf ) return b = b.path, Tf( this, a ), this.Sa( a, b, ( a.ab() || K ).da( b ), c, d, !1 );
        throw ib( "Unknown operation type: " + b.type );
    };

    function Tf( a, b ) {
        Wf( a, b.F );
        Wf( a, b.o );
        Wf( a, b.u );
        Wf( a, b.X )
    }

    function Wf( a, b ) {
        x( !b || a.Yb( b ), "Expected an indexed snap" )
    }
    h.Fa = function( a, b, c, d, e ) {
        Tf( this, a );
        if ( b.e() ) return b = this.G( c ), new Uf( a.F, a.o, b, null );
        var f = X( a ) || K,
            g = G( b );
        return 1 === Q( b ) || a.u || f.Y( g ) ? ( c = f.B( G( b ) ).L( R( b ), c ), this.Ra( a, G( b ), c, a.F, a.o, d, e ) ) : a
    };
    h.ae = function( a, b, c, d, e ) {
        Tf( this, a );
        var f = this,
            g = a;
        Xf( c, function( c, l ) {
            var m = b.k( c );
            Yf( a, G( m ) ) && ( g = f.Fa( g, m, l, d, e ) )
        } );
        Xf( c, function( c, l ) {
            var m = b.k( c );
            Yf( a, G( m ) ) || ( g = f.Fa( g, m, l, d, e ) )
        } );
        return g
    };
    h.Ea = function( a, b, c, d ) {
        var e = a.u,
            f = a.X,
            g;
        Tf( this, a );
        if ( a.F ) {
            x( e, "If we have a server snap, we must have an event snap" );
            var k = c.Ya( b, a.u, a.F );
            if ( k )
                if ( b.e() ) e = this.G( k );
                else return g = G( b ), b = e.L( b, k ).B( g ), this.Ra( a, g, b, a.F, a.o, c, d )
        } else if ( a.o )
            if ( e ) {
                var l = !1;
                a.o.ca( L, function( a, b ) {
                    l || e.B( a ).ja( b ) || ( l = !0 );
                    l && ( e = e.I( a, b ) )
                } );
                l && ( e = this.G( e ) )
            } else if ( f && ( x( 0 < Q( b ), "If it were an empty path, we would have an event snap" ), g = G( b ), 1 === Q( b ) || f.Y( g ) ) && ( k = c.Ya( b, f, a.o ) ) ) return b = f.L( b, k ).B( g ), this.Ra( a, g, b, a.F, a.o, c, d );
        return new Uf( a.F, a.o, e, f )
    };
    h.Sa = function( a, b, c, d, e, f ) {
        var g;
        Tf( this, a );
        var k = a.F,
            l = a.o;
        if ( a.F ) k = b.e() ? this.G( c, f ) : this.G( a.F.L( b, c ), f );
        else if ( b.e() ) k = this.G( c, f ), l = null;
        else if ( 1 === Q( b ) && ( a.o || !c.e() ) ) l = a.o || this.Ia( K ), l = this.G( l.L( b, c ), f );
        else if ( a.o && ( g = G( b ), a.o.Y( g ) ) ) var m = a.o.B( g ).L( R( b ), c ),
            l = this.G( a.o.I( g, m ), f );
        g = !1;
        f = a.u;
        m = a.X;
        if ( k !== a.F || l !== a.o )
            if ( k && !f ) f = this.G( d.xa( k ) ), m = null;
            else if ( k && f && !c.e() && k.da( b ).ja( f.da( b ) ) ) g = !0;
        else if ( c = d.Ya( b, f, k || l ) )
            if ( b.e() ) f = this.G( c ), m = null;
            else {
                g = G( b );
                b = R( b );
                a: {
                    f = g;
                    if ( a.u ) m = a.u.B( f );
                    else if ( a.X ) a.X.Y( f ) ? m = a.X.B( f ) : ( x( b.e(), "According to precondition, this must be true" ), m = K );
                    else {
                        if ( b.e() ) {
                            m = c;
                            break a
                        }
                        x( a.F || a.o, "If we do not have event data, we must have server data" );
                        m = ( a.F || a.o ).B( f )
                    }
                    m = m.e() && a.ab() ? a.ab().B( f ).L( b, c ) : m.L( b, c )
                }
                return this.Ra( a, g, m, k, l, d, e )
            } else g = !0;
        x( !g || f === a.u && m === a.X, "We thought we could skip diffing, but we changed the eventCache." );
        return new Uf( k, l, f, m )
    };
    h.$d = function( a, b, c, d, e, f ) {
        if ( !a.F && !a.o && b.e() ) return a;
        Tf( this, a );
        var g = this,
            k = a;
        Xf( c, function( c, m ) {
            var r = b.k( c );
            Yf( a, G( r ) ) && ( k = g.Sa( k, r, m, d, e, f ) )
        } );
        Xf( c, function( c, m ) {
            var r = b.k( c );
            Yf( a, G( r ) ) || ( k = g.Sa( k, r, m, d, e, f ) )
        } );
        return k
    };
    h.Ra = function( a, b, c, d, e ) {
        var f = a.u;
        a = a.X;
        f ? f = this.G( f.I( b, c ) ) : ( a || ( a = this.Ia( K ) ), a = this.G( a.I( b, c ) ) );
        return new Uf( d, e, f, a )
    };
    h.G = function( a ) {
        return this.Ia( a )
    };

    function Yf( a, b ) {
        var c = X( a ),
            d = a.ab();
        return !!( c && c.Y( b ) || d && d.Y( b ) )
    };

    function Zf( a ) {
        this.gb = a;
        this.index = a.m;
        this.gb.ga && n( pc( this.gb ) ) ? ( a = qc( this.gb ), a = this.index.ye( pc( this.gb ), a ) ) : a = this.index.Ae();
        this.Fb = a;
        this.gb.na && n( rc( this.gb ) ) ? ( a = sc( this.gb ), a = this.index.ye( rc( this.gb ), a ) ) : a = this.index.ze();
        this.pb = a
    }
    na( Zf, Pf );
    Zf.prototype.Ia = function( a ) {
        return a.Wd( this.index )
    };
    Zf.prototype.Yb = function( a ) {
        return a.Yb( this.index )
    };
    Zf.prototype.G = function( a, b ) {
        if ( !1 === b ) return Zf.oc.G.call( this, a, !1 );
        if ( a.P() ) return this.Ia( K );
        for ( var c = this.Ia( a ), d = this.Fb, e = this.pb, f = H( this.index ), g = c.Aa( this.index ), k = U( g ); k && 0 < f( d, k ); ) c = c.I( k.name, K ), k = U( g );
        g = c.rb( e, this.index );
        for ( ( k = U( g ) ) && 0 >= f( k, e ) && ( k = U( g ) ); k; ) c = c.I( k.name, K ), k = U( g );
        return c
    };
    Zf.prototype.Fa = function( a, b, c, d, e ) {
        Tf( this, a );
        if ( 1 < Q( b ) ) {
            var f = G( b );
            if ( ( null !== X( a ) ? X( a ) : K ).Y( f ) ) return Zf.oc.Fa.call( this, a, b, c, d, e );
            var g = null !== e ? e : a.ab(),
                g = null !== g && g.Y( f ) ? g.B( f ) : null,
                g = d.k( f ).xa( g );
            return null !== g ? ( b = g.L( R( b ), c ), this.Ra( a, f, b, a.F, a.o, d, e ) ) : a
        }
        return Zf.oc.Fa.call( this, a, b, c, d, e )
    };

    function $f( a ) {
        Zf.call( this, a );
        this.Ma = !( "" === a.Hb ? a.ga : "l" === a.Hb );
        this.bb = tc( a )
    }
    na( $f, Zf );
    $f.prototype.G = function( a, b ) {
        if ( !1 === b ) return $f.oc.G.call( this, a, !1 );
        if ( a.P() ) return this.Ia( K );
        var c = this.Ia( a ),
            d, e, f, g;
        if ( 2 * this.bb < a.Ua() )
            for ( d = this.Ia( K.ib( a.O() ) ), c = this.Ma ? c.Sb( this.pb, this.index ) : c.rb( this.Fb, this.index ), e = U( c ), f = 0; e && f < this.bb; )
                if ( g = this.Ma ? 0 >= H( this.index )( this.Fb, e ) : 0 >= H( this.index )( e, this.pb ) ) d = d.I( e.name, e.K ), f++, e = U( c );
                else break;
        else {
            d = this.Ia( a );
            var k, l, m = H( this.index );
            if ( this.Ma ) {
                c = c.bf( this.index );
                k = this.pb;
                l = this.Fb;
                var r = m,
                    m = function( a, b ) {
                        return -1 * r( a, b )
                    }
            } else c = c.Aa( this.index ), k = this.Fb, l = this.pb;
            f = 0;
            var s = !1;
            for ( e = U( c ); e; ) !s && 0 >= m( k, e ) && ( s = !0 ), ( g = s && f < this.bb && 0 >= m( e, l ) ) ? f++ : d = d.I( e.name, K ), e = U( c )
        }
        return d
    };
    $f.prototype.Ra = function( a, b, c, d, e, f, g ) {
        var k = X( a );
        return !k || k.Ua() < this.bb ? $f.oc.Ra.call( this, a, b, c, d, e, f, g ) : ( b = ag( this, a, b, c, f, g || d ) ) ? a.u ? new Uf( d, e, b, null ) : new Uf( d, e, null, b ) : new Uf( d, e, a.u, a.X )
    };

    function ag( a, b, c, d, e, f ) {
        var g = H( a.index ),
            k;
        k = a.Ma ? function( a, b ) {
            return -1 * g( a, b )
        } : g;
        b = X( b );
        x( b.Ua() === a.bb, "Limit should be full." );
        var l = new I( c, d ),
            m = a.Ma ? ld( b, a.index ) : md( b, a.index );
        x( null != m, "Shouldn't be null, since oldEventCache shouldn't be empty." );
        var r = 0 >= H( a.index )( a.Fb, l ) && 0 >= H( a.index )( l, a.pb );
        if ( b.Y( c ) ) {
            f = e.de( f, m, 1, a.Ma, a.index );
            e = null;
            0 < f.length && ( e = f[ 0 ], e.name === c && ( e = 2 <= f.length ? f[ 1 ] : null ) );
            k = null == e ? 1 : k( e, l );
            if ( r && !d.e() && 0 <= k ) return b.I( c, d );
            c = b.I( c, K );
            return null != e && 0 >= H( a.index )( a.Fb, e ) && 0 >= H( a.index )( e, a.pb ) ? c.I( e.name, e.K ) : c
        }
        return d.e() ? null : r ? 0 <= k( m, l ) ? b.I( c, d ).I( m.name, K ) : null : null
    };

    function bg( a ) {
        this.m = a
    }
    na( bg, Pf );
    bg.prototype.Ia = function( a ) {
        return a.Wd( this.m )
    };
    bg.prototype.Yb = function( a ) {
        return a.Yb( this.m )
    };

    function cg( a ) {
        this.U = a;
        this.m = a.w.m
    }

    function dg( a, b, c, d ) {
        var e = [],
            f = a.m,
            g = La( Ka( b, function( a ) {
                return "child_changed" === a.type && f.df( a.$f, a.Wa )
            } ), function( a ) {
                return new W( "child_moved", a.Wa, a.nb )
            } ),
            k = Pa( b, function( a ) {
                return "child_removed" !== a.type && "child_added" !== a.type
            } );
        for ( la( Ra, b, k, 0 ).apply( null, g ); 0 < b.length; ) {
            var g = b[ 0 ].type,
                k = eg( b, g ),
                l = b.slice( 0, k );
            b = b.slice( k );
            "value" === g || "children_added" === g || "children_removed" === g ? x( 1 === l.length, "We should not have more than one of these at a view" ) : Ta( l, q( a.Lf, a ) );
            e = e.concat( fg( a, d, l, c ) )
        }
        return e
    }

    function eg( a, b ) {
        var c = Pa( a, function( a ) {
            return a.type !== b
        } );
        return -1 === c ? a.length : c
    }

    function fg( a, b, c, d ) {
        for ( var e = [], f = 0; f < c.length; ++f )
            for ( var g = c[ f ], k = null, l = null, m = 0; m < b.length; ++m ) {
                var r = b[ m ];
                if ( r.pf( g.type ) ) {
                    if ( !k && !l )
                        if ( "children_added" === g.type ) {
                            var s = a,
                                y = g.Wa,
                                l = [];
                            if ( !y.P() && !y.e() )
                                for ( var s = y.Aa( s.m ), y = null, N = U( s ); N; ) {
                                    var Je = new W( "child_added", N.K, N.name );
                                    Je.Rc = y;
                                    l.push( Je );
                                    y = N.name;
                                    N = U( s )
                                }
                        } else if ( "children_removed" === g.type ) {
                        if ( s = a, y = g.Wa, l = [], !y.P() && !y.e() )
                            for ( s = y.Aa( s.m ), y = U( s ); y; ) l.push( new W( "child_removed", y.K, y.name ) ), y = U( s )
                    } else k = g, "value" !== k.type && "child_removed" !== k.type && ( k.Rc = d.af( k.nb, k.Wa, a.m ) );
                    if ( k ) e.push( r.createEvent( k, a.U ) );
                    else
                        for ( s = 0; s < l.length; ++s ) e.push( r.createEvent( l[ s ], a.U ) )
                }
            }
        return e
    }
    cg.prototype.Lf = function( a, b ) {
        if ( null == a.nb || null == b.nb ) throw ib( "Should only compare child_ events." );
        return this.m.compare( new I( a.nb, a.Wa ), new I( b.nb, b.Wa ) )
    };

    function gg( a, b ) {
        this.U = a;
        var c = a.w;
        wc( c ) ? ( this.ec = new bg( c.m ), this.ld = Kf ) : c.ka ? ( this.ec = new $f( c ), this.ld = new Of( tc( c ), c.m, this.ec.Ma ) ) : ( this.ec = new Zf( c ), this.ld = Kf );
        c = this.ec;
        this.ha = new Uf( b.F && c.G( b.F, !1 ), b.o && c.G( b.o, !1 ), b.u && c.G( b.u ), b.X && c.G( b.X ) );
        this.ya = [];
        this.le = new cg( a )
    }

    function hg( a ) {
        return a.U
    }
    h = gg.prototype;
    h.ab = function() {
        return this.ha.ab()
    };
    h.za = function( a ) {
        var b = this.ha.za();
        return b && ( wc( this.U.w ) || !a.e() && !b.B( G( a ) ).e() ) ? b.da( a ) : null
    };
    h.e = function() {
        return 0 === this.ya.length
    };
    h.Jb = function( a ) {
        this.ya.push( a )
    };
    h.hb = function( a, b ) {
        var c = [];
        if ( b ) {
            x( null == a, "A cancel should cancel all event registrations." );
            var d = this.U.path;
            Ja( this.ya, function( a ) {
                ( a = a.Te( b, d ) ) && c.push( a )
            } )
        }
        if ( a ) {
            for ( var e = [], f = 0; f < this.ya.length; ++f ) {
                var g = this.ya[ f ];
                if ( !g.matches( a ) ) e.push( g );
                else if ( a.cf() ) {
                    e = e.concat( this.ya.slice( f + 1 ) );
                    break
                }
            }
            this.ya = e
        } else this.ya = [];
        return c
    };
    h.Xa = function( a, b, c ) {
        a.type === Rf && null !== a.source.fc && ( x( this.ha.za(), "We should always have a full cache before handling merges" ), x( !!this.ha.u, "Missing event cache, even though we have a server cache" ) );
        var d = this.ha;
        b = this.ec.Xa( d, a, b, c );
        Tf( this.ec, b );
        this.ha = b;
        return X( b ) !== X( d ) ? ( a = Lf( this.ld, d, b, a.path ), d = X( b ), dg( this.le, a, d, this.ya ) ) : b.u && !d.u ? ( x( X( b ) === X( d ), "Caches should be the same." ), d = X( b ), dg( this.le, [ new W( "value", d ) ], d, this.ya ) ) : []
    };

    function Uf( a, b, c, d ) {
        this.F = a;
        this.o = b;
        this.u = c;
        this.X = d;
        x( null == a || null == b, "Only one of serverSnap / serverChildren can be non-null." );
        x( null == c || null == d, "Only one of eventSnap / eventChildren can be non-null." )
    }

    function X( a ) {
        return a.u || a.X
    }
    Uf.prototype.ab = function() {
        return this.F || this.o
    };
    Uf.prototype.za = function() {
        return this.F
    };
    var ig = new Uf( null, null, null, null );

    function jg( a, b ) {
        this.value = a;
        this.children = b || kg
    }
    var kg = new Lc( function( a, b ) {
            return a === b ? 0 : a < b ? -1 : 1
        } ),
        lg = new jg( null );

    function mg( a ) {
        var b = lg;
        A( a, function( a, d ) {
            b = b.set( new P( d ), a )
        } );
        return b
    }
    h = jg.prototype;
    h.e = function() {
        return null === this.value && this.children.e()
    };

    function ng( a, b, c ) {
        if ( null != a.value && c( a.value ) ) return {
            path: S,
            value: a.value
        };
        if ( b.e() ) return null;
        var d = G( b );
        a = a.children.get( d );
        return null !== a ? ( b = ng( a, R( b ), c ), null != b ? {
            path: ( new P( d ) ).k( b.path ),
            value: b.value
        } : null ) : null
    }

    function og( a, b ) {
        return ng( a, b, function() {
            return !0
        } )
    }
    h.subtree = function( a ) {
        if ( a.e() ) return this;
        var b = this.children.get( G( a ) );
        return null !== b ? b.subtree( R( a ) ) : lg
    };
    h.set = function( a, b ) {
        if ( a.e() ) return new jg( b, this.children );
        var c = G( a ),
            d = ( this.children.get( c ) || lg ).set( R( a ), b ),
            c = this.children.Ja( c, d );
        return new jg( this.value, c )
    };
    h.remove = function( a ) {
        if ( a.e() ) return this.children.e() ? lg : new jg( null, this.children );
        var b = G( a ),
            c = this.children.get( b );
        return c ? ( a = c.remove( R( a ) ), b = a.e() ? this.children.remove( b ) : this.children.Ja( b, a ), null === this.value && b.e() ? lg : new jg( this.value, b ) ) : this
    };
    h.get = function( a ) {
        if ( a.e() ) return this.value;
        var b = this.children.get( G( a ) );
        return b ? b.get( R( a ) ) : null
    };

    function pg( a, b, c ) {
        if ( b.e() ) return c;
        var d = G( b );
        b = pg( a.children.get( d ) || lg, R( b ), c );
        d = b.e() ? a.children.remove( d ) : a.children.Ja( d, b );
        return new jg( a.value, d )
    }

    function qg( a, b ) {
        return rg( a, S, b )
    }

    function rg( a, b, c ) {
        var d = {};
        a.children.Ba( function( a, f ) {
            d[ a ] = rg( f, b.k( a ), c )
        } );
        return c( b, a.value, d )
    }

    function sg( a, b, c ) {
        return tg( a, b, S, c )
    }

    function tg( a, b, c, d ) {
        var e = a.value ? d( c, a.value ) : !1;
        if ( e ) return e;
        if ( b.e() ) return null;
        e = G( b );
        return ( a = a.children.get( e ) ) ? tg( a, R( b ), c.k( e ), d ) : null
    }

    function ug( a, b, c ) {
        if ( !b.e() ) {
            var d = !0;
            a.value && ( d = c( S, a.value ) );
            !0 === d && ( d = G( b ), ( a = a.children.get( d ) ) && vg( a, R( b ), S.k( d ), c ) )
        }
    }

    function vg( a, b, c, d ) {
        if ( b.e() ) return a;
        a.value && d( c, a.value );
        var e = G( b );
        return ( a = a.children.get( e ) ) ? vg( a, R( b ), c.k( e ), d ) : lg
    }

    function Xf( a, b ) {
        wg( a, S, b )
    }

    function wg( a, b, c ) {
        a.children.Ba( function( a, e ) {
            wg( e, b.k( a ), c )
        } );
        a.value && c( b, a.value )
    }

    function xg( a, b ) {
        a.children.Ba( function( a, d ) {
            d.value && b( a, d.value )
        } )
    };

    function yg() {
        this.qa = {}
    }
    h = yg.prototype;
    h.e = function() {
        return Bd( this.qa )
    };
    h.Xa = function( a, b, c ) {
        var d = a.source.fc;
        if ( null !== d ) return d = v( this.qa, d ), x( null != d, "SyncTree gave us an op for an invalid query." ), d.Xa( a, b, c );
        var e = [];
        A( this.qa, function( d ) {
            e = e.concat( d.Xa( a, b, c ) )
        } );
        return e
    };
    h.Jb = function( a, b, c, d, e ) {
        var f = a.Da(),
            g = v( this.qa, f );
        g || ( c = ( g = c.xa( d ) ) ? null : c.ce( e ), d = new Uf( d, e, g, c ), g = new gg( a, d ), this.qa[ f ] = g );
        g.Jb( b );
        a = g;
        ( f = X( a.ha ) ) ? ( d = Lf( a.ld, ig, a.ha, S ), b = dg( a.le, d, f, b ? [ b ] : a.ya ) ) : b = [];
        return b
    };
    h.hb = function( a, b, c ) {
        var d = a.Da(),
            e = [],
            f = [],
            g = null != zg( this );
        if ( "default" === d ) {
            var k = this;
            A( this.qa, function( a, d ) {
                f = f.concat( a.hb( b, c ) );
                a.e() && ( delete k.qa[ d ], wc( a.U.w ) || e.push( a.U ) )
            } )
        } else {
            var l = v( this.qa, d );
            l && ( f = f.concat( l.hb( b, c ) ), l.e() && ( delete this.qa[ d ], wc( l.U.w ) || e.push( l.U ) ) )
        }
        g && null == zg( this ) && e.push( new O( a.g, a.path ) );
        return {
            mg: e,
            Pf: f
        }
    };

    function Ag( a ) {
        return Ka( xd( a.qa ), function( a ) {
            return !wc( a.U.w )
        } )
    }
    h.za = function( a ) {
        var b = null;
        A( this.qa, function( c ) {
            b = b || c.za( a )
        } );
        return b
    };

    function Bg( a, b ) {
        if ( wc( b.w ) ) return zg( a );
        var c = b.Da();
        return v( a.qa, c )
    }

    function zg( a ) {
        return Ad( a.qa, function( a ) {
            return wc( a.U.w )
        } ) || null
    };

    function Cg() {
        this.V = lg;
        this.ra = [];
        this.Ec = -1
    }

    function Dg( a, b ) {
        var c = Pa( a.ra, function( a ) {
            return a.Xd === b
        } );
        x( 0 <= c, "removeWrite called with nonexistent writeId." );
        var d = a.ra[ c ];
        a.ra.splice( c, 1 );
        for ( var e = !1, f = !1, g = !1, k = a.ra.length - 1; !e && 0 <= k; ) {
            var l = a.ra[ k ];
            k >= c && Eg( l, d.path ) ? e = !0 : !f && d.path.contains( l.path ) && ( k >= c ? f = !0 : g = !0 );
            k--
        }
        e || ( f || g ? Fg( a ) : d.Oa ? a.V = a.V.remove( d.path ) : A( d.children, function( b, c ) {
            a.V = a.V.remove( d.path.k( c ) )
        } ) );
        c = d.path;
        if ( og( a.V, c ) ) {
            if ( g ) return c;
            x( e, "Must have found a shadow" );
            return null
        }
        return c
    }
    h = Cg.prototype;
    h.Ob = function( a ) {
        var b = og( this.V, a );
        if ( b ) {
            var c = b.value;
            a = T( b.path, a );
            return c.da( a )
        }
        return null
    };
    h.xa = function( a, b, c, d ) {
        var e, f;
        if ( c || d ) return e = this.V.subtree( a ), !d && e.e() ? b : d || null !== b || null !== e.value ? ( e = Gg( this.ra, function( b ) {
            return ( b.visible || d ) && ( !c || !( 0 <= Ia( c, b.Xd ) ) ) && ( b.path.contains( a ) || a.contains( b.path ) )
        }, a ), f = b || K, Xf( e, function( a, b ) {
            f = f.L( a, b )
        } ), f ) : null;
        if ( e = og( this.V, a ) ) return b = T( e.path, a ), e.value.da( b );
        e = this.V.subtree( a );
        return e.e() ? b : b || e.value ? ( f = b || K, Xf( e, function( a, b ) {
            f = f.L( a, b )
        } ), f ) : null
    };
    h.ce = function( a, b ) {
        var c = !1,
            d = K,
            e = this.Ob( a );
        if ( e ) return e.P() || e.ca( L, function( a, b ) {
            d = d.I( a, b )
        } ), d;
        if ( b ) return d = b, xg( this.V.subtree( a ), function( a, b ) {
            d = d.I( a, b )
        } ), d;
        xg( this.V.subtree( a ), function( a, b ) {
            c = !0;
            d = d.I( a, b )
        } );
        return c ? d : null
    };
    h.Ya = function( a, b, c, d ) {
        x( c || d, "Either existingEventSnap or existingServerSnap must exist" );
        a = a.k( b );
        if ( og( this.V, a ) ) return null;
        a = this.V.subtree( a );
        if ( a.e() ) return d.da( b );
        var e = d.da( b );
        Xf( a, function( a, b ) {
            e = e.L( a, b )
        } );
        return e
    };
    h.de = function( a, b, c, d, e, f ) {
        var g;
        a = this.V.subtree( a );
        a.value ? g = a.value : b && ( g = b, Xf( a, function( a, b ) {
            g = g.L( a, b )
        } ) );
        if ( g ) {
            b = [];
            g = g.Wd( f );
            a = H( f );
            e = e ? g.Sb( c, f ) : g.rb( c, f );
            for ( f = U( e ); f && b.length < d; ) 0 !== a( f, c ) && b.push( f ), f = U( e );
            return b
        }
        return []
    };

    function Eg( a, b ) {
        return a.Oa ? a.path.contains( b ) : !!zd( a.children, function( c, d ) {
            return a.path.k( d ).contains( b )
        } )
    }

    function Fg( a ) {
        a.V = Gg( a.ra, Hg, S );
        a.Ec = 0 < a.ra.length ? a.ra[ a.ra.length - 1 ].Xd : -1
    }

    function Hg( a ) {
        return a.visible
    }

    function Gg( a, b, c ) {
        for ( var d = lg, e = 0; e < a.length; ++e ) {
            var f = a[ e ];
            if ( b( f ) ) {
                var g = f.path,
                    k;
                f.Oa ? ( c.contains( g ) ? ( k = T( c, g ), f = f.Oa ) : ( k = S, f = f.Oa.da( T( g, c ) ) ), d = Ig( d, k, f ) ) : d = Jg( d, f.path, f.children )
            }
        }
        return d
    }

    function Ig( a, b, c ) {
        var d = og( a, b );
        if ( d ) {
            var e = d.value,
                d = d.path;
            b = T( d, b );
            c = e.L( b, c );
            a = pg( a, d, new jg( c ) )
        } else a = pg( a, b, new jg( c ) );
        return a
    }

    function Jg( a, b, c ) {
        var d = og( a, b );
        if ( d ) {
            var e = d.value,
                d = d.path,
                f = T( d, b ),
                g = e;
            A( c, function( a, b ) {
                g = g.L( f.k( b ), a )
            } );
            a = pg( a, d, new jg( g ) )
        } else A( c, function( c, d ) {
            a = pg( a, b.k( d ), new jg( c ) )
        } );
        return a
    }

    function Kg( a, b ) {
        this.Gb = a;
        this.Ib = b
    }
    h = Kg.prototype;
    h.Ob = function() {
        return this.Ib.Ob( this.Gb )
    };
    h.xa = function( a, b, c ) {
        return this.Ib.xa( this.Gb, a, b, c )
    };
    h.ce = function( a ) {
        return this.Ib.ce( this.Gb, a )
    };
    h.Ya = function( a, b, c ) {
        return this.Ib.Ya( this.Gb, a, b, c )
    };
    h.de = function( a, b, c, d, e ) {
        return this.Ib.de( this.Gb, a, b, c, d, e )
    };
    h.k = function( a ) {
        return new Kg( this.Gb.k( a ), this.Ib )
    };

    function Lg( a, b, c ) {
        this.type = Qf;
        this.source = a;
        this.path = b;
        this.Oa = c
    }
    Lg.prototype.Mc = function( a ) {
        return this.path.e() ? new Lg( this.source, S, this.Oa.B( a ) ) : new Lg( this.source, R( this.path ), this.Oa )
    };

    function Mg( a, b ) {
        this.type = Sf;
        this.source = Ng;
        this.path = a;
        this.sf = b
    }
    Mg.prototype.Mc = function() {
        return this.path.e() ? this : new Mg( R( this.path ), this.sf )
    };

    function Og( a, b ) {
        this.type = Vf;
        this.source = a;
        this.path = b
    }
    Og.prototype.Mc = function() {
        return this.path.e() ? new Og( this.source, S ) : new Og( this.source, R( this.path ) )
    };

    function Pg( a, b, c ) {
        this.type = Rf;
        this.source = a;
        this.path = b;
        this.children = c
    }
    Pg.prototype.Mc = function( a ) {
        if ( this.path.e() ) return a = this.children.subtree( new P( a ) ), a.e() ? null : a.value ? new Lg( this.source, S, a.value ) : new Pg( this.source, S, a );
        x( G( this.path ) === a, "Can't get a merge for a child not on the path of the operation" );
        return new Pg( this.source, R( this.path ), this.children )
    };
    var Qf = 0,
        Rf = 1,
        Sf = 2,
        Vf = 3;

    function Qg( a, b, c, d ) {
        this.$e = a;
        this.Ze = b;
        this.fc = c;
        this.wf = d;
        x( !d || b, "Tagged queries must be from server." )
    }
    var Ng = new Qg( !0, !1, null, !1 ),
        Rg = new Qg( !1, !0, null, !1 );

    function Sg( a ) {
        this.ma = lg;
        this.Bb = new Cg;
        this.Zc = {};
        this.gc = {};
        this.Fc = a
    }
    h = Sg.prototype;
    h.Fa = function( a, b, c, d ) {
        var e = this.Bb,
            f = d;
        x( c > e.Ec, "Stacking an older write on top of newer ones" );
        n( f ) || ( f = !0 );
        e.ra.push( {
            path: a,
            Oa: b,
            Xd: c,
            visible: f
        } );
        f && ( e.V = Ig( e.V, a, b ) );
        e.Ec = c;
        return d ? Tg( this, new Lg( Ng, a, b ) ) : []
    };
    h.ae = function( a, b, c ) {
        var d = this.Bb;
        x( c > d.Ec, "Stacking an older merge on top of newer ones" );
        d.ra.push( {
            path: a,
            children: b,
            Xd: c,
            visible: !0
        } );
        d.V = Jg( d.V, a, b );
        d.Ec = c;
        b = mg( b );
        return Tg( this, new Pg( Ng, a, b ) )
    };
    h.Ea = function( a, b ) {
        b = b || !1;
        var c = Dg( this.Bb, a );
        return null == c ? [] : Tg( this, new Mg( c, b ) )
    };
    h.Sa = function( a, b ) {
        return Tg( this, new Lg( Rg, a, b ) )
    };
    h.$d = function( a, b ) {
        var c = mg( b );
        return Tg( this, new Pg( Rg, a, c ) )
    };

    function Ug( a, b, c, d ) {
        d = Cd( a.Zc, "_" + d );
        if ( null != d ) {
            var e = Vg( d );
            d = e.path;
            e = e.fc;
            b = T( d, b );
            c = new Lg( new Qg( !1, !0, e, !0 ), b, c );
            return Wg( a, d, c )
        }
        return []
    }

    function Xg( a, b, c, d ) {
        if ( d = Cd( a.Zc, "_" + d ) ) {
            var e = Vg( d );
            d = e.path;
            e = e.fc;
            b = T( d, b );
            c = mg( c );
            c = new Pg( new Qg( !1, !0, e, !0 ), b, c );
            return Wg( a, d, c )
        }
        return []
    }
    h.Jb = function( a, b ) {
        var c = a.path,
            d = null,
            e = !1;
        ug( this.ma, c, function( a, b ) {
            var f = T( a, c );
            d = b.za( f );
            e = e || null != zg( b );
            return !d
        } );
        var f = this.ma.get( c );
        f ? ( e = e || null != zg( f ), d = d || f.za( S ) ) : ( f = new yg, this.ma = this.ma.set( c, f ) );
        var g = null;
        if ( !d ) {
            var k = !1,
                g = K;
            xg( this.ma.subtree( c ), function( a, b ) {
                var c = b.za( S );
                c && ( k = !0, g = g.I( a, c ) )
            } );
            k || ( g = null )
        }
        var l = null != Bg( f, a );
        if ( !l && !wc( a.w ) ) {
            var m = Yg( a );
            x( !( m in this.gc ), "View does not exist, but we have a tag" );
            var r = Zg++;
            this.gc[ m ] = r;
            this.Zc[ "_" + r ] = m
        }
        m = f.Jb( a, b, new Kg( c, this.Bb ), d, g );
        l || e || ( f = Bg( f, a ), m = m.concat( $g( this, a, f ) ) );
        return m
    };
    h.hb = function( a, b, c ) {
        var d = a.path,
            e = this.ma.get( d ),
            f = [];
        if ( e && ( "default" === a.Da() || null != Bg( e, a ) ) ) {
            f = e.hb( a, b, c );
            e.e() && ( this.ma = this.ma.remove( d ) );
            e = f.mg;
            f = f.Pf;
            b = -1 !== Pa( e, function( a ) {
                return wc( a.w )
            } );
            var g = sg( this.ma, d, function( a, b ) {
                return null != zg( b )
            } );
            if ( b && !g && ( d = this.ma.subtree( d ), !d.e() ) )
                for ( var d = ah( d ), k = 0; k < d.length; ++k ) {
                    var l = d[ k ],
                        m = l.U,
                        l = bh( this, l );
                    this.Fc.Le( m, ch( this, m ), l.qd, l.H )
                }
            if ( !g && 0 < e.length && !c )
                if ( b ) this.Fc.Od( a, null );
                else {
                    var r = this;
                    Ja( e, function( a ) {
                        a.Da();
                        var b = r.gc[ Yg( a ) ];
                        r.Fc.Od( a, b )
                    } )
                }
            dh( this, e )
        }
        return f
    };
    h.xa = function( a, b ) {
        var c = this.Bb,
            d = sg( this.ma, a, function( b, c ) {
                var d = T( b, a );
                if ( d = c.za( d ) ) return d
            } );
        return c.xa( a, d, b, !0 )
    };

    function ah( a ) {
        return qg( a, function( a, c, d ) {
            if ( c && null != zg( c ) ) return [ zg( c ) ];
            var e = [];
            c && ( e = Ag( c ) );
            A( d, function( a ) {
                e = e.concat( a )
            } );
            return e
        } )
    }

    function dh( a, b ) {
        for ( var c = 0; c < b.length; ++c ) {
            var d = b[ c ];
            if ( !wc( d.w ) ) {
                var d = Yg( d ),
                    e = a.gc[ d ];
                delete a.gc[ d ];
                delete a.Zc[ "_" + e ]
            }
        }
    }

    function $g( a, b, c ) {
        var d = b.path,
            e = ch( a, b );
        c = bh( a, c );
        b = a.Fc.Le( b, e, c.qd, c.H );
        d = a.ma.subtree( d );
        if ( e ) x( null == zg( d.value ), "If we're adding a query, it shouldn't be shadowed" );
        else
            for ( e = qg( d, function( a, b, c ) {
                    if ( !a.e() && b && null != zg( b ) ) return [ hg( zg( b ) ) ];
                    var d = [];
                    b && ( d = d.concat( La( Ag( b ), function( a ) {
                        return a.U
                    } ) ) );
                    A( c, function( a ) {
                        d = d.concat( a )
                    } );
                    return d
                } ), d = 0; d < e.length; ++d ) c = e[ d ], a.Fc.Od( c, ch( a, c ) );
        return b
    }

    function bh( a, b ) {
        var c = b.U,
            d = ch( a, c );
        return {
            qd: function() {
                return ( b.ab() || K ).hash()
            },
            H: function( b, f ) {
                if ( "ok" === b ) {
                    if ( f && "object" === typeof f && u( f, "w" ) ) {
                        var g = v( f, "w" );
                        ea( g ) && 0 <= Ia( g, "no_index" ) && z( "Using an unspecified index. Consider adding " + ( '".indexOn": "' + c.w.m.toString() + '"' ) + " at " + c.path.toString() + " to your security rules for better performance" )
                    }
                    if ( d ) {
                        var k = c.path;
                        if ( g = Cd( a.Zc, "_" + d ) ) var l = Vg( g ),
                            g = l.path,
                            l = l.fc,
                            k = T( g, k ),
                            k = new Og( new Qg( !1, !0, l, !0 ), k ),
                            g = Wg( a, g, k );
                        else g = []
                    } else g = Tg( a, new Og( Rg, c.path ) );
                    return g
                }
                g = "Unknown Error";
                "too_big" === b ? g = "The data requested exceeds the maximum size that can be accessed with a single request." : "permission_denied" == b ? g = "Client doesn't have permission to access the desired data." : "unavailable" == b && ( g = "The service is unavailable" );
                g = Error( b + ": " + g );
                g.code = b.toUpperCase();
                return a.hb( c, null, g )
            }
        }
    }

    function Yg( a ) {
        return a.path.toString() + "$" + a.Da()
    }

    function Vg( a ) {
        var b = a.indexOf( "$" );
        x( -1 !== b && b < a.length - 1, "Bad queryKey." );
        return {
            fc: a.substr( b + 1 ),
            path: new P( a.substr( 0, b ) )
        }
    }

    function ch( a, b ) {
        var c = Yg( b );
        return v( a.gc, c )
    }
    var Zg = 1;

    function Wg( a, b, c ) {
        var d = a.ma.get( b );
        x( d, "Missing sync point for query tag that we're tracking" );
        return d.Xa( c, new Kg( b, a.Bb ), null )
    }

    function Tg( a, b ) {
        return eh( a, b, a.ma, null, new Kg( S, a.Bb ) )
    }

    function eh( a, b, c, d, e ) {
        if ( b.path.e() ) return fh( a, b, c, d, e );
        var f = c.get( S );
        null == d && null != f && ( d = f.za( S ) );
        var g = [],
            k = G( b.path ),
            l = b.Mc( k );
        if ( ( c = c.children.get( k ) ) && l ) var m = d ? d.B( k ) : null,
            k = e.k( k ),
            g = g.concat( eh( a, l, c, m, k ) );
        f && ( g = g.concat( f.Xa( b, e, d ) ) );
        return g
    }

    function fh( a, b, c, d, e ) {
        var f = c.get( S );
        null == d && null != f && ( d = f.za( S ) );
        var g = [];
        c.children.Ba( function( c, f ) {
            var m = d ? d.B( c ) : null,
                r = e.k( c ),
                s = b.Mc( c );
            s && ( g = g.concat( fh( a, s, f, m, r ) ) )
        } );
        f && ( g = g.concat( f.Xa( b, e, d ) ) );
        return g
    };

    function gh( a ) {
        this.Q = a;
        this.Qa = Ld( a );
        this.Z = new Te;
        this.zd = 1;
        this.S = new xe( this.Q, q( this.Cd, this ), q( this.Ad, this ), q( this.Ee, this ) );
        this.ug = Md( a, q( function() {
            return new Id( this.Qa, this.S )
        }, this ) );
        this.pc = new Fc;
        this.qe = new Se;
        var b = this;
        this.ud = new Sg( {
            Le: function( a, d, e, f ) {
                d = [];
                e = b.qe.Wc.da( a.path );
                e.e() || ( d = b.ud.Sa( a.path, e ), setTimeout( function() {
                    f( "ok" )
                }, 0 ) );
                return d
            },
            Od: ba
        } );
        hh( this, "connected", !1 );
        this.ea = new Pe;
        this.T = new tf( a, q( this.S.T, this.S ), q( this.S.Pe, this.S ), q( this.Be, this ) );
        this.jd = 0;
        this.re = null;
        this.M = new Sg( {
            Le: function( a, d, e, f ) {
                Be( b.S, a, e, d, function( d, e ) {
                    var l = f( d, e );
                    Xe( b.Z, a.path, l )
                } );
                return []
            },
            Od: function( a, d ) {
                var e = b.S,
                    f = a.path.toString(),
                    g = a.Da();
                e.f( "Unlisten called for " + f + " " + g );
                if ( De( e, f, g ) && e.ia ) {
                    var k = Dc( a );
                    e.f( "Unlisten on " + f + " for " + g );
                    f = {
                        p: f
                    };
                    d && ( f.q = k, f.t = d );
                    e.wa( "n", f )
                }
            }
        } )
    }
    h = gh.prototype;
    h.toString = function() {
        return ( this.Q.Cb ? "https://" : "http://" ) + this.Q.host
    };
    h.name = function() {
        return this.Q.yb
    };

    function ih( a ) {
        var b = new P( ".info/serverTimeOffset" );
        a = a.qe.Wc.da( b ).N() || 0;
        return ( new Date ).getTime() + a
    }

    function jh( a ) {
        a = a = {
            timestamp: ih( a )
        };
        a.timestamp = a.timestamp || ( new Date ).getTime();
        return a
    }
    h.Cd = function( a, b, c, d ) {
        this.jd++;
        var e = new P( a );
        b = this.re ? this.re( a, b ) : b;
        a = [];
        d ? c ? ( b = fd( b, function( a ) {
            return J( a )
        } ), a = Xg( this.M, e, b, d ) ) : ( b = J( b ), a = Ug( this.M, e, b, d ) ) : c ? ( d = fd( b, function( a ) {
            return J( a )
        } ), a = this.M.$d( e, d ) ) : ( d = J( b ), a = this.M.Sa( e, d ) );
        d = e;
        0 < a.length && ( d = kh( this, e ) );
        Xe( this.Z, d, a )
    };
    h.Ad = function( a ) {
        hh( this, "connected", a );
        !1 === a && lh( this )
    };
    h.Ee = function( a ) {
        var b = this;
        Cb( a, function( a, d ) {
            hh( b, d, a )
        } )
    };
    h.Be = function( a ) {
        hh( this, "authenticated", a )
    };

    function hh( a, b, c ) {
        b = new P( "/.info/" + b );
        c = J( c );
        var d = a.qe;
        d.Wc = d.Wc.L( b, c );
        c = a.ud.Sa( b, c );
        Xe( a.Z, b, c )
    }
    h.Db = function( a, b, c, d ) {
        this.f( "set", {
            path: a.toString(),
            value: b,
            Cg: c
        } );
        var e = jh( this );
        b = J( b, c );
        var e = If( b, e ),
            f = this.zd++,
            e = this.M.Fa( a, e, f, !0 );
        Ue( this.Z, e );
        var g = this;
        this.S.put( a.toString(), b.N( !0 ), function( b, c ) {
            var e = "ok" === b;
            e || z( "set at " + a + " failed: " + b );
            e = g.M.Ea( f, !e );
            Xe( g.Z, a, e );
            mh( d, b, c )
        } );
        e = nh( this, a );
        kh( this, e );
        Xe( this.Z, e, [] )
    };
    h.update = function( a, b, c ) {
        this.f( "update", {
            path: a.toString(),
            value: b
        } );
        var d = !0,
            e = jh( this ),
            f = {};
        A( b, function( a, b ) {
            d = !1;
            var c = J( a );
            f[ b ] = If( c, e )
        } );
        if ( d ) kb( "update() called with empty data.  Don't do anything." ), mh( c, "ok" );
        else {
            var g = this.zd++,
                k = this.M.ae( a, f, g );
            Ue( this.Z, k );
            var l = this;
            Ke( this.S, a.toString(), b, function( b, d ) {
                x( "ok" === b || "permission_denied" === b, "merge at " + a + " failed." );
                var e = "ok" === b;
                e || z( "update at " + a + " failed: " + b );
                var e = l.M.Ea( g, !e ),
                    f = a;
                0 < e.length && ( f = kh( l, a ) );
                Xe( l.Z, f, e );
                mh( c, b, d )
            } );
            b = nh( this, a );
            kh( this, b );
            Xe( this.Z, a, [] )
        }
    };

    function lh( a ) {
        a.f( "onDisconnectEvents" );
        var b = jh( a ),
            c = [];
        Re( Hf( a.ea, b ), S, function( b, e ) {
            c = c.concat( a.M.Sa( b, e ) );
            var f = nh( a, b );
            kh( a, f )
        } );
        a.ea = new Pe;
        Xe( a.Z, S, c )
    }
    h.Ce = function( a, b ) {
        var c = this;
        this.S.Ce( a.toString(), function( d, e ) {
            "ok" === d && Qe( c.ea, a );
            mh( b, d, e )
        } )
    };

    function oh( a, b, c, d ) {
        var e = J( c );
        Fe( a.S, b.toString(), e.N( !0 ), function( c, g ) {
            "ok" === c && a.ea.ic( b, e );
            mh( d, c, g )
        } )
    }

    function ph( a, b, c, d, e ) {
        var f = J( c, d );
        Fe( a.S, b.toString(), f.N( !0 ), function( c, d ) {
            "ok" === c && a.ea.ic( b, f );
            mh( e, c, d )
        } )
    }

    function qh( a, b, c, d ) {
        var e = !0,
            f;
        for ( f in c ) e = !1;
        e ? ( kb( "onDisconnect().update() called with empty data.  Don't do anything." ), mh( d, "ok" ) ) : He( a.S, b.toString(), c, function( e, f ) {
            if ( "ok" === e )
                for ( var l in c ) {
                    var m = J( c[ l ] );
                    a.ea.ic( b.k( l ), m )
                }
            mh( d, e, f )
        } )
    }

    function Bc( a, b, c ) {
        c = ".info" === G( b.path ) ? a.ud.Jb( b, c ) : a.M.Jb( b, c );
        Cc( a.Z, b.path, c )
    }
    h.tb = function() {
        this.S.tb()
    };
    h.kc = function() {
        this.S.kc()
    };
    h.Me = function( a ) {
        if ( "undefined" !== typeof console ) {
            a ? ( this.Nd || ( this.Nd = new Hd( this.Qa ) ), a = this.Nd.get() ) : a = this.Qa.get();
            var b = Ma( yd( a ), function( a, b ) {
                    return Math.max( b.length, a )
                }, 0 ),
                c;
            for ( c in a ) {
                for ( var d = a[ c ], e = c.length; e < b + 2; e++ ) c += " ";
                console.log( c + d )
            }
        }
    };
    h.Ne = function( a ) {
        Gd( this.Qa, a );
        this.ug.uf[ a ] = !0
    };
    h.f = function( a ) {
        kb( "r:" + this.S.id + ":", arguments )
    };

    function mh( a, b, c ) {
        a && Fb( function() {
            if ( "ok" == b ) a( null );
            else {
                var d = ( b || "error" ).toUpperCase(),
                    e = d;
                c && ( e += ": " + c );
                e = Error( e );
                e.code = d;
                a( e )
            }
        } )
    };

    function rh( a, b, c, d, e ) {
        function f() {}
        a.f( "transaction on " + b );
        var g = new O( a, b );
        g.zb( "value", f );
        c = {
            path: b,
            update: c,
            H: d,
            status: null,
            lf: hb(),
            Qe: e,
            rf: 0,
            Vd: function() {
                g.bc( "value", f )
            },
            Yd: null,
            sa: null,
            fd: null,
            gd: null,
            hd: null
        };
        d = a.M.xa( b, void 0 ) || K;
        c.fd = d;
        d = c.update( d.N() );
        if ( n( d ) ) {
            Tb( "transaction failed: Data returned ", d );
            c.status = 1;
            e = Gc( a.pc, b );
            var k = e.ta() || [];
            k.push( c );
            Hc( e, k );
            "object" === typeof d && null !== d && u( d, ".priority" ) ? ( k = v( d, ".priority" ), x( Rb( k ), "Invalid priority returned by transaction. Priority must be a valid string, finite number, server value, or null." ) ) : k = ( a.M.xa( b ) || K ).O().N();
            e = jh( a );
            d = J( d, k );
            e = If( d, e );
            c.gd = d;
            c.hd = e;
            c.sa = a.zd++;
            c = a.M.Fa( b, e, c.sa, c.Qe );
            Xe( a.Z, b, c );
            sh( a )
        } else c.Vd(), c.gd = null, c.hd = null, c.H && ( a = new C( c.fd, new O( a, c.path ), L ), c.H( null, !1, a ) )
    }

    function sh( a, b ) {
        var c = b || a.pc;
        b || th( a, c );
        if ( null !== c.ta() ) {
            var d = uh( a, c );
            x( 0 < d.length, "Sending zero length transaction queue" );
            Na( d, function( a ) {
                return 1 === a.status
            } ) && vh( a, c.path(), d )
        } else c.pd() && c.ca( function( b ) {
            sh( a, b )
        } )
    }

    function vh( a, b, c ) {
        for ( var d = La( c, function( a ) {
                return a.sa
            } ), e = a.M.xa( b, d ) || K, d = e, e = e.hash(), f = 0; f < c.length; f++ ) {
            var g = c[ f ];
            x( 1 === g.status, "tryToSendTransactionQueue_: items in queue should all be run." );
            g.status = 2;
            g.rf++;
            var k = T( b, g.path ),
                d = d.L( k, g.gd )
        }
        d = d.N( !0 );
        a.S.put( b.toString(), d, function( d ) {
            a.f( "transaction put response", {
                path: b.toString(),
                status: d
            } );
            var e = [];
            if ( "ok" === d ) {
                d = [];
                for ( f = 0; f < c.length; f++ ) {
                    c[ f ].status = 3;
                    e = e.concat( a.M.Ea( c[ f ].sa ) );
                    if ( c[ f ].H ) {
                        var g = c[ f ].hd,
                            k = new O( a, c[ f ].path );
                        d.push( q( c[ f ].H, null, null, !0, new C( g, k, L ) ) )
                    }
                    c[ f ].Vd()
                }
                th( a, Gc( a.pc, b ) );
                sh( a );
                Xe( a.Z, b, e );
                for ( f = 0; f < d.length; f++ ) Fb( d[ f ] )
            } else {
                if ( "datastale" === d )
                    for ( f = 0; f < c.length; f++ ) c[ f ].status = 4 === c[ f ].status ? 5 : 1;
                else
                    for ( z( "transaction at " + b.toString() + " failed: " + d ), f = 0; f < c.length; f++ ) c[ f ].status = 5, c[ f ].Yd = d;
                kh( a, b )
            }
        }, e )
    }

    function kh( a, b ) {
        var c = wh( a, b ),
            d = c.path(),
            c = uh( a, c );
        xh( a, c, d );
        return d
    }

    function xh( a, b, c ) {
        if ( 0 !== b.length ) {
            for ( var d = [], e = [], f = La( b, function( a ) {
                    return a.sa
                } ), g = 0; g < b.length; g++ ) {
                var k = b[ g ],
                    l = T( c, k.path ),
                    m = !1,
                    r;
                x( null !== l, "rerunTransactionsUnderNode_: relativePath should not be null." );
                if ( 5 === k.status ) m = !0, r = k.Yd, e = e.concat( a.M.Ea( k.sa, !0 ) );
                else if ( 1 === k.status )
                    if ( 25 <= k.rf ) m = !0, r = "maxretry", e = e.concat( a.M.Ea( k.sa, !0 ) );
                    else {
                        var s = a.M.xa( k.path, f ) || K;
                        k.fd = s;
                        var y = b[ g ].update( s.N() );
                        n( y ) ? ( Tb( "transaction failed: Data returned ", y ), l = J( y ), "object" === typeof y && null != y && u( y, ".priority" ) || ( l = l.ib( s.O() ) ), s = k.sa, y = jh( a ), y = If( l, y ), k.gd = l, k.hd = y, k.sa = a.zd++, Qa( f, s ), e = e.concat( a.M.Fa( k.path, y, k.sa, k.Qe ) ), e = e.concat( a.M.Ea( s, !0 ) ) ) : ( m = !0, r = "nodata", e = e.concat( a.M.Ea( k.sa, !0 ) ) )
                    }
                Xe( a.Z, c, e );
                e = [];
                m && ( b[ g ].status = 3, setTimeout( b[ g ].Vd, Math.floor( 0 ) ), b[ g ].H && ( "nodata" === r ? ( k = new O( a, b[ g ].path ), d.push( q( b[ g ].H, null, null, !1, new C( b[ g ].fd, k, L ) ) ) ) : d.push( q( b[ g ].H, null, Error( r ), !1, null ) ) ) )
            }
            th( a, a.pc );
            for ( g = 0; g < d.length; g++ ) Fb( d[ g ] );
            sh( a )
        }
    }

    function wh( a, b ) {
        for ( var c, d = a.pc; null !== ( c = G( b ) ) && null === d.ta(); ) d = Gc( d, c ), b = R( b );
        return d
    }

    function uh( a, b ) {
        var c = [];
        yh( a, b, c );
        c.sort( function( a, b ) {
            return a.lf - b.lf
        } );
        return c
    }

    function yh( a, b, c ) {
        var d = b.ta();
        if ( null !== d )
            for ( var e = 0; e < d.length; e++ ) c.push( d[ e ] );
        b.ca( function( b ) {
            yh( a, b, c )
        } )
    }

    function th( a, b ) {
        var c = b.ta();
        if ( c ) {
            for ( var d = 0, e = 0; e < c.length; e++ ) 3 !== c[ e ].status && ( c[ d ] = c[ e ], d++ );
            c.length = d;
            Hc( b, 0 < c.length ? c : null )
        }
        b.ca( function( b ) {
            th( a, b )
        } )
    }

    function nh( a, b ) {
        var c = wh( a, b ).path(),
            d = Gc( a.pc, b );
        Kc( d, function( b ) {
            zh( a, b )
        } );
        zh( a, d );
        Jc( d, function( b ) {
            zh( a, b )
        } );
        return c
    }

    function zh( a, b ) {
        var c = b.ta();
        if ( null !== c ) {
            for ( var d = [], e = [], f = -1, g = 0; g < c.length; g++ ) 4 !== c[ g ].status && ( 2 === c[ g ].status ? ( x( f === g - 1, "All SENT items should be at beginning of queue." ), f = g, c[ g ].status = 4, c[ g ].Yd = "set" ) : ( x( 1 === c[ g ].status, "Unexpected transaction status in abort" ), c[ g ].Vd(), e = e.concat( a.M.Ea( c[ g ].sa, !0 ) ), c[ g ].H && d.push( q( c[ g ].H, null, Error( "set" ), !1, null ) ) ) ); - 1 === f ? Hc( b, null ) : c.length = f + 1;
            Xe( a.Z, b.path(), e );
            for ( g = 0; g < d.length; g++ ) Fb( d[ g ] )
        }
    };

    function Ah() {
        this.jc = {}
    }
    ca( Ah );
    Ah.prototype.tb = function() {
        for ( var a in this.jc ) this.jc[ a ].tb()
    };
    Ah.prototype.interrupt = Ah.prototype.tb;
    Ah.prototype.kc = function() {
        for ( var a in this.jc ) this.jc[ a ].kc()
    };
    Ah.prototype.resume = Ah.prototype.kc;

    function Bh( a ) {
        var b = this;
        this.tc = a;
        this.Qd = "*";
        lf() ? this.Hc = this.sd = cf() : ( this.Hc = window.opener, this.sd = window );
        if ( !b.Hc ) throw "Unable to find relay frame";
        df( this.sd, "message", q( this.cc, this ) );
        df( this.sd, "message", q( this.hf, this ) );
        try {
            Ch( this, {
                a: "ready"
            } )
        } catch ( c ) {
            df( this.Hc, "load", function() {
                Ch( b, {
                    a: "ready"
                } )
            } )
        }
        df( window, "unload", q( this.eg, this ) )
    }

    function Ch( a, b ) {
        b = t( b );
        lf() ? a.Hc.doPost( b, a.Qd ) : a.Hc.postMessage( b, a.Qd )
    }
    Bh.prototype.cc = function( a ) {
        var b = this,
            c;
        try {
            c = ua( a.data )
        } catch ( d ) {}
        c && "request" === c.a && ( ef( window, "message", this.cc ), this.Qd = a.origin, this.tc && setTimeout( function() {
            b.tc( b.Qd, c.d, function( a, c ) {
                b.If = !c;
                b.tc = void 0;
                Ch( b, {
                    a: "response",
                    d: a,
                    forceKeepWindowOpen: c
                } )
            } )
        }, 0 ) )
    };
    Bh.prototype.eg = function() {
        try {
            ef( this.sd, "message", this.hf )
        } catch ( a ) {}
        this.tc && ( Ch( this, {
            a: "error",
            d: "unknown closed window"
        } ), this.tc = void 0 );
        try {
            window.close()
        } catch ( b ) {}
    };
    Bh.prototype.hf = function( a ) {
        if ( this.If && "die" === a.data ) try {
            window.close()
        } catch ( b ) {}
    };
    var Y = {
        Rf: function() {
            Yd = Pd = !0
        }
    };
    Y.forceLongPolling = Y.Rf;
    Y.Sf = function() {
        Zd = !0
    };
    Y.forceWebSockets = Y.Sf;
    Y.rg = function( a, b ) {
        a.g.S.Ke = b
    };
    Y.setSecurityDebugCallback = Y.rg;
    Y.Me = function( a, b ) {
        a.g.Me( b )
    };
    Y.stats = Y.Me;
    Y.Ne = function( a, b ) {
        a.g.Ne( b )
    };
    Y.statsIncrementCounter = Y.Ne;
    Y.jd = function( a ) {
        return a.g.jd
    };
    Y.dataUpdateCount = Y.jd;
    Y.Vf = function( a, b ) {
        a.g.re = b
    };
    Y.interceptServerData = Y.Vf;
    Y.bg = function( a ) {
        new Bh( a )
    };
    Y.onPopupOpen = Y.bg;
    Y.pg = function( a ) {
        Ye = a
    };
    Y.setAuthenticationServer = Y.pg;

    function Z( a, b ) {
        this.Sc = a;
        this.Ca = b
    }
    Z.prototype.cancel = function( a ) {
        D( "Firebase.onDisconnect().cancel", 0, 1, arguments.length );
        F( "Firebase.onDisconnect().cancel", 1, a, !0 );
        this.Sc.Ce( this.Ca, a || null )
    };
    Z.prototype.cancel = Z.prototype.cancel;
    Z.prototype.remove = function( a ) {
        D( "Firebase.onDisconnect().remove", 0, 1, arguments.length );
        $b( "Firebase.onDisconnect().remove", this.Ca );
        F( "Firebase.onDisconnect().remove", 1, a, !0 );
        oh( this.Sc, this.Ca, null, a )
    };
    Z.prototype.remove = Z.prototype.remove;
    Z.prototype.set = function( a, b ) {
        D( "Firebase.onDisconnect().set", 1, 2, arguments.length );
        $b( "Firebase.onDisconnect().set", this.Ca );
        Sb( "Firebase.onDisconnect().set", a, !1 );
        F( "Firebase.onDisconnect().set", 2, b, !0 );
        oh( this.Sc, this.Ca, a, b )
    };
    Z.prototype.set = Z.prototype.set;
    Z.prototype.Db = function( a, b, c ) {
        D( "Firebase.onDisconnect().setWithPriority", 2, 3, arguments.length );
        $b( "Firebase.onDisconnect().setWithPriority", this.Ca );
        Sb( "Firebase.onDisconnect().setWithPriority", a, !1 );
        Wb( "Firebase.onDisconnect().setWithPriority", 2, b );
        F( "Firebase.onDisconnect().setWithPriority", 3, c, !0 );
        ph( this.Sc, this.Ca, a, b, c )
    };
    Z.prototype.setWithPriority = Z.prototype.Db;
    Z.prototype.update = function( a, b ) {
        D( "Firebase.onDisconnect().update", 1, 2, arguments.length );
        $b( "Firebase.onDisconnect().update", this.Ca );
        if ( ea( a ) ) {
            for ( var c = {}, d = 0; d < a.length; ++d ) c[ "" + d ] = a[ d ];
            a = c;
            z( "Passing an Array to Firebase.onDisconnect().update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children." )
        }
        Vb( "Firebase.onDisconnect().update", a );
        F( "Firebase.onDisconnect().update", 2, b, !0 );
        qh( this.Sc, this.Ca, a, b )
    };
    Z.prototype.update = Z.prototype.update;
    var $ = {};
    $.rc = xe;
    $.DataConnection = $.rc;
    xe.prototype.tg = function( a, b ) {
        this.wa( "q", {
            p: a
        }, b )
    };
    $.rc.prototype.simpleListen = $.rc.prototype.tg;
    xe.prototype.Nf = function( a, b ) {
        this.wa( "echo", {
            d: a
        }, b )
    };
    $.rc.prototype.echo = $.rc.prototype.Nf;
    xe.prototype.interrupt = xe.prototype.tb;
    $.zf = ie;
    $.RealTimeConnection = $.zf;
    ie.prototype.sendRequest = ie.prototype.wa;
    ie.prototype.close = ie.prototype.close;
    $.Uf = function( a ) {
        var b = xe.prototype.put;
        xe.prototype.put = function( c, d, e, f ) {
            n( f ) && ( f = a() );
            b.call( this, c, d, e, f )
        };
        return function() {
            xe.prototype.put = b
        }
    };
    $.hijackHash = $.Uf;
    $.yf = Ca;
    $.ConnectionTarget = $.yf;
    $.Da = function( a ) {
        return a.Da()
    };
    $.queryIdentifier = $.Da;
    $.Wf = function( a ) {
        return a.g.S.ua
    };
    $.listens = $.Wf;
    var Dh = function() {
        var a = 0,
            b = [];
        return function( c ) {
            var d = c === a;
            a = c;
            for ( var e = Array( 8 ), f = 7; 0 <= f; f-- ) e[ f ] = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt( c % 64 ), c = Math.floor( c / 64 );
            x( 0 === c, "Cannot push at time == 0" );
            c = e.join( "" );
            if ( d ) {
                for ( f = 11; 0 <= f && 63 === b[ f ]; f-- ) b[ f ] = 0;
                b[ f ] ++
            } else
                for ( f = 0; 12 > f; f++ ) b[ f ] = Math.floor( 64 * Math.random() );
            for ( f = 0; 12 > f; f++ ) c += "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz".charAt( b[ f ] );
            x( 20 === c.length, "NextPushId: Length should be 20." );
            return c
        }
    }();

    function O( a, b ) {
        var c, d, e;
        if ( a instanceof gh ) c = a, d = b;
        else {
            D( "new Firebase", 1, 2, arguments.length );
            d = ub( arguments[ 0 ] );
            c = d.vg;
            "firebase" === d.domain && tb( d.host + " is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead" );
            c || tb( "Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com" );
            d.Cb || "undefined" !== typeof window && window.location && window.location.protocol && -1 !== window.location.protocol.indexOf( "https:" ) && z( "Insecure Firebase access from a secure page. Please use https in calls to new Firebase()." );
            c = new Ca( d.host, d.Cb, c, "ws" === d.scheme || "wss" === d.scheme );
            d = new P( d.Pc );
            e = d.toString();
            var f;
            !( f = !p( c.host ) || 0 === c.host.length || !Qb( c.yb ) ) && ( f = 0 !== e.length ) && ( e && ( e = e.replace( /^\/*\.info(\/|$)/, "/" ) ), f = !( p( e ) && 0 !== e.length && !Pb.test( e ) ) );
            if ( f ) throw Error( E( "new Firebase", 1, !1 ) + 'must be a valid firebase URL and the path can\'t contain ".", "#", "$", "[", or "]".' );
            if ( b )
                if ( b instanceof Ah ) e = b;
                else if ( p( b ) ) e = Ah.Qb(), c.Gd = b;
            else throw Error( "Expected a valid Firebase.Context for second argument to new Firebase()" );
            else e = Ah.Qb();
            f = c.toString();
            var g = v( e.jc, f );
            g || ( g = new gh( c ), e.jc[ f ] = g );
            c = g
        }
        M.call( this, c, d, oc, !1 )
    }
    na( O, M );
    var Eh = O,
        Fh = [ "Firebase" ],
        Gh = aa;
    Fh[ 0 ] in Gh || !Gh.execScript || Gh.execScript( "var " + Fh[ 0 ] );
    for ( var Hh; Fh.length && ( Hh = Fh.shift() ); ) !Fh.length && n( Eh ) ? Gh[ Hh ] = Eh : Gh = Gh[ Hh ] ? Gh[ Hh ] : Gh[ Hh ] = {};
    O.prototype.name = function() {
        z( "Firebase.name() being deprecated. Please use Firebase.key() instead." );
        D( "Firebase.name", 0, 0, arguments.length );
        return this.key()
    };
    O.prototype.name = O.prototype.name;
    O.prototype.key = function() {
        D( "Firebase.key", 0, 0, arguments.length );
        var a;
        this.path.e() ? a = null : ( a = this.path, a = a.aa < a.n.length ? a.n[ a.n.length - 1 ] : null );
        return a
    };
    O.prototype.key = O.prototype.key;
    O.prototype.k = function( a ) {
        D( "Firebase.child", 1, 1, arguments.length );
        if ( ga( a ) ) a = String( a );
        else if ( !( a instanceof P ) )
            if ( null === G( this.path ) ) {
                var b = a;
                b && ( b = b.replace( /^\/*\.info(\/|$)/, "/" ) );
                Zb( "Firebase.child", b )
            } else Zb( "Firebase.child", a );
        return new O( this.g, this.path.k( a ) )
    };
    O.prototype.child = O.prototype.k;
    O.prototype.parent = function() {
        D( "Firebase.parent", 0, 0, arguments.length );
        var a = this.path.parent();
        return null === a ? null : new O( this.g, a )
    };
    O.prototype.parent = O.prototype.parent;
    O.prototype.root = function() {
        D( "Firebase.ref", 0, 0, arguments.length );
        for ( var a = this; null !== a.parent(); ) a = a.parent();
        return a
    };
    O.prototype.root = O.prototype.root;
    O.prototype.toString = function() {
        D( "Firebase.toString", 0, 0, arguments.length );
        var a;
        if ( null === this.parent() ) a = this.g.toString();
        else {
            a = this.parent().toString() + "/";
            var b = this.key();
            a += encodeURIComponent( String( b ) )
        }
        return a
    };
    O.prototype.toString = O.prototype.toString;
    O.prototype.set = function( a, b ) {
        D( "Firebase.set", 1, 2, arguments.length );
        $b( "Firebase.set", this.path );
        Sb( "Firebase.set", a, !1 );
        F( "Firebase.set", 2, b, !0 );
        this.g.Db( this.path, a, null, b || null )
    };
    O.prototype.set = O.prototype.set;
    O.prototype.update = function( a, b ) {
        D( "Firebase.update", 1, 2, arguments.length );
        $b( "Firebase.update", this.path );
        if ( ea( a ) ) {
            for ( var c = {}, d = 0; d < a.length; ++d ) c[ "" + d ] = a[ d ];
            a = c;
            z( "Passing an Array to Firebase.update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children." )
        }
        Vb( "Firebase.update", a );
        F( "Firebase.update", 2, b, !0 );
        if ( u( a, ".priority" ) ) throw Error( "update() does not currently support updating .priority." );
        this.g.update( this.path, a, b || null )
    };
    O.prototype.update = O.prototype.update;
    O.prototype.Db = function( a, b, c ) {
        D( "Firebase.setWithPriority", 2, 3, arguments.length );
        $b( "Firebase.setWithPriority", this.path );
        Sb( "Firebase.setWithPriority", a, !1 );
        Wb( "Firebase.setWithPriority", 2, b );
        F( "Firebase.setWithPriority", 3, c, !0 );
        if ( ".length" === this.key() || ".keys" === this.key() ) throw "Firebase.setWithPriority failed: " + this.key() + " is a read-only object.";
        this.g.Db( this.path, a, b, c || null )
    };
    O.prototype.setWithPriority = O.prototype.Db;
    O.prototype.remove = function( a ) {
        D( "Firebase.remove", 0, 1, arguments.length );
        $b( "Firebase.remove", this.path );
        F( "Firebase.remove", 1, a, !0 );
        this.set( null, a )
    };
    O.prototype.remove = O.prototype.remove;
    O.prototype.transaction = function( a, b, c ) {
        D( "Firebase.transaction", 1, 3, arguments.length );
        $b( "Firebase.transaction", this.path );
        F( "Firebase.transaction", 1, a, !1 );
        F( "Firebase.transaction", 2, b, !0 );
        if ( n( c ) && "boolean" != typeof c ) throw Error( E( "Firebase.transaction", 3, !0 ) + "must be a boolean." );
        if ( ".length" === this.key() || ".keys" === this.key() ) throw "Firebase.transaction failed: " + this.key() + " is a read-only object.";
        "undefined" === typeof c && ( c = !0 );
        rh( this.g, this.path, a, b || null, c )
    };
    O.prototype.transaction = O.prototype.transaction;
    O.prototype.qg = function( a, b ) {
        D( "Firebase.setPriority", 1, 2, arguments.length );
        $b( "Firebase.setPriority", this.path );
        Wb( "Firebase.setPriority", 1, a );
        F( "Firebase.setPriority", 2, b, !0 );
        this.g.Db( this.path.k( ".priority" ), a, null, b )
    };
    O.prototype.setPriority = O.prototype.qg;
    O.prototype.push = function( a, b ) {
        D( "Firebase.push", 0, 2, arguments.length );
        $b( "Firebase.push", this.path );
        Sb( "Firebase.push", a, !0 );
        F( "Firebase.push", 2, b, !0 );
        var c = ih( this.g ),
            c = Dh( c ),
            c = this.k( c );
        "undefined" !== typeof a && null !== a && c.set( a, b );
        return c
    };
    O.prototype.push = O.prototype.push;
    O.prototype.fb = function() {
        $b( "Firebase.onDisconnect", this.path );
        return new Z( this.g, this.path )
    };
    O.prototype.onDisconnect = O.prototype.fb;
    O.prototype.T = function( a, b, c ) {
        z( "FirebaseRef.auth() being deprecated. Please use FirebaseRef.authWithCustomToken() instead." );
        D( "Firebase.auth", 1, 3, arguments.length );
        ac( "Firebase.auth", a );
        F( "Firebase.auth", 2, b, !0 );
        F( "Firebase.auth", 3, b, !0 );
        zf( this.g.T, a, {}, {
            remember: "none"
        }, b, c )
    };
    O.prototype.auth = O.prototype.T;
    O.prototype.Pe = function( a ) {
        D( "Firebase.unauth", 0, 1, arguments.length );
        F( "Firebase.unauth", 1, a, !0 );
        Af( this.g.T, a )
    };
    O.prototype.unauth = O.prototype.Pe;
    O.prototype.ne = function() {
        D( "Firebase.getAuth", 0, 0, arguments.length );
        return this.g.T.ne()
    };
    O.prototype.getAuth = O.prototype.ne;
    O.prototype.ag = function( a, b ) {
        D( "Firebase.onAuth", 1, 2, arguments.length );
        F( "Firebase.onAuth", 1, a, !1 );
        Nb( "Firebase.onAuth", 2, b );
        this.g.T.zb( "auth_status", a, b )
    };
    O.prototype.onAuth = O.prototype.ag;
    O.prototype.Zf = function( a, b ) {
        D( "Firebase.offAuth", 1, 2, arguments.length );
        F( "Firebase.offAuth", 1, a, !1 );
        Nb( "Firebase.offAuth", 2, b );
        this.g.T.bc( "auth_status", a, b )
    };
    O.prototype.offAuth = O.prototype.Zf;
    O.prototype.Df = function( a, b, c ) {
        D( "Firebase.authWithCustomToken", 2, 3, arguments.length );
        ac( "Firebase.authWithCustomToken", a );
        F( "Firebase.authWithCustomToken", 2, b, !1 );
        cc( "Firebase.authWithCustomToken", 3, c, !0 );
        zf( this.g.T, a, {}, c || {}, b )
    };
    O.prototype.authWithCustomToken = O.prototype.Df;
    O.prototype.Ef = function( a, b, c ) {
        D( "Firebase.authWithOAuthPopup", 2, 3, arguments.length );
        bc( "Firebase.authWithOAuthPopup", 1, a );
        F( "Firebase.authWithOAuthPopup", 2, b, !1 );
        cc( "Firebase.authWithOAuthPopup", 3, c, !0 );
        Ef( this.g.T, a, c, b )
    };
    O.prototype.authWithOAuthPopup = O.prototype.Ef;
    O.prototype.Ff = function( a, b, c ) {
        D( "Firebase.authWithOAuthRedirect", 2, 3, arguments.length );
        bc( "Firebase.authWithOAuthRedirect", 1, a );
        F( "Firebase.authWithOAuthRedirect", 2, b, !1 );
        cc( "Firebase.authWithOAuthRedirect", 3, c, !0 );
        var d = this.g.T;
        Cf( d );
        var e = [ sf ],
            f = af( c );
        "anonymous" === a || "firebase" === a ? B( b, V( "TRANSPORT_UNAVAILABLE" ) ) : ( Ba.set( "redirect_client_options", f.ed ), Df( d, e, "/auth/" + a, f, b ) )
    };
    O.prototype.authWithOAuthRedirect = O.prototype.Ff;
    O.prototype.Gf = function( a, b, c, d ) {
        D( "Firebase.authWithOAuthToken", 3, 4, arguments.length );
        bc( "Firebase.authWithOAuthToken", 1, a );
        F( "Firebase.authWithOAuthToken", 3, c, !1 );
        cc( "Firebase.authWithOAuthToken", 4, d, !0 );
        p( b ) ? ( bc( "Firebase.authWithOAuthToken", 2, b ), Bf( this.g.T, a + "/token", {
            access_token: b
        }, d, c ) ) : ( cc( "Firebase.authWithOAuthToken", 2, b, !1 ), Bf( this.g.T, a + "/token", b, d, c ) )
    };
    O.prototype.authWithOAuthToken = O.prototype.Gf;
    O.prototype.Cf = function( a, b ) {
        D( "Firebase.authAnonymously", 1, 2, arguments.length );
        F( "Firebase.authAnonymously", 1, a, !1 );
        cc( "Firebase.authAnonymously", 2, b, !0 );
        Bf( this.g.T, "anonymous", {}, b, a )
    };
    O.prototype.authAnonymously = O.prototype.Cf;
    O.prototype.Hf = function( a, b, c ) {
        D( "Firebase.authWithPassword", 2, 3, arguments.length );
        cc( "Firebase.authWithPassword", 1, a, !1 );
        dc( "Firebase.authWithPassword", a, "email" );
        dc( "Firebase.authWithPassword", a, "password" );
        F( "Firebase.authAnonymously", 2, b, !1 );
        cc( "Firebase.authAnonymously", 3, c, !0 );
        Bf( this.g.T, "password", a, c, b )
    };
    O.prototype.authWithPassword = O.prototype.Hf;
    O.prototype.je = function( a, b ) {
        D( "Firebase.createUser", 2, 2, arguments.length );
        cc( "Firebase.createUser", 1, a, !1 );
        dc( "Firebase.createUser", a, "email" );
        dc( "Firebase.createUser", a, "password" );
        F( "Firebase.createUser", 2, b, !1 );
        this.g.T.je( a, b )
    };
    O.prototype.createUser = O.prototype.je;
    O.prototype.Ie = function( a, b ) {
        D( "Firebase.removeUser", 2, 2, arguments.length );
        cc( "Firebase.removeUser", 1, a, !1 );
        dc( "Firebase.removeUser", a, "email" );
        dc( "Firebase.removeUser", a, "password" );
        F( "Firebase.removeUser", 2, b, !1 );
        this.g.T.Ie( a, b )
    };
    O.prototype.removeUser = O.prototype.Ie;
    O.prototype.ee = function( a, b ) {
        D( "Firebase.changePassword", 2, 2, arguments.length );
        cc( "Firebase.changePassword", 1, a, !1 );
        dc( "Firebase.changePassword", a, "email" );
        dc( "Firebase.changePassword", a, "oldPassword" );
        dc( "Firebase.changePassword", a, "newPassword" );
        F( "Firebase.changePassword", 2, b, !1 );
        this.g.T.ee( a, b )
    };
    O.prototype.changePassword = O.prototype.ee;
    O.prototype.Je = function( a, b ) {
        D( "Firebase.resetPassword", 2, 2, arguments.length );
        cc( "Firebase.resetPassword", 1, a, !1 );
        dc( "Firebase.resetPassword", a, "email" );
        F( "Firebase.resetPassword", 2, b, !1 );
        this.g.T.Je( a, b )
    };
    O.prototype.resetPassword = O.prototype.Je;
    O.goOffline = function() {
        D( "Firebase.goOffline", 0, 0, arguments.length );
        Ah.Qb().tb()
    };
    O.goOnline = function() {
        D( "Firebase.goOnline", 0, 0, arguments.length );
        Ah.Qb().kc()
    };

    function qb( a, b ) {
        x( !b || !0 === a || !1 === a, "Can't turn on custom loggers persistently." );
        !0 === a ? ( "undefined" !== typeof console && ( "function" === typeof console.log ? ob = q( console.log, console ) : "object" === typeof console.log && ( ob = function( a ) {
            console.log( a )
        } ) ), b && Ba.set( "logging_enabled", !0 ) ) : a ? ob = a : ( ob = null, Ba.remove( "logging_enabled" ) )
    }
    O.enableLogging = qb;
    O.ServerValue = {
        TIMESTAMP: {
            ".sv": "timestamp"
        }
    };
    O.SDK_VERSION = "2.0.6";
    O.INTERNAL = Y;
    O.Context = Ah;
    O.TEST_ACCESS = $;
} )();
/*! Hammer.JS - v2.0.4 - 2014-09-28
 * http://hammerjs.github.io/
 *
 * Copyright (c) 2014 Jorik Tangelder;
 * Licensed under the MIT license */
( function( window, document, exportName, undefined ) {
    'use strict';
    var VENDOR_PREFIXES = [ '', 'webkit', 'moz', 'MS', 'ms', 'o' ];
    var TEST_ELEMENT = document.createElement( 'div' );
    var TYPE_FUNCTION = 'function';
    var round = Math.round;
    var abs = Math.abs;
    var now = Date.now;
    /**
     * set a timeout with a given scope
     * @param {Function} fn
     * @param {Number} timeout
     * @param {Object} context
     * @returns {number}
     */
    function setTimeoutContext( fn, timeout, context ) {
            return setTimeout( bindFn( fn, context ), timeout );
        }
        /**
         * if the argument is an array, we want to execute the fn on each entry
         * if it aint an array we don't want to do a thing.
         * this is used by all the methods that accept a single and array argument.
         * @param {*|Array} arg
         * @param {String} fn
         * @param {Object} [context]
         * @returns {Boolean}
         */
    function invokeArrayArg( arg, fn, context ) {
            if ( Array.isArray( arg ) ) {
                each( arg, context[ fn ], context );
                return true;
            }
            return false;
        }
        /**
         * walk objects and arrays
         * @param {Object} obj
         * @param {Function} iterator
         * @param {Object} context
         */
    function each( obj, iterator, context ) {
            var i;
            if ( !obj ) {
                return;
            }
            if ( obj.forEach ) {
                obj.forEach( iterator, context );
            } else if ( obj.length !== undefined ) {
                i = 0;
                while ( i < obj.length ) {
                    iterator.call( context, obj[ i ], i, obj );
                    i++;
                }
            } else {
                for ( i in obj ) {
                    obj.hasOwnProperty( i ) && iterator.call( context, obj[ i ], i, obj );
                }
            }
        }
        /**
         * extend object.
         * means that properties in dest will be overwritten by the ones in src.
         * @param {Object} dest
         * @param {Object} src
         * @param {Boolean} [merge]
         * @returns {Object} dest
         */
    function extend( dest, src, merge ) {
            var keys = Object.keys( src );
            var i = 0;
            while ( i < keys.length ) {
                if ( !merge || ( merge && dest[ keys[ i ] ] === undefined ) ) {
                    dest[ keys[ i ] ] = src[ keys[ i ] ];
                }
                i++;
            }
            return dest;
        }
        /**
         * merge the values from src in the dest.
         * means that properties that exist in dest will not be overwritten by src
         * @param {Object} dest
         * @param {Object} src
         * @returns {Object} dest
         */
    function merge( dest, src ) {
            return extend( dest, src, true );
        }
        /**
         * simple class inheritance
         * @param {Function} child
         * @param {Function} base
         * @param {Object} [properties]
         */
    function inherit( child, base, properties ) {
            var baseP = base.prototype,
                childP;
            childP = child.prototype = Object.create( baseP );
            childP.constructor = child;
            childP._super = baseP;
            if ( properties ) {
                extend( childP, properties );
            }
        }
        /**
         * simple function bind
         * @param {Function} fn
         * @param {Object} context
         * @returns {Function}
         */
    function bindFn( fn, context ) {
            return function boundFn() {
                return fn.apply( context, arguments );
            };
        }
        /**
         * let a boolean value also be a function that must return a boolean
         * this first item in args will be used as the context
         * @param {Boolean|Function} val
         * @param {Array} [args]
         * @returns {Boolean}
         */
    function boolOrFn( val, args ) {
            if ( typeof val == TYPE_FUNCTION ) {
                return val.apply( args ? args[ 0 ] || undefined : undefined, args );
            }
            return val;
        }
        /**
         * use the val2 when val1 is undefined
         * @param {*} val1
         * @param {*} val2
         * @returns {*}
         */
    function ifUndefined( val1, val2 ) {
            return ( val1 === undefined ) ? val2 : val1;
        }
        /**
         * addEventListener with multiple events at once
         * @param {EventTarget} target
         * @param {String} types
         * @param {Function} handler
         */
    function addEventListeners( target, types, handler ) {
            each( splitStr( types ), function( type ) {
                target.addEventListener( type, handler, false );
            } );
        }
        /**
         * removeEventListener with multiple events at once
         * @param {EventTarget} target
         * @param {String} types
         * @param {Function} handler
         */
    function removeEventListeners( target, types, handler ) {
            each( splitStr( types ), function( type ) {
                target.removeEventListener( type, handler, false );
            } );
        }
        /**
         * find if a node is in the given parent
         * @method hasParent
         * @param {HTMLElement} node
         * @param {HTMLElement} parent
         * @return {Boolean} found
         */
    function hasParent( node, parent ) {
            while ( node ) {
                if ( node == parent ) {
                    return true;
                }
                node = node.parentNode;
            }
            return false;
        }
        /**
         * small indexOf wrapper
         * @param {String} str
         * @param {String} find
         * @returns {Boolean} found
         */
    function inStr( str, find ) {
            return str.indexOf( find ) > -1;
        }
        /**
         * split string on whitespace
         * @param {String} str
         * @returns {Array} words
         */
    function splitStr( str ) {
            return str.trim().split( /\s+/g );
        }
        /**
         * find if a array contains the object using indexOf or a simple polyFill
         * @param {Array} src
         * @param {String} find
         * @param {String} [findByKey]
         * @return {Boolean|Number} false when not found, or the index
         */
    function inArray( src, find, findByKey ) {
            if ( src.indexOf && !findByKey ) {
                return src.indexOf( find );
            } else {
                var i = 0;
                while ( i < src.length ) {
                    if ( ( findByKey && src[ i ][ findByKey ] == find ) || ( !findByKey && src[ i ] === find ) ) {
                        return i;
                    }
                    i++;
                }
                return -1;
            }
        }
        /**
         * convert array-like objects to real arrays
         * @param {Object} obj
         * @returns {Array}
         */
    function toArray( obj ) {
            return Array.prototype.slice.call( obj, 0 );
        }
        /**
         * unique array with objects based on a key (like 'id') or just by the array's value
         * @param {Array} src [{id:1},{id:2},{id:1}]
         * @param {String} [key]
         * @param {Boolean} [sort=False]
         * @returns {Array} [{id:1},{id:2}]
         */
    function uniqueArray( src, key, sort ) {
            var results = [];
            var values = [];
            var i = 0;
            while ( i < src.length ) {
                var val = key ? src[ i ][ key ] : src[ i ];
                if ( inArray( values, val ) < 0 ) {
                    results.push( src[ i ] );
                }
                values[ i ] = val;
                i++;
            }
            if ( sort ) {
                if ( !key ) {
                    results = results.sort();
                } else {
                    results = results.sort( function sortUniqueArray( a, b ) {
                        return a[ key ] > b[ key ];
                    } );
                }
            }
            return results;
        }
        /**
         * get the prefixed property
         * @param {Object} obj
         * @param {String} property
         * @returns {String|Undefined} prefixed
         */
    function prefixed( obj, property ) {
            var prefix, prop;
            var camelProp = property[ 0 ].toUpperCase() + property.slice( 1 );
            var i = 0;
            while ( i < VENDOR_PREFIXES.length ) {
                prefix = VENDOR_PREFIXES[ i ];
                prop = ( prefix ) ? prefix + camelProp : property;
                if ( prop in obj ) {
                    return prop;
                }
                i++;
            }
            return undefined;
        }
        /**
         * get a unique id
         * @returns {number} uniqueId
         */
    var _uniqueId = 1;

    function uniqueId() {
            return _uniqueId++;
        }
        /**
         * get the window object of an element
         * @param {HTMLElement} element
         * @returns {DocumentView|Window}
         */
    function getWindowForElement( element ) {
        var doc = element.ownerDocument;
        return ( doc.defaultView || doc.parentWindow );
    }
    var MOBILE_REGEX = /mobile|tablet|ip(ad|hone|od)|android/i;
    var SUPPORT_TOUCH = ( 'ontouchstart' in window );
    var SUPPORT_POINTER_EVENTS = prefixed( window, 'PointerEvent' ) !== undefined;
    var SUPPORT_ONLY_TOUCH = SUPPORT_TOUCH && MOBILE_REGEX.test( navigator.userAgent );
    var INPUT_TYPE_TOUCH = 'touch';
    var INPUT_TYPE_PEN = 'pen';
    var INPUT_TYPE_MOUSE = 'mouse';
    var INPUT_TYPE_KINECT = 'kinect';
    var COMPUTE_INTERVAL = 25;
    var INPUT_START = 1;
    var INPUT_MOVE = 2;
    var INPUT_END = 4;
    var INPUT_CANCEL = 8;
    var DIRECTION_NONE = 1;
    var DIRECTION_LEFT = 2;
    var DIRECTION_RIGHT = 4;
    var DIRECTION_UP = 8;
    var DIRECTION_DOWN = 16;
    var DIRECTION_HORIZONTAL = DIRECTION_LEFT | DIRECTION_RIGHT;
    var DIRECTION_VERTICAL = DIRECTION_UP | DIRECTION_DOWN;
    var DIRECTION_ALL = DIRECTION_HORIZONTAL | DIRECTION_VERTICAL;
    var PROPS_XY = [ 'x', 'y' ];
    var PROPS_CLIENT_XY = [ 'clientX', 'clientY' ];
    /**
     * create new input type manager
     * @param {Manager} manager
     * @param {Function} callback
     * @returns {Input}
     * @constructor
     */
    function Input( manager, callback ) {
        var self = this;
        this.manager = manager;
        this.callback = callback;
        this.element = manager.element;
        this.target = manager.options.inputTarget;
        // smaller wrapper around the handler, for the scope and the enabled state of the manager,
        // so when disabled the input events are completely bypassed.
        this.domHandler = function( ev ) {
            if ( boolOrFn( manager.options.enable, [ manager ] ) ) {
                self.handler( ev );
            }
        };
        this.init();
    }
    Input.prototype = {
        /**
         * should handle the inputEvent data and trigger the callback
         * @virtual
         */
        handler: function() {},
        /**
         * bind the events
         */
        init: function() {
            this.evEl && addEventListeners( this.element, this.evEl, this.domHandler );
            this.evTarget && addEventListeners( this.target, this.evTarget, this.domHandler );
            this.evWin && addEventListeners( getWindowForElement( this.element ), this.evWin, this.domHandler );
        },
        /**
         * unbind the events
         */
        destroy: function() {
            this.evEl && removeEventListeners( this.element, this.evEl, this.domHandler );
            this.evTarget && removeEventListeners( this.target, this.evTarget, this.domHandler );
            this.evWin && removeEventListeners( getWindowForElement( this.element ), this.evWin, this.domHandler );
        }
    };
    /**
     * create new input type manager
     * called by the Manager constructor
     * @param {Hammer} manager
     * @returns {Input}
     */
    function createInputInstance( manager ) {
            var Type;
            var inputClass = manager.options.inputClass;
            if ( inputClass ) {
                Type = inputClass;
            } else if ( SUPPORT_POINTER_EVENTS ) {
                Type = PointerEventInput;
            } else if ( SUPPORT_ONLY_TOUCH ) {
                Type = TouchInput;
            } else if ( !SUPPORT_TOUCH ) {
                Type = MouseInput;
            } else {
                Type = TouchMouseInput;
            }
            return new( Type )( manager, inputHandler );
        }
        /**
         * handle input events
         * @param {Manager} manager
         * @param {String} eventType
         * @param {Object} input
         */
    function inputHandler( manager, eventType, input ) {
            var pointersLen = input.pointers.length;
            var changedPointersLen = input.changedPointers.length;
            var isFirst = ( eventType & INPUT_START && ( pointersLen - changedPointersLen === 0 ) );
            var isFinal = ( eventType & ( INPUT_END | INPUT_CANCEL ) && ( pointersLen - changedPointersLen === 0 ) );
            input.isFirst = !!isFirst;
            input.isFinal = !!isFinal;
            if ( isFirst ) {
                manager.session = {};
            }
            // source event is the normalized value of the domEvents
            // like 'touchstart, mouseup, pointerdown'
            input.eventType = eventType;
            // compute scale, rotation etc
            computeInputData( manager, input );
            // emit secret event
            manager.emit( 'hammer.input', input );
            manager.recognize( input );
            manager.session.prevInput = input;
        }
        /**
         * extend the data with some usable properties like scale, rotate, velocity etc
         * @param {Object} manager
         * @param {Object} input
         */
    function computeInputData( manager, input ) {
        var session = manager.session;
        var pointers = input.pointers;
        var pointersLength = pointers.length;
        // store the first input to calculate the distance and direction
        if ( !session.firstInput ) {
            session.firstInput = simpleCloneInputData( input );
        }
        // to compute scale and rotation we need to store the multiple touches
        if ( pointersLength > 1 && !session.firstMultiple ) {
            session.firstMultiple = simpleCloneInputData( input );
        } else if ( pointersLength === 1 ) {
            session.firstMultiple = false;
        }
        var firstInput = session.firstInput;
        var firstMultiple = session.firstMultiple;
        var offsetCenter = firstMultiple ? firstMultiple.center : firstInput.center;
        var center = input.center = getCenter( pointers );
        input.timeStamp = now();
        input.deltaTime = input.timeStamp - firstInput.timeStamp;
        input.angle = getAngle( offsetCenter, center );
        input.distance = getDistance( offsetCenter, center );
        computeDeltaXY( session, input );
        input.offsetDirection = getDirection( input.deltaX, input.deltaY );
        input.scale = firstMultiple ? getScale( firstMultiple.pointers, pointers ) : 1;
        input.rotation = firstMultiple ? getRotation( firstMultiple.pointers, pointers ) : 0;
        computeIntervalInputData( session, input );
        // find the correct target
        var target = manager.element;
        if ( hasParent( input.srcEvent.target, target ) ) {
            target = input.srcEvent.target;
        }
        input.target = target;
    }

    function computeDeltaXY( session, input ) {
            var center = input.center;
            var offset = session.offsetDelta || {};
            var prevDelta = session.prevDelta || {};
            var prevInput = session.prevInput || {};
            if ( input.eventType === INPUT_START || prevInput.eventType === INPUT_END ) {
                prevDelta = session.prevDelta = {
                    x: prevInput.deltaX || 0,
                    y: prevInput.deltaY || 0
                };
                offset = session.offsetDelta = {
                    x: center.x,
                    y: center.y
                };
            }
            input.deltaX = prevDelta.x + ( center.x - offset.x );
            input.deltaY = prevDelta.y + ( center.y - offset.y );
        }
        /**
         * velocity is calculated every x ms
         * @param {Object} session
         * @param {Object} input
         */
    function computeIntervalInputData( session, input ) {
            var last = session.lastInterval || input,
                deltaTime = input.timeStamp - last.timeStamp,
                velocity, velocityX, velocityY, direction;
            if ( input.eventType != INPUT_CANCEL && ( deltaTime > COMPUTE_INTERVAL || last.velocity === undefined ) ) {
                var deltaX = last.deltaX - input.deltaX;
                var deltaY = last.deltaY - input.deltaY;
                var v = getVelocity( deltaTime, deltaX, deltaY );
                velocityX = v.x;
                velocityY = v.y;
                velocity = ( abs( v.x ) > abs( v.y ) ) ? v.x : v.y;
                direction = getDirection( deltaX, deltaY );
                session.lastInterval = input;
            } else {
                // use latest velocity info if it doesn't overtake a minimum period
                velocity = last.velocity;
                velocityX = last.velocityX;
                velocityY = last.velocityY;
                direction = last.direction;
            }
            input.velocity = velocity;
            input.velocityX = velocityX;
            input.velocityY = velocityY;
            input.direction = direction;
        }
        /**
         * create a simple clone from the input used for storage of firstInput and firstMultiple
         * @param {Object} input
         * @returns {Object} clonedInputData
         */
    function simpleCloneInputData( input ) {
            // make a simple copy of the pointers because we will get a reference if we don't
            // we only need clientXY for the calculations
            var pointers = [];
            var i = 0;
            while ( i < input.pointers.length ) {
                pointers[ i ] = {
                    clientX: round( input.pointers[ i ].clientX ),
                    clientY: round( input.pointers[ i ].clientY )
                };
                i++;
            }
            return {
                timeStamp: now(),
                pointers: pointers,
                center: getCenter( pointers ),
                deltaX: input.deltaX,
                deltaY: input.deltaY
            };
        }
        /**
         * get the center of all the pointers
         * @param {Array} pointers
         * @return {Object} center contains `x` and `y` properties
         */
    function getCenter( pointers ) {
            var pointersLength = pointers.length;
            // no need to loop when only one touch
            if ( pointersLength === 1 ) {
                return {
                    x: round( pointers[ 0 ].clientX ),
                    y: round( pointers[ 0 ].clientY )
                };
            }
            var x = 0,
                y = 0,
                i = 0;
            while ( i < pointersLength ) {
                x += pointers[ i ].clientX;
                y += pointers[ i ].clientY;
                i++;
            }
            return {
                x: round( x / pointersLength ),
                y: round( y / pointersLength )
            };
        }
        /**
         * calculate the velocity between two points. unit is in px per ms.
         * @param {Number} deltaTime
         * @param {Number} x
         * @param {Number} y
         * @return {Object} velocity `x` and `y`
         */
    function getVelocity( deltaTime, x, y ) {
            return {
                x: x / deltaTime || 0,
                y: y / deltaTime || 0
            };
        }
        /**
         * get the direction between two points
         * @param {Number} x
         * @param {Number} y
         * @return {Number} direction
         */
    function getDirection( x, y ) {
            if ( x === y ) {
                return DIRECTION_NONE;
            }
            if ( abs( x ) >= abs( y ) ) {
                return x > 0 ? DIRECTION_LEFT : DIRECTION_RIGHT;
            }
            return y > 0 ? DIRECTION_UP : DIRECTION_DOWN;
        }
        /**
         * calculate the absolute distance between two points
         * @param {Object} p1 {x, y}
         * @param {Object} p2 {x, y}
         * @param {Array} [props] containing x and y keys
         * @return {Number} distance
         */
    function getDistance( p1, p2, props ) {
            if ( !props ) {
                props = PROPS_XY;
            }
            var x = p2[ props[ 0 ] ] - p1[ props[ 0 ] ],
                y = p2[ props[ 1 ] ] - p1[ props[ 1 ] ];
            return Math.sqrt( ( x * x ) + ( y * y ) );
        }
        /**
         * calculate the angle between two coordinates
         * @param {Object} p1
         * @param {Object} p2
         * @param {Array} [props] containing x and y keys
         * @return {Number} angle
         */
    function getAngle( p1, p2, props ) {
            if ( !props ) {
                props = PROPS_XY;
            }
            var x = p2[ props[ 0 ] ] - p1[ props[ 0 ] ],
                y = p2[ props[ 1 ] ] - p1[ props[ 1 ] ];
            return Math.atan2( y, x ) * 180 / Math.PI;
        }
        /**
         * calculate the rotation degrees between two pointersets
         * @param {Array} start array of pointers
         * @param {Array} end array of pointers
         * @return {Number} rotation
         */
    function getRotation( start, end ) {
            return getAngle( end[ 1 ], end[ 0 ], PROPS_CLIENT_XY ) - getAngle( start[ 1 ], start[ 0 ], PROPS_CLIENT_XY );
        }
        /**
         * calculate the scale factor between two pointersets
         * no scale is 1, and goes down to 0 when pinched together, and bigger when pinched out
         * @param {Array} start array of pointers
         * @param {Array} end array of pointers
         * @return {Number} scale
         */
    function getScale( start, end ) {
        return getDistance( end[ 0 ], end[ 1 ], PROPS_CLIENT_XY ) / getDistance( start[ 0 ], start[ 1 ], PROPS_CLIENT_XY );
    }
    var MOUSE_INPUT_MAP = {
        mousedown: INPUT_START,
        mousemove: INPUT_MOVE,
        mouseup: INPUT_END
    };
    var MOUSE_ELEMENT_EVENTS = 'mousedown';
    var MOUSE_WINDOW_EVENTS = 'mousemove mouseup';
    /**
     * Mouse events input
     * @constructor
     * @extends Input
     */
    function MouseInput() {
        this.evEl = MOUSE_ELEMENT_EVENTS;
        this.evWin = MOUSE_WINDOW_EVENTS;
        this.allow = true; // used by Input.TouchMouse to disable mouse events
        this.pressed = false; // mousedown state
        Input.apply( this, arguments );
    }
    inherit( MouseInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function MEhandler( ev ) {
            var eventType = MOUSE_INPUT_MAP[ ev.type ];
            // on start we want to have the left mouse button down
            if ( eventType & INPUT_START && ev.button === 0 ) {
                this.pressed = true;
            }
            if ( eventType & INPUT_MOVE && ev.which !== 1 ) {
                eventType = INPUT_END;
            }
            // mouse must be down, and mouse events are allowed (see the TouchMouse input)
            if ( !this.pressed || !this.allow ) {
                return;
            }
            if ( eventType & INPUT_END ) {
                this.pressed = false;
            }
            this.callback( this.manager, eventType, {
                pointers: [ ev ],
                changedPointers: [ ev ],
                pointerType: INPUT_TYPE_MOUSE,
                srcEvent: ev
            } );
        }
    } );
    var POINTER_INPUT_MAP = {
        pointerdown: INPUT_START,
        pointermove: INPUT_MOVE,
        pointerup: INPUT_END,
        pointercancel: INPUT_CANCEL,
        pointerout: INPUT_CANCEL
    };
    // in IE10 the pointer types is defined as an enum
    var IE10_POINTER_TYPE_ENUM = {
        2: INPUT_TYPE_TOUCH,
        3: INPUT_TYPE_PEN,
        4: INPUT_TYPE_MOUSE,
        5: INPUT_TYPE_KINECT // see https://twitter.com/jacobrossi/status/480596438489890816
    };
    var POINTER_ELEMENT_EVENTS = 'pointerdown';
    var POINTER_WINDOW_EVENTS = 'pointermove pointerup pointercancel';
    // IE10 has prefixed support, and case-sensitive
    if ( window.MSPointerEvent ) {
        POINTER_ELEMENT_EVENTS = 'MSPointerDown';
        POINTER_WINDOW_EVENTS = 'MSPointerMove MSPointerUp MSPointerCancel';
    }
    /**
     * Pointer events input
     * @constructor
     * @extends Input
     */
    function PointerEventInput() {
        this.evEl = POINTER_ELEMENT_EVENTS;
        this.evWin = POINTER_WINDOW_EVENTS;
        Input.apply( this, arguments );
        this.store = ( this.manager.session.pointerEvents = [] );
    }
    inherit( PointerEventInput, Input, {
        /**
         * handle mouse events
         * @param {Object} ev
         */
        handler: function PEhandler( ev ) {
            var store = this.store;
            var removePointer = false;
            var eventTypeNormalized = ev.type.toLowerCase().replace( 'ms', '' );
            var eventType = POINTER_INPUT_MAP[ eventTypeNormalized ];
            var pointerType = IE10_POINTER_TYPE_ENUM[ ev.pointerType ] || ev.pointerType;
            var isTouch = ( pointerType == INPUT_TYPE_TOUCH );
            // get index of the event in the store
            var storeIndex = inArray( store, ev.pointerId, 'pointerId' );
            // start and mouse must be down
            if ( eventType & INPUT_START && ( ev.button === 0 || isTouch ) ) {
                if ( storeIndex < 0 ) {
                    store.push( ev );
                    storeIndex = store.length - 1;
                }
            } else if ( eventType & ( INPUT_END | INPUT_CANCEL ) ) {
                removePointer = true;
            }
            // it not found, so the pointer hasn't been down (so it's probably a hover)
            if ( storeIndex < 0 ) {
                return;
            }
            // update the event in the store
            store[ storeIndex ] = ev;
            this.callback( this.manager, eventType, {
                pointers: store,
                changedPointers: [ ev ],
                pointerType: pointerType,
                srcEvent: ev
            } );
            if ( removePointer ) {
                // remove from the store
                store.splice( storeIndex, 1 );
            }
        }
    } );
    var SINGLE_TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };
    var SINGLE_TOUCH_TARGET_EVENTS = 'touchstart';
    var SINGLE_TOUCH_WINDOW_EVENTS = 'touchstart touchmove touchend touchcancel';
    /**
     * Touch events input
     * @constructor
     * @extends Input
     */
    function SingleTouchInput() {
        this.evTarget = SINGLE_TOUCH_TARGET_EVENTS;
        this.evWin = SINGLE_TOUCH_WINDOW_EVENTS;
        this.started = false;
        Input.apply( this, arguments );
    }
    inherit( SingleTouchInput, Input, {
        handler: function TEhandler( ev ) {
            var type = SINGLE_TOUCH_INPUT_MAP[ ev.type ];
            // should we handle the touch events?
            if ( type === INPUT_START ) {
                this.started = true;
            }
            if ( !this.started ) {
                return;
            }
            var touches = normalizeSingleTouches.call( this, ev, type );
            // when done, reset the started state
            if ( type & ( INPUT_END | INPUT_CANCEL ) && touches[ 0 ].length - touches[ 1 ].length === 0 ) {
                this.started = false;
            }
            this.callback( this.manager, type, {
                pointers: touches[ 0 ],
                changedPointers: touches[ 1 ],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            } );
        }
    } );
    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function normalizeSingleTouches( ev, type ) {
        var all = toArray( ev.touches );
        var changed = toArray( ev.changedTouches );
        if ( type & ( INPUT_END | INPUT_CANCEL ) ) {
            all = uniqueArray( all.concat( changed ), 'identifier', true );
        }
        return [ all, changed ];
    }
    var TOUCH_INPUT_MAP = {
        touchstart: INPUT_START,
        touchmove: INPUT_MOVE,
        touchend: INPUT_END,
        touchcancel: INPUT_CANCEL
    };
    var TOUCH_TARGET_EVENTS = 'touchstart touchmove touchend touchcancel';
    /**
     * Multi-user touch events input
     * @constructor
     * @extends Input
     */
    function TouchInput() {
        this.evTarget = TOUCH_TARGET_EVENTS;
        this.targetIds = {};
        Input.apply( this, arguments );
    }
    inherit( TouchInput, Input, {
        handler: function MTEhandler( ev ) {
            var type = TOUCH_INPUT_MAP[ ev.type ];
            var touches = getTouches.call( this, ev, type );
            if ( !touches ) {
                return;
            }
            this.callback( this.manager, type, {
                pointers: touches[ 0 ],
                changedPointers: touches[ 1 ],
                pointerType: INPUT_TYPE_TOUCH,
                srcEvent: ev
            } );
        }
    } );
    /**
     * @this {TouchInput}
     * @param {Object} ev
     * @param {Number} type flag
     * @returns {undefined|Array} [all, changed]
     */
    function getTouches( ev, type ) {
            var allTouches = toArray( ev.touches );
            var targetIds = this.targetIds;
            // when there is only one touch, the process can be simplified
            if ( type & ( INPUT_START | INPUT_MOVE ) && allTouches.length === 1 ) {
                targetIds[ allTouches[ 0 ].identifier ] = true;
                return [ allTouches, allTouches ];
            }
            var i,
                targetTouches,
                changedTouches = toArray( ev.changedTouches ),
                changedTargetTouches = [],
                target = this.target;
            // get target touches from touches
            targetTouches = allTouches.filter( function( touch ) {
                return hasParent( touch.target, target );
            } );
            // collect touches
            if ( type === INPUT_START ) {
                i = 0;
                while ( i < targetTouches.length ) {
                    targetIds[ targetTouches[ i ].identifier ] = true;
                    i++;
                }
            }
            // filter changed touches to only contain touches that exist in the collected target ids
            i = 0;
            while ( i < changedTouches.length ) {
                if ( targetIds[ changedTouches[ i ].identifier ] ) {
                    changedTargetTouches.push( changedTouches[ i ] );
                }
                // cleanup removed touches
                if ( type & ( INPUT_END | INPUT_CANCEL ) ) {
                    delete targetIds[ changedTouches[ i ].identifier ];
                }
                i++;
            }
            if ( !changedTargetTouches.length ) {
                return;
            }
            return [
        // merge targetTouches with changedTargetTouches so it contains ALL touches, including 'end' and 'cancel'
        uniqueArray( targetTouches.concat( changedTargetTouches ), 'identifier', true ),
        changedTargetTouches
    ];
        }
        /**
         * Combined touch and mouse input
         *
         * Touch has a higher priority then mouse, and while touching no mouse events are allowed.
         * This because touch devices also emit mouse events while doing a touch.
         *
         * @constructor
         * @extends Input
         */
    function TouchMouseInput() {
        Input.apply( this, arguments );
        var handler = bindFn( this.handler, this );
        this.touch = new TouchInput( this.manager, handler );
        this.mouse = new MouseInput( this.manager, handler );
    }
    inherit( TouchMouseInput, Input, {
        /**
         * handle mouse and touch events
         * @param {Hammer} manager
         * @param {String} inputEvent
         * @param {Object} inputData
         */
        handler: function TMEhandler( manager, inputEvent, inputData ) {
            var isTouch = ( inputData.pointerType == INPUT_TYPE_TOUCH ),
                isMouse = ( inputData.pointerType == INPUT_TYPE_MOUSE );
            // when we're in a touch event, so  block all upcoming mouse events
            // most mobile browser also emit mouseevents, right after touchstart
            if ( isTouch ) {
                this.mouse.allow = false;
            } else if ( isMouse && !this.mouse.allow ) {
                return;
            }
            // reset the allowMouse when we're done
            if ( inputEvent & ( INPUT_END | INPUT_CANCEL ) ) {
                this.mouse.allow = true;
            }
            this.callback( manager, inputEvent, inputData );
        },
        /**
         * remove the event listeners
         */
        destroy: function destroy() {
            this.touch.destroy();
            this.mouse.destroy();
        }
    } );
    var PREFIXED_TOUCH_ACTION = prefixed( TEST_ELEMENT.style, 'touchAction' );
    var NATIVE_TOUCH_ACTION = PREFIXED_TOUCH_ACTION !== undefined;
    // magical touchAction value
    var TOUCH_ACTION_COMPUTE = 'compute';
    var TOUCH_ACTION_AUTO = 'auto';
    var TOUCH_ACTION_MANIPULATION = 'manipulation'; // not implemented
    var TOUCH_ACTION_NONE = 'none';
    var TOUCH_ACTION_PAN_X = 'pan-x';
    var TOUCH_ACTION_PAN_Y = 'pan-y';
    /**
     * Touch Action
     * sets the touchAction property or uses the js alternative
     * @param {Manager} manager
     * @param {String} value
     * @constructor
     */
    function TouchAction( manager, value ) {
        this.manager = manager;
        this.set( value );
    }
    TouchAction.prototype = {
        /**
         * set the touchAction value on the element or enable the polyfill
         * @param {String} value
         */
        set: function( value ) {
            // find out the touch-action by the event handlers
            if ( value == TOUCH_ACTION_COMPUTE ) {
                value = this.compute();
            }
            if ( NATIVE_TOUCH_ACTION ) {
                this.manager.element.style[ PREFIXED_TOUCH_ACTION ] = value;
            }
            this.actions = value.toLowerCase().trim();
        },
        /**
         * just re-set the touchAction value
         */
        update: function() {
            this.set( this.manager.options.touchAction );
        },
        /**
         * compute the value for the touchAction property based on the recognizer's settings
         * @returns {String} value
         */
        compute: function() {
            var actions = [];
            each( this.manager.recognizers, function( recognizer ) {
                if ( boolOrFn( recognizer.options.enable, [ recognizer ] ) ) {
                    actions = actions.concat( recognizer.getTouchAction() );
                }
            } );
            return cleanTouchActions( actions.join( ' ' ) );
        },
        /**
         * this method is called on each input cycle and provides the preventing of the browser behavior
         * @param {Object} input
         */
        preventDefaults: function( input ) {
            // not needed with native support for the touchAction property
            if ( NATIVE_TOUCH_ACTION ) {
                return;
            }
            var srcEvent = input.srcEvent;
            var direction = input.offsetDirection;
            // if the touch action did prevented once this session
            if ( this.manager.session.prevented ) {
                srcEvent.preventDefault();
                return;
            }
            var actions = this.actions;
            var hasNone = inStr( actions, TOUCH_ACTION_NONE );
            var hasPanY = inStr( actions, TOUCH_ACTION_PAN_Y );
            var hasPanX = inStr( actions, TOUCH_ACTION_PAN_X );
            if ( hasNone || ( hasPanY && direction & DIRECTION_HORIZONTAL ) || ( hasPanX && direction & DIRECTION_VERTICAL ) ) {
                return this.preventSrc( srcEvent );
            }
        },
        /**
         * call preventDefault to prevent the browser's default behavior (scrolling in most cases)
         * @param {Object} srcEvent
         */
        preventSrc: function( srcEvent ) {
            this.manager.session.prevented = true;
            srcEvent.preventDefault();
        }
    };
    /**
     * when the touchActions are collected they are not a valid value, so we need to clean things up. *
     * @param {String} actions
     * @returns {*}
     */
    function cleanTouchActions( actions ) {
            // none
            if ( inStr( actions, TOUCH_ACTION_NONE ) ) {
                return TOUCH_ACTION_NONE;
            }
            var hasPanX = inStr( actions, TOUCH_ACTION_PAN_X );
            var hasPanY = inStr( actions, TOUCH_ACTION_PAN_Y );
            // pan-x and pan-y can be combined
            if ( hasPanX && hasPanY ) {
                return TOUCH_ACTION_PAN_X + ' ' + TOUCH_ACTION_PAN_Y;
            }
            // pan-x OR pan-y
            if ( hasPanX || hasPanY ) {
                return hasPanX ? TOUCH_ACTION_PAN_X : TOUCH_ACTION_PAN_Y;
            }
            // manipulation
            if ( inStr( actions, TOUCH_ACTION_MANIPULATION ) ) {
                return TOUCH_ACTION_MANIPULATION;
            }
            return TOUCH_ACTION_AUTO;
        }
        /**
         * Recognizer flow explained; *
         * All recognizers have the initial state of POSSIBLE when a input session starts.
         * The definition of a input session is from the first input until the last input, with all it's movement in it. *
         * Example session for mouse-input: mousedown -> mousemove -> mouseup
         *
         * On each recognizing cycle (see Manager.recognize) the .recognize() method is executed
         * which determines with state it should be.
         *
         * If the recognizer has the state FAILED, CANCELLED or RECOGNIZED (equals ENDED), it is reset to
         * POSSIBLE to give it another change on the next cycle.
         *
         *               Possible
         *                  |
         *            +-----+---------------+
         *            |                     |
         *      +-----+-----+               |
         *      |           |               |
         *   Failed      Cancelled          |
         *                          +-------+------+
         *                          |              |
         *                      Recognized       Began
         *                                         |
         *                                      Changed
         *                                         |
         *                                  Ended/Recognized
         */
    var STATE_POSSIBLE = 1;
    var STATE_BEGAN = 2;
    var STATE_CHANGED = 4;
    var STATE_ENDED = 8;
    var STATE_RECOGNIZED = STATE_ENDED;
    var STATE_CANCELLED = 16;
    var STATE_FAILED = 32;
    /**
     * Recognizer
     * Every recognizer needs to extend from this class.
     * @constructor
     * @param {Object} options
     */
    function Recognizer( options ) {
        this.id = uniqueId();
        this.manager = null;
        this.options = merge( options || {}, this.defaults );
        // default is enable true
        this.options.enable = ifUndefined( this.options.enable, true );
        this.state = STATE_POSSIBLE;
        this.simultaneous = {};
        this.requireFail = [];
    }
    Recognizer.prototype = {
        /**
         * @virtual
         * @type {Object}
         */
        defaults: {},
        /**
         * set options
         * @param {Object} options
         * @return {Recognizer}
         */
        set: function( options ) {
            extend( this.options, options );
            // also update the touchAction, in case something changed about the directions/enabled state
            this.manager && this.manager.touchAction.update();
            return this;
        },
        /**
         * recognize simultaneous with an other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        recognizeWith: function( otherRecognizer ) {
            if ( invokeArrayArg( otherRecognizer, 'recognizeWith', this ) ) {
                return this;
            }
            var simultaneous = this.simultaneous;
            otherRecognizer = getRecognizerByNameIfManager( otherRecognizer, this );
            if ( !simultaneous[ otherRecognizer.id ] ) {
                simultaneous[ otherRecognizer.id ] = otherRecognizer;
                otherRecognizer.recognizeWith( this );
            }
            return this;
        },
        /**
         * drop the simultaneous link. it doesnt remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRecognizeWith: function( otherRecognizer ) {
            if ( invokeArrayArg( otherRecognizer, 'dropRecognizeWith', this ) ) {
                return this;
            }
            otherRecognizer = getRecognizerByNameIfManager( otherRecognizer, this );
            delete this.simultaneous[ otherRecognizer.id ];
            return this;
        },
        /**
         * recognizer can only run when an other is failing
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        requireFailure: function( otherRecognizer ) {
            if ( invokeArrayArg( otherRecognizer, 'requireFailure', this ) ) {
                return this;
            }
            var requireFail = this.requireFail;
            otherRecognizer = getRecognizerByNameIfManager( otherRecognizer, this );
            if ( inArray( requireFail, otherRecognizer ) === -1 ) {
                requireFail.push( otherRecognizer );
                otherRecognizer.requireFailure( this );
            }
            return this;
        },
        /**
         * drop the requireFailure link. it does not remove the link on the other recognizer.
         * @param {Recognizer} otherRecognizer
         * @returns {Recognizer} this
         */
        dropRequireFailure: function( otherRecognizer ) {
            if ( invokeArrayArg( otherRecognizer, 'dropRequireFailure', this ) ) {
                return this;
            }
            otherRecognizer = getRecognizerByNameIfManager( otherRecognizer, this );
            var index = inArray( this.requireFail, otherRecognizer );
            if ( index > -1 ) {
                this.requireFail.splice( index, 1 );
            }
            return this;
        },
        /**
         * has require failures boolean
         * @returns {boolean}
         */
        hasRequireFailures: function() {
            return this.requireFail.length > 0;
        },
        /**
         * if the recognizer can recognize simultaneous with an other recognizer
         * @param {Recognizer} otherRecognizer
         * @returns {Boolean}
         */
        canRecognizeWith: function( otherRecognizer ) {
            return !!this.simultaneous[ otherRecognizer.id ];
        },
        /**
         * You should use `tryEmit` instead of `emit` directly to check
         * that all the needed recognizers has failed before emitting.
         * @param {Object} input
         */
        emit: function( input ) {
            var self = this;
            var state = this.state;

            function emit( withState ) {
                    self.manager.emit( self.options.event + ( withState ? stateStr( state ) : '' ), input );
                }
                // 'panstart' and 'panmove'
            if ( state < STATE_ENDED ) {
                emit( true );
            }
            emit(); // simple 'eventName' events
            // panend and pancancel
            if ( state >= STATE_ENDED ) {
                emit( true );
            }
        },
        /**
         * Check that all the require failure recognizers has failed,
         * if true, it emits a gesture event,
         * otherwise, setup the state to FAILED.
         * @param {Object} input
         */
        tryEmit: function( input ) {
            if ( this.canEmit() ) {
                return this.emit( input );
            }
            // it's failing anyway
            this.state = STATE_FAILED;
        },
        /**
         * can we emit?
         * @returns {boolean}
         */
        canEmit: function() {
            var i = 0;
            while ( i < this.requireFail.length ) {
                if ( !( this.requireFail[ i ].state & ( STATE_FAILED | STATE_POSSIBLE ) ) ) {
                    return false;
                }
                i++;
            }
            return true;
        },
        /**
         * update the recognizer
         * @param {Object} inputData
         */
        recognize: function( inputData ) {
            // make a new copy of the inputData
            // so we can change the inputData without messing up the other recognizers
            var inputDataClone = extend( {}, inputData );
            // is is enabled and allow recognizing?
            if ( !boolOrFn( this.options.enable, [ this, inputDataClone ] ) ) {
                this.reset();
                this.state = STATE_FAILED;
                return;
            }
            // reset when we've reached the end
            if ( this.state & ( STATE_RECOGNIZED | STATE_CANCELLED | STATE_FAILED ) ) {
                this.state = STATE_POSSIBLE;
            }
            this.state = this.process( inputDataClone );
            // the recognizer has recognized a gesture
            // so trigger an event
            if ( this.state & ( STATE_BEGAN | STATE_CHANGED | STATE_ENDED | STATE_CANCELLED ) ) {
                this.tryEmit( inputDataClone );
            }
        },
        /**
         * return the state of the recognizer
         * the actual recognizing happens in this method
         * @virtual
         * @param {Object} inputData
         * @returns {Const} STATE
         */
        process: function( inputData ) {}, // jshint ignore:line
        /**
         * return the preferred touch-action
         * @virtual
         * @returns {Array}
         */
        getTouchAction: function() {},
        /**
         * called when the gesture isn't allowed to recognize
         * like when another is being recognized or it is disabled
         * @virtual
         */
        reset: function() {}
    };
    /**
     * get a usable string, used as event postfix
     * @param {Const} state
     * @returns {String} state
     */
    function stateStr( state ) {
            if ( state & STATE_CANCELLED ) {
                return 'cancel';
            } else if ( state & STATE_ENDED ) {
                return 'end';
            } else if ( state & STATE_CHANGED ) {
                return 'move';
            } else if ( state & STATE_BEGAN ) {
                return 'start';
            }
            return '';
        }
        /**
         * direction cons to string
         * @param {Const} direction
         * @returns {String}
         */
    function directionStr( direction ) {
            if ( direction == DIRECTION_DOWN ) {
                return 'down';
            } else if ( direction == DIRECTION_UP ) {
                return 'up';
            } else if ( direction == DIRECTION_LEFT ) {
                return 'left';
            } else if ( direction == DIRECTION_RIGHT ) {
                return 'right';
            }
            return '';
        }
        /**
         * get a recognizer by name if it is bound to a manager
         * @param {Recognizer|String} otherRecognizer
         * @param {Recognizer} recognizer
         * @returns {Recognizer}
         */
    function getRecognizerByNameIfManager( otherRecognizer, recognizer ) {
            var manager = recognizer.manager;
            if ( manager ) {
                return manager.get( otherRecognizer );
            }
            return otherRecognizer;
        }
        /**
         * This recognizer is just used as a base for the simple attribute recognizers.
         * @constructor
         * @extends Recognizer
         */
    function AttrRecognizer() {
        Recognizer.apply( this, arguments );
    }
    inherit( AttrRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof AttrRecognizer
         */
        defaults: {
            /**
             * @type {Number}
             * @default 1
             */
            pointers: 1
        },
        /**
         * Used to check if it the recognizer receives valid input, like input.distance > 10.
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {Boolean} recognized
         */
        attrTest: function( input ) {
            var optionPointers = this.options.pointers;
            return optionPointers === 0 || input.pointers.length === optionPointers;
        },
        /**
         * Process the input and return the state for the recognizer
         * @memberof AttrRecognizer
         * @param {Object} input
         * @returns {*} State
         */
        process: function( input ) {
            var state = this.state;
            var eventType = input.eventType;
            var isRecognized = state & ( STATE_BEGAN | STATE_CHANGED );
            var isValid = this.attrTest( input );
            // on cancel input and we've recognized before, return STATE_CANCELLED
            if ( isRecognized && ( eventType & INPUT_CANCEL || !isValid ) ) {
                return state | STATE_CANCELLED;
            } else if ( isRecognized || isValid ) {
                if ( eventType & INPUT_END ) {
                    return state | STATE_ENDED;
                } else if ( !( state & STATE_BEGAN ) ) {
                    return STATE_BEGAN;
                }
                return state | STATE_CHANGED;
            }
            return STATE_FAILED;
        }
    } );
    /**
     * Pan
     * Recognized when the pointer is down and moved in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function PanRecognizer() {
        AttrRecognizer.apply( this, arguments );
        this.pX = null;
        this.pY = null;
    }
    inherit( PanRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PanRecognizer
         */
        defaults: {
            event: 'pan',
            threshold: 10,
            pointers: 1,
            direction: DIRECTION_ALL
        },
        getTouchAction: function() {
            var direction = this.options.direction;
            var actions = [];
            if ( direction & DIRECTION_HORIZONTAL ) {
                actions.push( TOUCH_ACTION_PAN_Y );
            }
            if ( direction & DIRECTION_VERTICAL ) {
                actions.push( TOUCH_ACTION_PAN_X );
            }
            return actions;
        },
        directionTest: function( input ) {
            var options = this.options;
            var hasMoved = true;
            var distance = input.distance;
            var direction = input.direction;
            var x = input.deltaX;
            var y = input.deltaY;
            // lock to axis?
            if ( !( direction & options.direction ) ) {
                if ( options.direction & DIRECTION_HORIZONTAL ) {
                    direction = ( x === 0 ) ? DIRECTION_NONE : ( x < 0 ) ? DIRECTION_LEFT : DIRECTION_RIGHT;
                    hasMoved = x != this.pX;
                    distance = Math.abs( input.deltaX );
                } else {
                    direction = ( y === 0 ) ? DIRECTION_NONE : ( y < 0 ) ? DIRECTION_UP : DIRECTION_DOWN;
                    hasMoved = y != this.pY;
                    distance = Math.abs( input.deltaY );
                }
            }
            input.direction = direction;
            return hasMoved && distance > options.threshold && direction & options.direction;
        },
        attrTest: function( input ) {
            return AttrRecognizer.prototype.attrTest.call( this, input ) && ( this.state & STATE_BEGAN || ( !( this.state & STATE_BEGAN ) && this.directionTest( input ) ) );
        },
        emit: function( input ) {
            this.pX = input.deltaX;
            this.pY = input.deltaY;
            var direction = directionStr( input.direction );
            if ( direction ) {
                this.manager.emit( this.options.event + direction, input );
            }
            this._super.emit.call( this, input );
        }
    } );
    /**
     * Pinch
     * Recognized when two or more pointers are moving toward (zoom-in) or away from each other (zoom-out).
     * @constructor
     * @extends AttrRecognizer
     */
    function PinchRecognizer() {
        AttrRecognizer.apply( this, arguments );
    }
    inherit( PinchRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
            event: 'pinch',
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function() {
            return [ TOUCH_ACTION_NONE ];
        },
        attrTest: function( input ) {
            return this._super.attrTest.call( this, input ) && ( Math.abs( input.scale - 1 ) > this.options.threshold || this.state & STATE_BEGAN );
        },
        emit: function( input ) {
            this._super.emit.call( this, input );
            if ( input.scale !== 1 ) {
                var inOut = input.scale < 1 ? 'in' : 'out';
                this.manager.emit( this.options.event + inOut, input );
            }
        }
    } );
    /**
     * Press
     * Recognized when the pointer is down for x ms without any movement.
     * @constructor
     * @extends Recognizer
     */
    function PressRecognizer() {
        Recognizer.apply( this, arguments );
        this._timer = null;
        this._input = null;
    }
    inherit( PressRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PressRecognizer
         */
        defaults: {
            event: 'press',
            pointers: 1,
            time: 500, // minimal time of the pointer to be pressed
            threshold: 5 // a minimal movement is ok, but keep it low
        },
        getTouchAction: function() {
            return [ TOUCH_ACTION_AUTO ];
        },
        process: function( input ) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTime = input.deltaTime > options.time;
            this._input = input;
            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if ( !validMovement || !validPointers || ( input.eventType & ( INPUT_END | INPUT_CANCEL ) && !validTime ) ) {
                this.reset();
            } else if ( input.eventType & INPUT_START ) {
                this.reset();
                this._timer = setTimeoutContext( function() {
                    this.state = STATE_RECOGNIZED;
                    this.tryEmit();
                }, options.time, this );
            } else if ( input.eventType & INPUT_END ) {
                return STATE_RECOGNIZED;
            }
            return STATE_FAILED;
        },
        reset: function() {
            clearTimeout( this._timer );
        },
        emit: function( input ) {
            if ( this.state !== STATE_RECOGNIZED ) {
                return;
            }
            if ( input && ( input.eventType & INPUT_END ) ) {
                this.manager.emit( this.options.event + 'up', input );
            } else {
                this._input.timeStamp = now();
                this.manager.emit( this.options.event, this._input );
            }
        }
    } );
    /**
     * Rotate
     * Recognized when two or more pointer are moving in a circular motion.
     * @constructor
     * @extends AttrRecognizer
     */
    function RotateRecognizer() {
        AttrRecognizer.apply( this, arguments );
    }
    inherit( RotateRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof RotateRecognizer
         */
        defaults: {
            event: 'rotate',
            threshold: 0,
            pointers: 2
        },
        getTouchAction: function() {
            return [ TOUCH_ACTION_NONE ];
        },
        attrTest: function( input ) {
            return this._super.attrTest.call( this, input ) && ( Math.abs( input.rotation ) > this.options.threshold || this.state & STATE_BEGAN );
        }
    } );
    /**
     * Swipe
     * Recognized when the pointer is moving fast (velocity), with enough distance in the allowed direction.
     * @constructor
     * @extends AttrRecognizer
     */
    function SwipeRecognizer() {
        AttrRecognizer.apply( this, arguments );
    }
    inherit( SwipeRecognizer, AttrRecognizer, {
        /**
         * @namespace
         * @memberof SwipeRecognizer
         */
        defaults: {
            event: 'swipe',
            threshold: 10,
            velocity: 0.65,
            direction: DIRECTION_HORIZONTAL | DIRECTION_VERTICAL,
            pointers: 1
        },
        getTouchAction: function() {
            return PanRecognizer.prototype.getTouchAction.call( this );
        },
        attrTest: function( input ) {
            var direction = this.options.direction;
            var velocity;
            if ( direction & ( DIRECTION_HORIZONTAL | DIRECTION_VERTICAL ) ) {
                velocity = input.velocity;
            } else if ( direction & DIRECTION_HORIZONTAL ) {
                velocity = input.velocityX;
            } else if ( direction & DIRECTION_VERTICAL ) {
                velocity = input.velocityY;
            }
            return this._super.attrTest.call( this, input ) && direction & input.direction && input.distance > this.options.threshold && abs( velocity ) > this.options.velocity && input.eventType & INPUT_END;
        },
        emit: function( input ) {
            var direction = directionStr( input.direction );
            if ( direction ) {
                this.manager.emit( this.options.event + direction, input );
            }
            this.manager.emit( this.options.event, input );
        }
    } );
    /**
     * A tap is ecognized when the pointer is doing a small tap/click. Multiple taps are recognized if they occur
     * between the given interval and position. The delay option can be used to recognize multi-taps without firing
     * a single tap.
     *
     * The eventData from the emitted event contains the property `tapCount`, which contains the amount of
     * multi-taps being recognized.
     * @constructor
     * @extends Recognizer
     */
    function TapRecognizer() {
        Recognizer.apply( this, arguments );
        // previous time and center,
        // used for tap counting
        this.pTime = false;
        this.pCenter = false;
        this._timer = null;
        this._input = null;
        this.count = 0;
    }
    inherit( TapRecognizer, Recognizer, {
        /**
         * @namespace
         * @memberof PinchRecognizer
         */
        defaults: {
            event: 'tap',
            pointers: 1,
            taps: 1,
            interval: 300, // max time between the multi-tap taps
            time: 250, // max time of the pointer to be down (like finger on the screen)
            threshold: 2, // a minimal movement is ok, but keep it low
            posThreshold: 10 // a multi-tap can be a bit off the initial position
        },
        getTouchAction: function() {
            return [ TOUCH_ACTION_MANIPULATION ];
        },
        process: function( input ) {
            var options = this.options;
            var validPointers = input.pointers.length === options.pointers;
            var validMovement = input.distance < options.threshold;
            var validTouchTime = input.deltaTime < options.time;
            this.reset();
            if ( ( input.eventType & INPUT_START ) && ( this.count === 0 ) ) {
                return this.failTimeout();
            }
            // we only allow little movement
            // and we've reached an end event, so a tap is possible
            if ( validMovement && validTouchTime && validPointers ) {
                if ( input.eventType != INPUT_END ) {
                    return this.failTimeout();
                }
                var validInterval = this.pTime ? ( input.timeStamp - this.pTime < options.interval ) : true;
                var validMultiTap = !this.pCenter || getDistance( this.pCenter, input.center ) < options.posThreshold;
                this.pTime = input.timeStamp;
                this.pCenter = input.center;
                if ( !validMultiTap || !validInterval ) {
                    this.count = 1;
                } else {
                    this.count += 1;
                }
                this._input = input;
                // if tap count matches we have recognized it,
                // else it has began recognizing...
                var tapCount = this.count % options.taps;
                if ( tapCount === 0 ) {
                    // no failing requirements, immediately trigger the tap event
                    // or wait as long as the multitap interval to trigger
                    if ( !this.hasRequireFailures() ) {
                        return STATE_RECOGNIZED;
                    } else {
                        this._timer = setTimeoutContext( function() {
                            this.state = STATE_RECOGNIZED;
                            this.tryEmit();
                        }, options.interval, this );
                        return STATE_BEGAN;
                    }
                }
            }
            return STATE_FAILED;
        },
        failTimeout: function() {
            this._timer = setTimeoutContext( function() {
                this.state = STATE_FAILED;
            }, this.options.interval, this );
            return STATE_FAILED;
        },
        reset: function() {
            clearTimeout( this._timer );
        },
        emit: function() {
            if ( this.state == STATE_RECOGNIZED ) {
                this._input.tapCount = this.count;
                this.manager.emit( this.options.event, this._input );
            }
        }
    } );
    /**
     * Simple way to create an manager with a default set of recognizers.
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Hammer( element, options ) {
            options = options || {};
            options.recognizers = ifUndefined( options.recognizers, Hammer.defaults.preset );
            return new Manager( element, options );
        }
        /**
         * @const {string}
         */
    Hammer.VERSION = '2.0.4';
    /**
     * default settings
     * @namespace
     */
    Hammer.defaults = {
        /**
         * set if DOM events are being triggered.
         * But this is slower and unused by simple implementations, so disabled by default.
         * @type {Boolean}
         * @default false
         */
        domEvents: false,
        /**
         * The value for the touchAction property/fallback.
         * When set to `compute` it will magically set the correct value based on the added recognizers.
         * @type {String}
         * @default compute
         */
        touchAction: TOUCH_ACTION_COMPUTE,
        /**
         * @type {Boolean}
         * @default true
         */
        enable: true,
        /**
         * EXPERIMENTAL FEATURE -- can be removed/changed
         * Change the parent input target element.
         * If Null, then it is being set the to main element.
         * @type {Null|EventTarget}
         * @default null
         */
        inputTarget: null,
        /**
         * force an input class
         * @type {Null|Function}
         * @default null
         */
        inputClass: null,
        /**
         * Default recognizer setup when calling `Hammer()`
         * When creating a new Manager these will be skipped.
         * @type {Array}
         */
        preset: [
        // RecognizerClass, options, [recognizeWith, ...], [requireFailure, ...]
        [ RotateRecognizer, {
                enable: false
            } ],
        [ PinchRecognizer, {
                enable: false
            }, [ 'rotate' ] ],
        [ SwipeRecognizer, {
                direction: DIRECTION_HORIZONTAL
            } ],
        [ PanRecognizer, {
                direction: DIRECTION_HORIZONTAL
            }, [ 'swipe' ] ],
        [ TapRecognizer ],
        [ TapRecognizer, {
                event: 'doubletap',
                taps: 2
            }, [ 'tap' ] ],
        [ PressRecognizer ]
    ],
        /**
         * Some CSS properties can be used to improve the working of Hammer.
         * Add them to this method and they will be set when creating a new Manager.
         * @namespace
         */
        cssProps: {
            /**
             * Disables text selection to improve the dragging gesture. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userSelect: 'none',
            /**
             * Disable the Windows Phone grippers when pressing an element.
             * @type {String}
             * @default 'none'
             */
            touchSelect: 'none',
            /**
             * Disables the default callout shown when you touch and hold a touch target.
             * On iOS, when you touch and hold a touch target such as a link, Safari displays
             * a callout containing information about the link. This property allows you to disable that callout.
             * @type {String}
             * @default 'none'
             */
            touchCallout: 'none',
            /**
             * Specifies whether zooming is enabled. Used by IE10>
             * @type {String}
             * @default 'none'
             */
            contentZooming: 'none',
            /**
             * Specifies that an entire element should be draggable instead of its contents. Mainly for desktop browsers.
             * @type {String}
             * @default 'none'
             */
            userDrag: 'none',
            /**
             * Overrides the highlight color shown when the user taps a link or a JavaScript
             * clickable element in iOS. This property obeys the alpha value, if specified.
             * @type {String}
             * @default 'rgba(0,0,0,0)'
             */
            tapHighlightColor: 'rgba(0,0,0,0)'
        }
    };
    var STOP = 1;
    var FORCED_STOP = 2;
    /**
     * Manager
     * @param {HTMLElement} element
     * @param {Object} [options]
     * @constructor
     */
    function Manager( element, options ) {
        options = options || {};
        this.options = merge( options, Hammer.defaults );
        this.options.inputTarget = this.options.inputTarget || element;
        this.handlers = {};
        this.session = {};
        this.recognizers = [];
        this.element = element;
        this.input = createInputInstance( this );
        this.touchAction = new TouchAction( this, this.options.touchAction );
        toggleCssProps( this, true );
        each( options.recognizers, function( item ) {
            var recognizer = this.add( new( item[ 0 ] )( item[ 1 ] ) );
            item[ 2 ] && recognizer.recognizeWith( item[ 2 ] );
            item[ 3 ] && recognizer.requireFailure( item[ 3 ] );
        }, this );
    }
    Manager.prototype = {
        /**
         * set options
         * @param {Object} options
         * @returns {Manager}
         */
        set: function( options ) {
            extend( this.options, options );
            // Options that need a little more setup
            if ( options.touchAction ) {
                this.touchAction.update();
            }
            if ( options.inputTarget ) {
                // Clean up existing event listeners and reinitialize
                this.input.destroy();
                this.input.target = options.inputTarget;
                this.input.init();
            }
            return this;
        },
        /**
         * stop recognizing for this session.
         * This session will be discarded, when a new [input]start event is fired.
         * When forced, the recognizer cycle is stopped immediately.
         * @param {Boolean} [force]
         */
        stop: function( force ) {
            this.session.stopped = force ? FORCED_STOP : STOP;
        },
        /**
         * run the recognizers!
         * called by the inputHandler function on every movement of the pointers (touches)
         * it walks through all the recognizers and tries to detect the gesture that is being made
         * @param {Object} inputData
         */
        recognize: function( inputData ) {
            var session = this.session;
            if ( session.stopped ) {
                return;
            }
            // run the touch-action polyfill
            this.touchAction.preventDefaults( inputData );
            var recognizer;
            var recognizers = this.recognizers;
            // this holds the recognizer that is being recognized.
            // so the recognizer's state needs to be BEGAN, CHANGED, ENDED or RECOGNIZED
            // if no recognizer is detecting a thing, it is set to `null`
            var curRecognizer = session.curRecognizer;
            // reset when the last recognizer is recognized
            // or when we're in a new session
            if ( !curRecognizer || ( curRecognizer && curRecognizer.state & STATE_RECOGNIZED ) ) {
                curRecognizer = session.curRecognizer = null;
            }
            var i = 0;
            while ( i < recognizers.length ) {
                recognizer = recognizers[ i ];
                // find out if we are allowed try to recognize the input for this one.
                // 1.   allow if the session is NOT forced stopped (see the .stop() method)
                // 2.   allow if we still haven't recognized a gesture in this session, or the this recognizer is the one
                //      that is being recognized.
                // 3.   allow if the recognizer is allowed to run simultaneous with the current recognized recognizer.
                //      this can be setup with the `recognizeWith()` method on the recognizer.
                if ( session.stopped !== FORCED_STOP && ( // 1
                        !curRecognizer || recognizer == curRecognizer || // 2
                        recognizer.canRecognizeWith( curRecognizer ) ) ) { // 3
                    recognizer.recognize( inputData );
                } else {
                    recognizer.reset();
                }
                // if the recognizer has been recognizing the input as a valid gesture, we want to store this one as the
                // current active recognizer. but only if we don't already have an active recognizer
                if ( !curRecognizer && recognizer.state & ( STATE_BEGAN | STATE_CHANGED | STATE_ENDED ) ) {
                    curRecognizer = session.curRecognizer = recognizer;
                }
                i++;
            }
        },
        /**
         * get a recognizer by its event name.
         * @param {Recognizer|String} recognizer
         * @returns {Recognizer|Null}
         */
        get: function( recognizer ) {
            if ( recognizer instanceof Recognizer ) {
                return recognizer;
            }
            var recognizers = this.recognizers;
            for ( var i = 0; i < recognizers.length; i++ ) {
                if ( recognizers[ i ].options.event == recognizer ) {
                    return recognizers[ i ];
                }
            }
            return null;
        },
        /**
         * add a recognizer to the manager
         * existing recognizers with the same event name will be removed
         * @param {Recognizer} recognizer
         * @returns {Recognizer|Manager}
         */
        add: function( recognizer ) {
            if ( invokeArrayArg( recognizer, 'add', this ) ) {
                return this;
            }
            // remove existing
            var existing = this.get( recognizer.options.event );
            if ( existing ) {
                this.remove( existing );
            }
            this.recognizers.push( recognizer );
            recognizer.manager = this;
            this.touchAction.update();
            return recognizer;
        },
        /**
         * remove a recognizer by name or instance
         * @param {Recognizer|String} recognizer
         * @returns {Manager}
         */
        remove: function( recognizer ) {
            if ( invokeArrayArg( recognizer, 'remove', this ) ) {
                return this;
            }
            var recognizers = this.recognizers;
            recognizer = this.get( recognizer );
            recognizers.splice( inArray( recognizers, recognizer ), 1 );
            this.touchAction.update();
            return this;
        },
        /**
         * bind event
         * @param {String} events
         * @param {Function} handler
         * @returns {EventEmitter} this
         */
        on: function( events, handler ) {
            var handlers = this.handlers;
            each( splitStr( events ), function( event ) {
                handlers[ event ] = handlers[ event ] || [];
                handlers[ event ].push( handler );
            } );
            return this;
        },
        /**
         * unbind event, leave emit blank to remove all handlers
         * @param {String} events
         * @param {Function} [handler]
         * @returns {EventEmitter} this
         */
        off: function( events, handler ) {
            var handlers = this.handlers;
            each( splitStr( events ), function( event ) {
                if ( !handler ) {
                    delete handlers[ event ];
                } else {
                    handlers[ event ].splice( inArray( handlers[ event ], handler ), 1 );
                }
            } );
            return this;
        },
        /**
         * emit event to the listeners
         * @param {String} event
         * @param {Object} data
         */
        emit: function( event, data ) {
            // we also want to trigger dom events
            if ( this.options.domEvents ) {
                triggerDomEvent( event, data );
            }
            // no handlers, so skip it all
            var handlers = this.handlers[ event ] && this.handlers[ event ].slice();
            if ( !handlers || !handlers.length ) {
                return;
            }
            data.type = event;
            data.preventDefault = function() {
                data.srcEvent.preventDefault();
            };
            var i = 0;
            while ( i < handlers.length ) {
                handlers[ i ]( data );
                i++;
            }
        },
        /**
         * destroy the manager and unbinds all events
         * it doesn't unbind dom events, that is the user own responsibility
         */
        destroy: function() {
            this.element && toggleCssProps( this, false );
            this.handlers = {};
            this.session = {};
            this.input.destroy();
            this.element = null;
        }
    };
    /**
     * add/remove the css properties as defined in manager.options.cssProps
     * @param {Manager} manager
     * @param {Boolean} add
     */
    function toggleCssProps( manager, add ) {
            var element = manager.element;
            each( manager.options.cssProps, function( value, name ) {
                element.style[ prefixed( element.style, name ) ] = add ? value : '';
            } );
        }
        /**
         * trigger dom event
         * @param {String} event
         * @param {Object} data
         */
    function triggerDomEvent( event, data ) {
        var gestureEvent = document.createEvent( 'Event' );
        gestureEvent.initEvent( event, true, true );
        gestureEvent.gesture = data;
        data.target.dispatchEvent( gestureEvent );
    }
    extend( Hammer, {
        INPUT_START: INPUT_START,
        INPUT_MOVE: INPUT_MOVE,
        INPUT_END: INPUT_END,
        INPUT_CANCEL: INPUT_CANCEL,
        STATE_POSSIBLE: STATE_POSSIBLE,
        STATE_BEGAN: STATE_BEGAN,
        STATE_CHANGED: STATE_CHANGED,
        STATE_ENDED: STATE_ENDED,
        STATE_RECOGNIZED: STATE_RECOGNIZED,
        STATE_CANCELLED: STATE_CANCELLED,
        STATE_FAILED: STATE_FAILED,
        DIRECTION_NONE: DIRECTION_NONE,
        DIRECTION_LEFT: DIRECTION_LEFT,
        DIRECTION_RIGHT: DIRECTION_RIGHT,
        DIRECTION_UP: DIRECTION_UP,
        DIRECTION_DOWN: DIRECTION_DOWN,
        DIRECTION_HORIZONTAL: DIRECTION_HORIZONTAL,
        DIRECTION_VERTICAL: DIRECTION_VERTICAL,
        DIRECTION_ALL: DIRECTION_ALL,
        Manager: Manager,
        Input: Input,
        TouchAction: TouchAction,
        TouchInput: TouchInput,
        MouseInput: MouseInput,
        PointerEventInput: PointerEventInput,
        TouchMouseInput: TouchMouseInput,
        SingleTouchInput: SingleTouchInput,
        Recognizer: Recognizer,
        AttrRecognizer: AttrRecognizer,
        Tap: TapRecognizer,
        Pan: PanRecognizer,
        Swipe: SwipeRecognizer,
        Pinch: PinchRecognizer,
        Rotate: RotateRecognizer,
        Press: PressRecognizer,
        on: addEventListeners,
        off: removeEventListeners,
        each: each,
        merge: merge,
        extend: extend,
        inherit: inherit,
        bindFn: bindFn,
        prefixed: prefixed
    } );
    if ( typeof define == TYPE_FUNCTION && define.amd ) {
        define( function() {
            return Hammer;
        } );
    } else if ( typeof module != 'undefined' && module.exports ) {
        module.exports = Hammer;
    } else {
        window[ exportName ] = Hammer;
    }
} )( window, document, 'Hammer' );
/**
 * @license
 * Lo-Dash 2.4.1 (Custom Build) <http://lodash.com/>
 * Build: `lodash -o ./dist/lodash.compat.js`
 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <http://lodash.com/license>
 */
;
( function() {
    /** Used as a safe reference for `undefined` in pre ES5 environments */
    var undefined;
    /** Used to pool arrays and objects used internally */
    var arrayPool = [],
        objectPool = [];
    /** Used to generate unique IDs */
    var idCounter = 0;
    /** Used internally to indicate various things */
    var indicatorObject = {};
    /** Used to prefix keys to avoid issues with `__proto__` and properties on `Object.prototype` */
    var keyPrefix = +new Date + '';
    /** Used as the size when optimizations are enabled for large arrays */
    var largeArraySize = 75;
    /** Used as the max size of the `arrayPool` and `objectPool` */
    var maxPoolSize = 40;
    /** Used to detect and test whitespace */
    var whitespace = (
        // whitespace
        ' \t\x0B\f\xA0\ufeff' +
        // line terminators
        '\n\r\u2028\u2029' +
        // unicode category "Zs" space separators
        '\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u202f\u205f\u3000' );
    /** Used to match empty string literals in compiled template source */
    var reEmptyStringLeading = /\b__p \+= '';/g,
        reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
        reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;
    /**
     * Used to match ES6 template delimiters
     * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-literals-string-literals
     */
    var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;
    /** Used to match regexp flags from their coerced string values */
    var reFlags = /\w*$/;
    /** Used to detected named functions */
    var reFuncName = /^\s*function[ \n\r\t]+\w/;
    /** Used to match "interpolate" template delimiters */
    var reInterpolate = /<%=([\s\S]+?)%>/g;
    /** Used to match leading whitespace and zeros to be removed */
    var reLeadingSpacesAndZeros = RegExp( '^[' + whitespace + ']*0+(?=.$)' );
    /** Used to ensure capturing order of template delimiters */
    var reNoMatch = /($^)/;
    /** Used to detect functions containing a `this` reference */
    var reThis = /\bthis\b/;
    /** Used to match unescaped characters in compiled string literals */
    var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;
    /** Used to assign default `context` object properties */
    var contextProps = [
    'Array', 'Boolean', 'Date', 'Error', 'Function', 'Math', 'Number', 'Object',
    'RegExp', 'String', '_', 'attachEvent', 'clearTimeout', 'isFinite', 'isNaN',
    'parseInt', 'setTimeout'
  ];
    /** Used to fix the JScript [[DontEnum]] bug */
    var shadowedProps = [
    'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
    'toLocaleString', 'toString', 'valueOf'
  ];
    /** Used to make template sourceURLs easier to identify */
    var templateCounter = 0;
    /** `Object#toString` result shortcuts */
    var argsClass = '[object Arguments]',
        arrayClass = '[object Array]',
        boolClass = '[object Boolean]',
        dateClass = '[object Date]',
        errorClass = '[object Error]',
        funcClass = '[object Function]',
        numberClass = '[object Number]',
        objectClass = '[object Object]',
        regexpClass = '[object RegExp]',
        stringClass = '[object String]';
    /** Used to identify object classifications that `_.clone` supports */
    var cloneableClasses = {};
    cloneableClasses[ funcClass ] = false;
    cloneableClasses[ argsClass ] = cloneableClasses[ arrayClass ] = cloneableClasses[ boolClass ] = cloneableClasses[ dateClass ] = cloneableClasses[ numberClass ] = cloneableClasses[ objectClass ] = cloneableClasses[ regexpClass ] = cloneableClasses[ stringClass ] = true;
    /** Used as an internal `_.debounce` options object */
    var debounceOptions = {
        'leading': false,
        'maxWait': 0,
        'trailing': false
    };
    /** Used as the property descriptor for `__bindData__` */
    var descriptor = {
        'configurable': false,
        'enumerable': false,
        'value': null,
        'writable': false
    };
    /** Used as the data object for `iteratorTemplate` */
    var iteratorData = {
        'args': '',
        'array': null,
        'bottom': '',
        'firstArg': '',
        'init': '',
        'keys': null,
        'loop': '',
        'shadowedProps': null,
        'support': null,
        'top': '',
        'useHas': false
    };
    /** Used to determine if values are of the language type Object */
    var objectTypes = {
        'boolean': false,
        'function': true,
        'object': true,
        'number': false,
        'string': false,
        'undefined': false
    };
    /** Used to escape characters for inclusion in compiled string literals */
    var stringEscapes = {
        '\\': '\\',
        "'": "'",
        '\n': 'n',
        '\r': 'r',
        '\t': 't',
        '\u2028': 'u2028',
        '\u2029': 'u2029'
    };
    /** Used as a reference to the global object */
    var root = ( objectTypes[ typeof window ] && window ) || this;
    /** Detect free variable `exports` */
    var freeExports = objectTypes[ typeof exports ] && exports && !exports.nodeType && exports;
    /** Detect free variable `module` */
    var freeModule = objectTypes[ typeof module ] && module && !module.nodeType && module;
    /** Detect the popular CommonJS extension `module.exports` */
    var moduleExports = freeModule && freeModule.exports === freeExports && freeExports;
    /** Detect free variable `global` from Node.js or Browserified code and use it as `root` */
    var freeGlobal = objectTypes[ typeof global ] && global;
    if ( freeGlobal && ( freeGlobal.global === freeGlobal || freeGlobal.window === freeGlobal ) ) {
        root = freeGlobal;
    }
    /*--------------------------------------------------------------------------*/
    /**
     * The base implementation of `_.indexOf` without support for binary searches
     * or `fromIndex` constraints.
     *
     * @private
     * @param {Array} array The array to search.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value or `-1`.
     */
    function baseIndexOf( array, value, fromIndex ) {
            var index = ( fromIndex || 0 ) - 1,
                length = array ? array.length : 0;
            while ( ++index < length ) {
                if ( array[ index ] === value ) {
                    return index;
                }
            }
            return -1;
        }
        /**
         * An implementation of `_.contains` for cache objects that mimics the return
         * signature of `_.indexOf` by returning `0` if the value is found, else `-1`.
         *
         * @private
         * @param {Object} cache The cache object to inspect.
         * @param {*} value The value to search for.
         * @returns {number} Returns `0` if `value` is found, else `-1`.
         */
    function cacheIndexOf( cache, value ) {
            var type = typeof value;
            cache = cache.cache;
            if ( type == 'boolean' || value == null ) {
                return cache[ value ] ? 0 : -1;
            }
            if ( type != 'number' && type != 'string' ) {
                type = 'object';
            }
            var key = type == 'number' ? value : keyPrefix + value;
            cache = ( cache = cache[ type ] ) && cache[ key ];
            return type == 'object' ? ( cache && baseIndexOf( cache, value ) > -1 ? 0 : -1 ) : ( cache ? 0 : -1 );
        }
        /**
         * Adds a given value to the corresponding cache object.
         *
         * @private
         * @param {*} value The value to add to the cache.
         */
    function cachePush( value ) {
            var cache = this.cache,
                type = typeof value;
            if ( type == 'boolean' || value == null ) {
                cache[ value ] = true;
            } else {
                if ( type != 'number' && type != 'string' ) {
                    type = 'object';
                }
                var key = type == 'number' ? value : keyPrefix + value,
                    typeCache = cache[ type ] || ( cache[ type ] = {} );
                if ( type == 'object' ) {
                    ( typeCache[ key ] || ( typeCache[ key ] = [] ) ).push( value );
                } else {
                    typeCache[ key ] = true;
                }
            }
        }
        /**
         * Used by `_.max` and `_.min` as the default callback when a given
         * collection is a string value.
         *
         * @private
         * @param {string} value The character to inspect.
         * @returns {number} Returns the code unit of given character.
         */
    function charAtCallback( value ) {
            return value.charCodeAt( 0 );
        }
        /**
         * Used by `sortBy` to compare transformed `collection` elements, stable sorting
         * them in ascending order.
         *
         * @private
         * @param {Object} a The object to compare to `b`.
         * @param {Object} b The object to compare to `a`.
         * @returns {number} Returns the sort order indicator of `1` or `-1`.
         */
    function compareAscending( a, b ) {
            var ac = a.criteria,
                bc = b.criteria,
                index = -1,
                length = ac.length;
            while ( ++index < length ) {
                var value = ac[ index ],
                    other = bc[ index ];
                if ( value !== other ) {
                    if ( value > other || typeof value == 'undefined' ) {
                        return 1;
                    }
                    if ( value < other || typeof other == 'undefined' ) {
                        return -1;
                    }
                }
            }
            // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
            // that causes it, under certain circumstances, to return the same value for
            // `a` and `b`. See https://github.com/jashkenas/underscore/pull/1247
            //
            // This also ensures a stable sort in V8 and other engines.
            // See http://code.google.com/p/v8/issues/detail?id=90
            return a.index - b.index;
        }
        /**
         * Creates a cache object to optimize linear searches of large arrays.
         *
         * @private
         * @param {Array} [array=[]] The array to search.
         * @returns {null|Object} Returns the cache object or `null` if caching should not be used.
         */
    function createCache( array ) {
            var index = -1,
                length = array.length,
                first = array[ 0 ],
                mid = array[ ( length / 2 ) | 0 ],
                last = array[ length - 1 ];
            if ( first && typeof first == 'object' && mid && typeof mid == 'object' && last && typeof last == 'object' ) {
                return false;
            }
            var cache = getObject();
            cache[ 'false' ] = cache[ 'null' ] = cache[ 'true' ] = cache[ 'undefined' ] = false;
            var result = getObject();
            result.array = array;
            result.cache = cache;
            result.push = cachePush;
            while ( ++index < length ) {
                result.push( array[ index ] );
            }
            return result;
        }
        /**
         * Used by `template` to escape characters for inclusion in compiled
         * string literals.
         *
         * @private
         * @param {string} match The matched character to escape.
         * @returns {string} Returns the escaped character.
         */
    function escapeStringChar( match ) {
            return '\\' + stringEscapes[ match ];
        }
        /**
         * Gets an array from the array pool or creates a new one if the pool is empty.
         *
         * @private
         * @returns {Array} The array from the pool.
         */
    function getArray() {
            return arrayPool.pop() || [];
        }
        /**
         * Gets an object from the object pool or creates a new one if the pool is empty.
         *
         * @private
         * @returns {Object} The object from the pool.
         */
    function getObject() {
            return objectPool.pop() || {
                'array': null,
                'cache': null,
                'criteria': null,
                'false': false,
                'index': 0,
                'null': false,
                'number': null,
                'object': null,
                'push': null,
                'string': null,
                'true': false,
                'undefined': false,
                'value': null
            };
        }
        /**
         * Checks if `value` is a DOM node in IE < 9.
         *
         * @private
         * @param {*} value The value to check.
         * @returns {boolean} Returns `true` if the `value` is a DOM node, else `false`.
         */
    function isNode( value ) {
            // IE < 9 presents DOM nodes as `Object` objects except they have `toString`
            // methods that are `typeof` "string" and still can coerce nodes to strings
            return typeof value.toString != 'function' && typeof( value + '' ) == 'string';
        }
        /**
         * Releases the given array back to the array pool.
         *
         * @private
         * @param {Array} [array] The array to release.
         */
    function releaseArray( array ) {
            array.length = 0;
            if ( arrayPool.length < maxPoolSize ) {
                arrayPool.push( array );
            }
        }
        /**
         * Releases the given object back to the object pool.
         *
         * @private
         * @param {Object} [object] The object to release.
         */
    function releaseObject( object ) {
            var cache = object.cache;
            if ( cache ) {
                releaseObject( cache );
            }
            object.array = object.cache = object.criteria = object.object = object.number = object.string = object.value = null;
            if ( objectPool.length < maxPoolSize ) {
                objectPool.push( object );
            }
        }
        /**
         * Slices the `collection` from the `start` index up to, but not including,
         * the `end` index.
         *
         * Note: This function is used instead of `Array#slice` to support node lists
         * in IE < 9 and to ensure dense arrays are returned.
         *
         * @private
         * @param {Array|Object|string} collection The collection to slice.
         * @param {number} start The start index.
         * @param {number} end The end index.
         * @returns {Array} Returns the new array.
         */
    function slice( array, start, end ) {
            start || ( start = 0 );
            if ( typeof end == 'undefined' ) {
                end = array ? array.length : 0;
            }
            var index = -1,
                length = end - start || 0,
                result = Array( length < 0 ? 0 : length );
            while ( ++index < length ) {
                result[ index ] = array[ start + index ];
            }
            return result;
        }
        /*--------------------------------------------------------------------------*/
        /**
         * Create a new `lodash` function using the given context object.
         *
         * @static
         * @memberOf _
         * @category Utilities
         * @param {Object} [context=root] The context object.
         * @returns {Function} Returns the `lodash` function.
         */
    function runInContext( context ) {
            // Avoid issues with some ES3 environments that attempt to use values, named
            // after built-in constructors like `Object`, for the creation of literals.
            // ES5 clears this up by stating that literals must use built-in constructors.
            // See http://es5.github.io/#x11.1.5.
            context = context ? _.defaults( root.Object(), context, _.pick( root, contextProps ) ) : root;
            /** Native constructor references */
            var Array = context.Array,
                Boolean = context.Boolean,
                Date = context.Date,
                Error = context.Error,
                Function = context.Function,
                Math = context.Math,
                Number = context.Number,
                Object = context.Object,
                RegExp = context.RegExp,
                String = context.String,
                TypeError = context.TypeError;
            /**
             * Used for `Array` method references.
             *
             * Normally `Array.prototype` would suffice, however, using an array literal
             * avoids issues in Narwhal.
             */
            var arrayRef = [];
            /** Used for native method references */
            var errorProto = Error.prototype,
                objectProto = Object.prototype,
                stringProto = String.prototype;
            /** Used to restore the original `_` reference in `noConflict` */
            var oldDash = context._;
            /** Used to resolve the internal [[Class]] of values */
            var toString = objectProto.toString;
            /** Used to detect if a method is native */
            var reNative = RegExp( '^' + String( toString ).replace( /[.*+?^${}()|[\]\\]/g, '\\$&' ).replace( /toString| for [^\]]+/g, '.*?' ) + '$' );
            /** Native method shortcuts */
            var ceil = Math.ceil,
                clearTimeout = context.clearTimeout,
                floor = Math.floor,
                fnToString = Function.prototype.toString,
                getPrototypeOf = isNative( getPrototypeOf = Object.getPrototypeOf ) && getPrototypeOf,
                hasOwnProperty = objectProto.hasOwnProperty,
                push = arrayRef.push,
                propertyIsEnumerable = objectProto.propertyIsEnumerable,
                setTimeout = context.setTimeout,
                splice = arrayRef.splice,
                unshift = arrayRef.unshift;
            /** Used to set meta data on functions */
            var defineProperty = ( function() {
                // IE 8 only accepts DOM elements
                try {
                    var o = {},
                        func = isNative( func = Object.defineProperty ) && func,
                        result = func( o, o, o ) && func;
                } catch ( e ) {}
                return result;
            }() );
            /* Native method shortcuts for methods with the same name as other `lodash` methods */
            var nativeCreate = isNative( nativeCreate = Object.create ) && nativeCreate,
                nativeIsArray = isNative( nativeIsArray = Array.isArray ) && nativeIsArray,
                nativeIsFinite = context.isFinite,
                nativeIsNaN = context.isNaN,
                nativeKeys = isNative( nativeKeys = Object.keys ) && nativeKeys,
                nativeMax = Math.max,
                nativeMin = Math.min,
                nativeParseInt = context.parseInt,
                nativeRandom = Math.random;
            /** Used to lookup a built-in constructor by [[Class]] */
            var ctorByClass = {};
            ctorByClass[ arrayClass ] = Array;
            ctorByClass[ boolClass ] = Boolean;
            ctorByClass[ dateClass ] = Date;
            ctorByClass[ funcClass ] = Function;
            ctorByClass[ objectClass ] = Object;
            ctorByClass[ numberClass ] = Number;
            ctorByClass[ regexpClass ] = RegExp;
            ctorByClass[ stringClass ] = String;
            /** Used to avoid iterating non-enumerable properties in IE < 9 */
            var nonEnumProps = {};
            nonEnumProps[ arrayClass ] = nonEnumProps[ dateClass ] = nonEnumProps[ numberClass ] = {
                'constructor': true,
                'toLocaleString': true,
                'toString': true,
                'valueOf': true
            };
            nonEnumProps[ boolClass ] = nonEnumProps[ stringClass ] = {
                'constructor': true,
                'toString': true,
                'valueOf': true
            };
            nonEnumProps[ errorClass ] = nonEnumProps[ funcClass ] = nonEnumProps[ regexpClass ] = {
                'constructor': true,
                'toString': true
            };
            nonEnumProps[ objectClass ] = {
                'constructor': true
            };
            ( function() {
                var length = shadowedProps.length;
                while ( length-- ) {
                    var key = shadowedProps[ length ];
                    for ( var className in nonEnumProps ) {
                        if ( hasOwnProperty.call( nonEnumProps, className ) && !hasOwnProperty.call( nonEnumProps[ className ], key ) ) {
                            nonEnumProps[ className ][ key ] = false;
                        }
                    }
                }
            }() );
            /*--------------------------------------------------------------------------*/
            /**
             * Creates a `lodash` object which wraps the given value to enable intuitive
             * method chaining.
             *
             * In addition to Lo-Dash methods, wrappers also have the following `Array` methods:
             * `concat`, `join`, `pop`, `push`, `reverse`, `shift`, `slice`, `sort`, `splice`,
             * and `unshift`
             *
             * Chaining is supported in custom builds as long as the `value` method is
             * implicitly or explicitly included in the build.
             *
             * The chainable wrapper functions are:
             * `after`, `assign`, `bind`, `bindAll`, `bindKey`, `chain`, `compact`,
             * `compose`, `concat`, `countBy`, `create`, `createCallback`, `curry`,
             * `debounce`, `defaults`, `defer`, `delay`, `difference`, `filter`, `flatten`,
             * `forEach`, `forEachRight`, `forIn`, `forInRight`, `forOwn`, `forOwnRight`,
             * `functions`, `groupBy`, `indexBy`, `initial`, `intersection`, `invert`,
             * `invoke`, `keys`, `map`, `max`, `memoize`, `merge`, `min`, `object`, `omit`,
             * `once`, `pairs`, `partial`, `partialRight`, `pick`, `pluck`, `pull`, `push`,
             * `range`, `reject`, `remove`, `rest`, `reverse`, `shuffle`, `slice`, `sort`,
             * `sortBy`, `splice`, `tap`, `throttle`, `times`, `toArray`, `transform`,
             * `union`, `uniq`, `unshift`, `unzip`, `values`, `where`, `without`, `wrap`,
             * and `zip`
             *
             * The non-chainable wrapper functions are:
             * `clone`, `cloneDeep`, `contains`, `escape`, `every`, `find`, `findIndex`,
             * `findKey`, `findLast`, `findLastIndex`, `findLastKey`, `has`, `identity`,
             * `indexOf`, `isArguments`, `isArray`, `isBoolean`, `isDate`, `isElement`,
             * `isEmpty`, `isEqual`, `isFinite`, `isFunction`, `isNaN`, `isNull`, `isNumber`,
             * `isObject`, `isPlainObject`, `isRegExp`, `isString`, `isUndefined`, `join`,
             * `lastIndexOf`, `mixin`, `noConflict`, `parseInt`, `pop`, `random`, `reduce`,
             * `reduceRight`, `result`, `shift`, `size`, `some`, `sortedIndex`, `runInContext`,
             * `template`, `unescape`, `uniqueId`, and `value`
             *
             * The wrapper functions `first` and `last` return wrapped values when `n` is
             * provided, otherwise they return unwrapped values.
             *
             * Explicit chaining can be enabled by using the `_.chain` method.
             *
             * @name _
             * @constructor
             * @category Chaining
             * @param {*} value The value to wrap in a `lodash` instance.
             * @returns {Object} Returns a `lodash` instance.
             * @example
             *
             * var wrapped = _([1, 2, 3]);
             *
             * // returns an unwrapped value
             * wrapped.reduce(function(sum, num) {
             *   return sum + num;
             * });
             * // => 6
             *
             * // returns a wrapped value
             * var squares = wrapped.map(function(num) {
             *   return num * num;
             * });
             *
             * _.isArray(squares);
             * // => false
             *
             * _.isArray(squares.value());
             * // => true
             */
            function lodash( value ) {
                    // don't wrap if already wrapped, even if wrapped by a different `lodash` constructor
                    return ( value && typeof value == 'object' && !isArray( value ) && hasOwnProperty.call( value, '__wrapped__' ) ) ? value : new lodashWrapper( value );
                }
                /**
                 * A fast path for creating `lodash` wrapper objects.
                 *
                 * @private
                 * @param {*} value The value to wrap in a `lodash` instance.
                 * @param {boolean} chainAll A flag to enable chaining for all methods
                 * @returns {Object} Returns a `lodash` instance.
                 */
            function lodashWrapper( value, chainAll ) {
                    this.__chain__ = !!chainAll;
                    this.__wrapped__ = value;
                }
                // ensure `new lodashWrapper` is an instance of `lodash`
            lodashWrapper.prototype = lodash.prototype;
            /**
             * An object used to flag environments features.
             *
             * @static
             * @memberOf _
             * @type Object
             */
            var support = lodash.support = {};
            ( function() {
                var ctor = function() {
                        this.x = 1;
                    },
                    object = {
                        '0': 1,
                        'length': 1
                    },
                    props = [];
                ctor.prototype = {
                    'valueOf': 1,
                    'y': 1
                };
                for ( var key in new ctor ) {
                    props.push( key );
                }
                for ( key in arguments ) {}
                /**
                 * Detect if an `arguments` object's [[Class]] is resolvable (all but Firefox < 4, IE < 9).
                 *
                 * @memberOf _.support
                 * @type boolean
                 */
                support.argsClass = toString.call( arguments ) == argsClass;
                /**
                 * Detect if `arguments` objects are `Object` objects (all but Narwhal and Opera < 10.5).
                 *
                 * @memberOf _.support
                 * @type boolean
                 */
                support.argsObject = arguments.constructor == Object && !( arguments instanceof Array );
                /**
                 * Detect if `name` or `message` properties of `Error.prototype` are
                 * enumerable by default. (IE < 9, Safari < 5.1)
                 *
                 * @memberOf _.support
                 * @type boolean
                 */
                support.enumErrorProps = propertyIsEnumerable.call( errorProto, 'message' ) || propertyIsEnumerable.call( errorProto, 'name' );
                /**
                 * Detect if `prototype` properties are enumerable by default.
                 *
                 * Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1
                 * (if the prototype or a property on the prototype has been set)
                 * incorrectly sets a function's `prototype` property [[Enumerable]]
                 * value to `true`.
                 *
                 * @memberOf _.support
                 * @type boolean
                 */
                support.enumPrototypes = propertyIsEnumerable.call( ctor, 'prototype' );
                /**
                 * Detect if functions can be decompiled by `Function#toString`
                 * (all but PS3 and older Opera mobile browsers & avoided in Windows 8 apps).
                 *
                 * @memberOf _.support
                 * @type boolean
                 */
                support.funcDecomp = !isNative( context.WinRTError ) && reThis.test( runInContext );
                /**
                 * Detect if `Function#name` is supported (all but IE).
                 *
                 * @memberOf _.support
                 * @type boolean
                 */
                support.funcNames = typeof Function.name == 'string';
                /**
                 * Detect if `arguments` object indexes are non-enumerable
                 * (Firefox < 4, IE < 9, PhantomJS, Safari < 5.1).
                 *
                 * @memberOf _.support
                 * @type boolean
                 */
                support.nonEnumArgs = key != 0;
                /**
                 * Detect if properties shadowing those on `Object.prototype` are non-enumerable.
                 *
                 * In IE < 9 an objects own properties, shadowing non-enumerable ones, are
                 * made non-enumerable as well (a.k.a the JScript [[DontEnum]] bug).
                 *
                 * @memberOf _.support
                 * @type boolean
                 */
                support.nonEnumShadows = !/valueOf/.test( props );
                /**
                 * Detect if own properties are iterated after inherited properties (all but IE < 9).
                 *
                 * @memberOf _.support
                 * @type boolean
                 */
                support.ownLast = props[ 0 ] != 'x';
                /**
                 * Detect if `Array#shift` and `Array#splice` augment array-like objects correctly.
                 *
                 * Firefox < 10, IE compatibility mode, and IE < 9 have buggy Array `shift()`
                 * and `splice()` functions that fail to remove the last element, `value[0]`,
                 * of array-like objects even though the `length` property is set to `0`.
                 * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`
                 * is buggy regardless of mode in IE < 9 and buggy in compatibility mode in IE 9.
                 *
                 * @memberOf _.support
                 * @type boolean
                 */
                support.spliceObjects = ( arrayRef.splice.call( object, 0, 1 ), !object[ 0 ] );
                /**
                 * Detect lack of support for accessing string characters by index.
                 *
                 * IE < 8 can't access characters by index and IE 8 can only access
                 * characters by index on string literals.
                 *
                 * @memberOf _.support
                 * @type boolean
                 */
                support.unindexedChars = ( 'x' [ 0 ] + Object( 'x' )[ 0 ] ) != 'xx';
                /**
                 * Detect if a DOM node's [[Class]] is resolvable (all but IE < 9)
                 * and that the JS engine errors when attempting to coerce an object to
                 * a string without a `toString` function.
                 *
                 * @memberOf _.support
                 * @type boolean
                 */
                try {
                    support.nodeClass = !( toString.call( document ) == objectClass && !( {
                        'toString': 0
                    } + '' ) );
                } catch ( e ) {
                    support.nodeClass = true;
                }
            }( 1 ) );
            /**
             * By default, the template delimiters used by Lo-Dash are similar to those in
             * embedded Ruby (ERB). Change the following template settings to use alternative
             * delimiters.
             *
             * @static
             * @memberOf _
             * @type Object
             */
            lodash.templateSettings = {
                /**
                 * Used to detect `data` property values to be HTML-escaped.
                 *
                 * @memberOf _.templateSettings
                 * @type RegExp
                 */
                'escape': /<%-([\s\S]+?)%>/g,
                /**
                 * Used to detect code to be evaluated.
                 *
                 * @memberOf _.templateSettings
                 * @type RegExp
                 */
                'evaluate': /<%([\s\S]+?)%>/g,
                /**
                 * Used to detect `data` property values to inject.
                 *
                 * @memberOf _.templateSettings
                 * @type RegExp
                 */
                'interpolate': reInterpolate,
                /**
                 * Used to reference the data object in the template text.
                 *
                 * @memberOf _.templateSettings
                 * @type string
                 */
                'variable': '',
                /**
                 * Used to import variables into the compiled template.
                 *
                 * @memberOf _.templateSettings
                 * @type Object
                 */
                'imports': {
                    /**
                     * A reference to the `lodash` function.
                     *
                     * @memberOf _.templateSettings.imports
                     * @type Function
                     */
                    '_': lodash
                }
            };
            /*--------------------------------------------------------------------------*/
            /**
             * The template used to create iterator functions.
             *
             * @private
             * @param {Object} data The data object used to populate the text.
             * @returns {string} Returns the interpolated text.
             */
            var iteratorTemplate = function( obj ) {
                var __p = 'var index, iterable = ' + ( obj.firstArg ) + ', result = ' + ( obj.init ) + ';\nif (!iterable) return result;\n' + ( obj.top ) + ';';
                if ( obj.array ) {
                    __p += '\nvar length = iterable.length; index = -1;\nif (' + ( obj.array ) + ') {  ';
                    if ( support.unindexedChars ) {
                        __p += '\n  if (isString(iterable)) {\n    iterable = iterable.split(\'\')\n  }  ';
                    }
                    __p += '\n  while (++index < length) {\n    ' + ( obj.loop ) + ';\n  }\n}\nelse {  ';
                } else if ( support.nonEnumArgs ) {
                    __p += '\n  var length = iterable.length; index = -1;\n  if (length && isArguments(iterable)) {\n    while (++index < length) {\n      index += \'\';\n      ' + ( obj.loop ) + ';\n    }\n  } else {  ';
                }
                if ( support.enumPrototypes ) {
                    __p += '\n  var skipProto = typeof iterable == \'function\';\n  ';
                }
                if ( support.enumErrorProps ) {
                    __p += '\n  var skipErrorProps = iterable === errorProto || iterable instanceof Error;\n  ';
                }
                var conditions = [];
                if ( support.enumPrototypes ) {
                    conditions.push( '!(skipProto && index == "prototype")' );
                }
                if ( support.enumErrorProps ) {
                    conditions.push( '!(skipErrorProps && (index == "message" || index == "name"))' );
                }
                if ( obj.useHas && obj.keys ) {
                    __p += '\n  var ownIndex = -1,\n      ownProps = objectTypes[typeof iterable] && keys(iterable),\n      length = ownProps ? ownProps.length : 0;\n\n  while (++ownIndex < length) {\n    index = ownProps[ownIndex];\n';
                    if ( conditions.length ) {
                        __p += '    if (' + ( conditions.join( ' && ' ) ) + ') {\n  ';
                    }
                    __p += ( obj.loop ) + ';    ';
                    if ( conditions.length ) {
                        __p += '\n    }';
                    }
                    __p += '\n  }  ';
                } else {
                    __p += '\n  for (index in iterable) {\n';
                    if ( obj.useHas ) {
                        conditions.push( "hasOwnProperty.call(iterable, index)" );
                    }
                    if ( conditions.length ) {
                        __p += '    if (' + ( conditions.join( ' && ' ) ) + ') {\n  ';
                    }
                    __p += ( obj.loop ) + ';    ';
                    if ( conditions.length ) {
                        __p += '\n    }';
                    }
                    __p += '\n  }    ';
                    if ( support.nonEnumShadows ) {
                        __p += '\n\n  if (iterable !== objectProto) {\n    var ctor = iterable.constructor,\n        isProto = iterable === (ctor && ctor.prototype),\n        className = iterable === stringProto ? stringClass : iterable === errorProto ? errorClass : toString.call(iterable),\n        nonEnum = nonEnumProps[className];\n      ';
                        for ( k = 0; k < 7; k++ ) {
                            __p += '\n    index = \'' + ( obj.shadowedProps[ k ] ) + '\';\n    if ((!(isProto && nonEnum[index]) && hasOwnProperty.call(iterable, index))';
                            if ( !obj.useHas ) {
                                __p += ' || (!nonEnum[index] && iterable[index] !== objectProto[index])';
                            }
                            __p += ') {\n      ' + ( obj.loop ) + ';\n    }      ';
                        }
                        __p += '\n  }    ';
                    }
                }
                if ( obj.array || support.nonEnumArgs ) {
                    __p += '\n}';
                }
                __p += ( obj.bottom ) + ';\nreturn result';
                return __p
            };
            /*--------------------------------------------------------------------------*/
            /**
             * The base implementation of `_.bind` that creates the bound function and
             * sets its meta data.
             *
             * @private
             * @param {Array} bindData The bind data array.
             * @returns {Function} Returns the new bound function.
             */
            function baseBind( bindData ) {
                    var func = bindData[ 0 ],
                        partialArgs = bindData[ 2 ],
                        thisArg = bindData[ 4 ];

                    function bound() {
                        // `Function#bind` spec
                        // http://es5.github.io/#x15.3.4.5
                        if ( partialArgs ) {
                            // avoid `arguments` object deoptimizations by using `slice` instead
                            // of `Array.prototype.slice.call` and not assigning `arguments` to a
                            // variable as a ternary expression
                            var args = slice( partialArgs );
                            push.apply( args, arguments );
                        }
                        // mimic the constructor's `return` behavior
                        // http://es5.github.io/#x13.2.2
                        if ( this instanceof bound ) {
                            // ensure `new bound` is an instance of `func`
                            var thisBinding = baseCreate( func.prototype ),
                                result = func.apply( thisBinding, args || arguments );
                            return isObject( result ) ? result : thisBinding;
                        }
                        return func.apply( thisArg, args || arguments );
                    }
                    setBindData( bound, bindData );
                    return bound;
                }
                /**
                 * The base implementation of `_.clone` without argument juggling or support
                 * for `thisArg` binding.
                 *
                 * @private
                 * @param {*} value The value to clone.
                 * @param {boolean} [isDeep=false] Specify a deep clone.
                 * @param {Function} [callback] The function to customize cloning values.
                 * @param {Array} [stackA=[]] Tracks traversed source objects.
                 * @param {Array} [stackB=[]] Associates clones with source counterparts.
                 * @returns {*} Returns the cloned value.
                 */
            function baseClone( value, isDeep, callback, stackA, stackB ) {
                    if ( callback ) {
                        var result = callback( value );
                        if ( typeof result != 'undefined' ) {
                            return result;
                        }
                    }
                    // inspect [[Class]]
                    var isObj = isObject( value );
                    if ( isObj ) {
                        var className = toString.call( value );
                        if ( !cloneableClasses[ className ] || ( !support.nodeClass && isNode( value ) ) ) {
                            return value;
                        }
                        var ctor = ctorByClass[ className ];
                        switch ( className ) {
                            case boolClass:
                            case dateClass:
                                return new ctor( +value );
                            case numberClass:
                            case stringClass:
                                return new ctor( value );
                            case regexpClass:
                                result = ctor( value.source, reFlags.exec( value ) );
                                result.lastIndex = value.lastIndex;
                                return result;
                        }
                    } else {
                        return value;
                    }
                    var isArr = isArray( value );
                    if ( isDeep ) {
                        // check for circular references and return corresponding clone
                        var initedStack = !stackA;
                        stackA || ( stackA = getArray() );
                        stackB || ( stackB = getArray() );
                        var length = stackA.length;
                        while ( length-- ) {
                            if ( stackA[ length ] == value ) {
                                return stackB[ length ];
                            }
                        }
                        result = isArr ? ctor( value.length ) : {};
                    } else {
                        result = isArr ? slice( value ) : assign( {}, value );
                    }
                    // add array properties assigned by `RegExp#exec`
                    if ( isArr ) {
                        if ( hasOwnProperty.call( value, 'index' ) ) {
                            result.index = value.index;
                        }
                        if ( hasOwnProperty.call( value, 'input' ) ) {
                            result.input = value.input;
                        }
                    }
                    // exit for shallow clone
                    if ( !isDeep ) {
                        return result;
                    }
                    // add the source value to the stack of traversed objects
                    // and associate it with its clone
                    stackA.push( value );
                    stackB.push( result );
                    // recursively populate clone (susceptible to call stack limits)
                    ( isArr ? baseEach : forOwn )( value, function( objValue, key ) {
                        result[ key ] = baseClone( objValue, isDeep, callback, stackA, stackB );
                    } );
                    if ( initedStack ) {
                        releaseArray( stackA );
                        releaseArray( stackB );
                    }
                    return result;
                }
                /**
                 * The base implementation of `_.create` without support for assigning
                 * properties to the created object.
                 *
                 * @private
                 * @param {Object} prototype The object to inherit from.
                 * @returns {Object} Returns the new object.
                 */
            function baseCreate( prototype, properties ) {
                    return isObject( prototype ) ? nativeCreate( prototype ) : {};
                }
                // fallback for browsers without `Object.create`
            if ( !nativeCreate ) {
                baseCreate = ( function() {
                    function Object() {}
                    return function( prototype ) {
                        if ( isObject( prototype ) ) {
                            Object.prototype = prototype;
                            var result = new Object;
                            Object.prototype = null;
                        }
                        return result || context.Object();
                    };
                }() );
            }
            /**
             * The base implementation of `_.createCallback` without support for creating
             * "_.pluck" or "_.where" style callbacks.
             *
             * @private
             * @param {*} [func=identity] The value to convert to a callback.
             * @param {*} [thisArg] The `this` binding of the created callback.
             * @param {number} [argCount] The number of arguments the callback accepts.
             * @returns {Function} Returns a callback function.
             */
            function baseCreateCallback( func, thisArg, argCount ) {
                    if ( typeof func != 'function' ) {
                        return identity;
                    }
                    // exit early for no `thisArg` or already bound by `Function#bind`
                    if ( typeof thisArg == 'undefined' || !( 'prototype' in func ) ) {
                        return func;
                    }
                    var bindData = func.__bindData__;
                    if ( typeof bindData == 'undefined' ) {
                        if ( support.funcNames ) {
                            bindData = !func.name;
                        }
                        bindData = bindData || !support.funcDecomp;
                        if ( !bindData ) {
                            var source = fnToString.call( func );
                            if ( !support.funcNames ) {
                                bindData = !reFuncName.test( source );
                            }
                            if ( !bindData ) {
                                // checks if `func` references the `this` keyword and stores the result
                                bindData = reThis.test( source );
                                setBindData( func, bindData );
                            }
                        }
                    }
                    // exit early if there are no `this` references or `func` is bound
                    if ( bindData === false || ( bindData !== true && bindData[ 1 ] & 1 ) ) {
                        return func;
                    }
                    switch ( argCount ) {
                        case 1:
                            return function( value ) {
                                return func.call( thisArg, value );
                            };
                        case 2:
                            return function( a, b ) {
                                return func.call( thisArg, a, b );
                            };
                        case 3:
                            return function( value, index, collection ) {
                                return func.call( thisArg, value, index, collection );
                            };
                        case 4:
                            return function( accumulator, value, index, collection ) {
                                return func.call( thisArg, accumulator, value, index, collection );
                            };
                    }
                    return bind( func, thisArg );
                }
                /**
                 * The base implementation of `createWrapper` that creates the wrapper and
                 * sets its meta data.
                 *
                 * @private
                 * @param {Array} bindData The bind data array.
                 * @returns {Function} Returns the new function.
                 */
            function baseCreateWrapper( bindData ) {
                    var func = bindData[ 0 ],
                        bitmask = bindData[ 1 ],
                        partialArgs = bindData[ 2 ],
                        partialRightArgs = bindData[ 3 ],
                        thisArg = bindData[ 4 ],
                        arity = bindData[ 5 ];
                    var isBind = bitmask & 1,
                        isBindKey = bitmask & 2,
                        isCurry = bitmask & 4,
                        isCurryBound = bitmask & 8,
                        key = func;

                    function bound() {
                        var thisBinding = isBind ? thisArg : this;
                        if ( partialArgs ) {
                            var args = slice( partialArgs );
                            push.apply( args, arguments );
                        }
                        if ( partialRightArgs || isCurry ) {
                            args || ( args = slice( arguments ) );
                            if ( partialRightArgs ) {
                                push.apply( args, partialRightArgs );
                            }
                            if ( isCurry && args.length < arity ) {
                                bitmask |= 16 & ~32;
                                return baseCreateWrapper( [ func, ( isCurryBound ? bitmask : bitmask & ~3 ), args, null, thisArg, arity ] );
                            }
                        }
                        args || ( args = arguments );
                        if ( isBindKey ) {
                            func = thisBinding[ key ];
                        }
                        if ( this instanceof bound ) {
                            thisBinding = baseCreate( func.prototype );
                            var result = func.apply( thisBinding, args );
                            return isObject( result ) ? result : thisBinding;
                        }
                        return func.apply( thisBinding, args );
                    }
                    setBindData( bound, bindData );
                    return bound;
                }
                /**
                 * The base implementation of `_.difference` that accepts a single array
                 * of values to exclude.
                 *
                 * @private
                 * @param {Array} array The array to process.
                 * @param {Array} [values] The array of values to exclude.
                 * @returns {Array} Returns a new array of filtered values.
                 */
            function baseDifference( array, values ) {
                    var index = -1,
                        indexOf = getIndexOf(),
                        length = array ? array.length : 0,
                        isLarge = length >= largeArraySize && indexOf === baseIndexOf,
                        result = [];
                    if ( isLarge ) {
                        var cache = createCache( values );
                        if ( cache ) {
                            indexOf = cacheIndexOf;
                            values = cache;
                        } else {
                            isLarge = false;
                        }
                    }
                    while ( ++index < length ) {
                        var value = array[ index ];
                        if ( indexOf( values, value ) < 0 ) {
                            result.push( value );
                        }
                    }
                    if ( isLarge ) {
                        releaseObject( values );
                    }
                    return result;
                }
                /**
                 * The base implementation of `_.flatten` without support for callback
                 * shorthands or `thisArg` binding.
                 *
                 * @private
                 * @param {Array} array The array to flatten.
                 * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
                 * @param {boolean} [isStrict=false] A flag to restrict flattening to arrays and `arguments` objects.
                 * @param {number} [fromIndex=0] The index to start from.
                 * @returns {Array} Returns a new flattened array.
                 */
            function baseFlatten( array, isShallow, isStrict, fromIndex ) {
                    var index = ( fromIndex || 0 ) - 1,
                        length = array ? array.length : 0,
                        result = [];
                    while ( ++index < length ) {
                        var value = array[ index ];
                        if ( value && typeof value == 'object' && typeof value.length == 'number' && ( isArray( value ) || isArguments( value ) ) ) {
                            // recursively flatten arrays (susceptible to call stack limits)
                            if ( !isShallow ) {
                                value = baseFlatten( value, isShallow, isStrict );
                            }
                            var valIndex = -1,
                                valLength = value.length,
                                resIndex = result.length;
                            result.length += valLength;
                            while ( ++valIndex < valLength ) {
                                result[ resIndex++ ] = value[ valIndex ];
                            }
                        } else if ( !isStrict ) {
                            result.push( value );
                        }
                    }
                    return result;
                }
                /**
                 * The base implementation of `_.isEqual`, without support for `thisArg` binding,
                 * that allows partial "_.where" style comparisons.
                 *
                 * @private
                 * @param {*} a The value to compare.
                 * @param {*} b The other value to compare.
                 * @param {Function} [callback] The function to customize comparing values.
                 * @param {Function} [isWhere=false] A flag to indicate performing partial comparisons.
                 * @param {Array} [stackA=[]] Tracks traversed `a` objects.
                 * @param {Array} [stackB=[]] Tracks traversed `b` objects.
                 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                 */
            function baseIsEqual( a, b, callback, isWhere, stackA, stackB ) {
                    // used to indicate that when comparing objects, `a` has at least the properties of `b`
                    if ( callback ) {
                        var result = callback( a, b );
                        if ( typeof result != 'undefined' ) {
                            return !!result;
                        }
                    }
                    // exit early for identical values
                    if ( a === b ) {
                        // treat `+0` vs. `-0` as not equal
                        return a !== 0 || ( 1 / a == 1 / b );
                    }
                    var type = typeof a,
                        otherType = typeof b;
                    // exit early for unlike primitive values
                    if ( a === a && !( a && objectTypes[ type ] ) && !( b && objectTypes[ otherType ] ) ) {
                        return false;
                    }
                    // exit early for `null` and `undefined` avoiding ES3's Function#call behavior
                    // http://es5.github.io/#x15.3.4.4
                    if ( a == null || b == null ) {
                        return a === b;
                    }
                    // compare [[Class]] names
                    var className = toString.call( a ),
                        otherClass = toString.call( b );
                    if ( className == argsClass ) {
                        className = objectClass;
                    }
                    if ( otherClass == argsClass ) {
                        otherClass = objectClass;
                    }
                    if ( className != otherClass ) {
                        return false;
                    }
                    switch ( className ) {
                        case boolClass:
                        case dateClass:
                            // coerce dates and booleans to numbers, dates to milliseconds and booleans
                            // to `1` or `0` treating invalid dates coerced to `NaN` as not equal
                            return +a == +b;
                        case numberClass:
                            // treat `NaN` vs. `NaN` as equal
                            return ( a != +a ) ? b != +b
                                // but treat `+0` vs. `-0` as not equal
                                : ( a == 0 ? ( 1 / a == 1 / b ) : a == +b );
                        case regexpClass:
                        case stringClass:
                            // coerce regexes to strings (http://es5.github.io/#x15.10.6.4)
                            // treat string primitives and their corresponding object instances as equal
                            return a == String( b );
                    }
                    var isArr = className == arrayClass;
                    if ( !isArr ) {
                        // unwrap any `lodash` wrapped values
                        var aWrapped = hasOwnProperty.call( a, '__wrapped__' ),
                            bWrapped = hasOwnProperty.call( b, '__wrapped__' );
                        if ( aWrapped || bWrapped ) {
                            return baseIsEqual( aWrapped ? a.__wrapped__ : a, bWrapped ? b.__wrapped__ : b, callback, isWhere, stackA, stackB );
                        }
                        // exit for functions and DOM nodes
                        if ( className != objectClass || ( !support.nodeClass && ( isNode( a ) || isNode( b ) ) ) ) {
                            return false;
                        }
                        // in older versions of Opera, `arguments` objects have `Array` constructors
                        var ctorA = !support.argsObject && isArguments( a ) ? Object : a.constructor,
                            ctorB = !support.argsObject && isArguments( b ) ? Object : b.constructor;
                        // non `Object` object instances with different constructors are not equal
                        if ( ctorA != ctorB && !( isFunction( ctorA ) && ctorA instanceof ctorA && isFunction( ctorB ) && ctorB instanceof ctorB ) && ( 'constructor' in a && 'constructor' in b ) ) {
                            return false;
                        }
                    }
                    // assume cyclic structures are equal
                    // the algorithm for detecting cyclic structures is adapted from ES 5.1
                    // section 15.12.3, abstract operation `JO` (http://es5.github.io/#x15.12.3)
                    var initedStack = !stackA;
                    stackA || ( stackA = getArray() );
                    stackB || ( stackB = getArray() );
                    var length = stackA.length;
                    while ( length-- ) {
                        if ( stackA[ length ] == a ) {
                            return stackB[ length ] == b;
                        }
                    }
                    var size = 0;
                    result = true;
                    // add `a` and `b` to the stack of traversed objects
                    stackA.push( a );
                    stackB.push( b );
                    // recursively compare objects and arrays (susceptible to call stack limits)
                    if ( isArr ) {
                        // compare lengths to determine if a deep comparison is necessary
                        length = a.length;
                        size = b.length;
                        result = size == length;
                        if ( result || isWhere ) {
                            // deep compare the contents, ignoring non-numeric properties
                            while ( size-- ) {
                                var index = length,
                                    value = b[ size ];
                                if ( isWhere ) {
                                    while ( index-- ) {
                                        if ( ( result = baseIsEqual( a[ index ], value, callback, isWhere, stackA, stackB ) ) ) {
                                            break;
                                        }
                                    }
                                } else if ( !( result = baseIsEqual( a[ size ], value, callback, isWhere, stackA, stackB ) ) ) {
                                    break;
                                }
                            }
                        }
                    } else {
                        // deep compare objects using `forIn`, instead of `forOwn`, to avoid `Object.keys`
                        // which, in this case, is more costly
                        forIn( b, function( value, key, b ) {
                            if ( hasOwnProperty.call( b, key ) ) {
                                // count the number of properties.
                                size++;
                                // deep compare each property value.
                                return ( result = hasOwnProperty.call( a, key ) && baseIsEqual( a[ key ], value, callback, isWhere, stackA, stackB ) );
                            }
                        } );
                        if ( result && !isWhere ) {
                            // ensure both objects have the same number of properties
                            forIn( a, function( value, key, a ) {
                                if ( hasOwnProperty.call( a, key ) ) {
                                    // `size` will be `-1` if `a` has more properties than `b`
                                    return ( result = --size > -1 );
                                }
                            } );
                        }
                    }
                    stackA.pop();
                    stackB.pop();
                    if ( initedStack ) {
                        releaseArray( stackA );
                        releaseArray( stackB );
                    }
                    return result;
                }
                /**
                 * The base implementation of `_.merge` without argument juggling or support
                 * for `thisArg` binding.
                 *
                 * @private
                 * @param {Object} object The destination object.
                 * @param {Object} source The source object.
                 * @param {Function} [callback] The function to customize merging properties.
                 * @param {Array} [stackA=[]] Tracks traversed source objects.
                 * @param {Array} [stackB=[]] Associates values with source counterparts.
                 */
            function baseMerge( object, source, callback, stackA, stackB ) {
                    ( isArray( source ) ? forEach : forOwn )( source, function( source, key ) {
                        var found,
                            isArr,
                            result = source,
                            value = object[ key ];
                        if ( source && ( ( isArr = isArray( source ) ) || isPlainObject( source ) ) ) {
                            // avoid merging previously merged cyclic sources
                            var stackLength = stackA.length;
                            while ( stackLength-- ) {
                                if ( ( found = stackA[ stackLength ] == source ) ) {
                                    value = stackB[ stackLength ];
                                    break;
                                }
                            }
                            if ( !found ) {
                                var isShallow;
                                if ( callback ) {
                                    result = callback( value, source );
                                    if ( ( isShallow = typeof result != 'undefined' ) ) {
                                        value = result;
                                    }
                                }
                                if ( !isShallow ) {
                                    value = isArr ? ( isArray( value ) ? value : [] ) : ( isPlainObject( value ) ? value : {} );
                                }
                                // add `source` and associated `value` to the stack of traversed objects
                                stackA.push( source );
                                stackB.push( value );
                                // recursively merge objects and arrays (susceptible to call stack limits)
                                if ( !isShallow ) {
                                    baseMerge( value, source, callback, stackA, stackB );
                                }
                            }
                        } else {
                            if ( callback ) {
                                result = callback( value, source );
                                if ( typeof result == 'undefined' ) {
                                    result = source;
                                }
                            }
                            if ( typeof result != 'undefined' ) {
                                value = result;
                            }
                        }
                        object[ key ] = value;
                    } );
                }
                /**
                 * The base implementation of `_.random` without argument juggling or support
                 * for returning floating-point numbers.
                 *
                 * @private
                 * @param {number} min The minimum possible value.
                 * @param {number} max The maximum possible value.
                 * @returns {number} Returns a random number.
                 */
            function baseRandom( min, max ) {
                    return min + floor( nativeRandom() * ( max - min + 1 ) );
                }
                /**
                 * The base implementation of `_.uniq` without support for callback shorthands
                 * or `thisArg` binding.
                 *
                 * @private
                 * @param {Array} array The array to process.
                 * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
                 * @param {Function} [callback] The function called per iteration.
                 * @returns {Array} Returns a duplicate-value-free array.
                 */
            function baseUniq( array, isSorted, callback ) {
                    var index = -1,
                        indexOf = getIndexOf(),
                        length = array ? array.length : 0,
                        result = [];
                    var isLarge = !isSorted && length >= largeArraySize && indexOf === baseIndexOf,
                        seen = ( callback || isLarge ) ? getArray() : result;
                    if ( isLarge ) {
                        var cache = createCache( seen );
                        indexOf = cacheIndexOf;
                        seen = cache;
                    }
                    while ( ++index < length ) {
                        var value = array[ index ],
                            computed = callback ? callback( value, index, array ) : value;
                        if ( isSorted ? !index || seen[ seen.length - 1 ] !== computed : indexOf( seen, computed ) < 0 ) {
                            if ( callback || isLarge ) {
                                seen.push( computed );
                            }
                            result.push( value );
                        }
                    }
                    if ( isLarge ) {
                        releaseArray( seen.array );
                        releaseObject( seen );
                    } else if ( callback ) {
                        releaseArray( seen );
                    }
                    return result;
                }
                /**
                 * Creates a function that aggregates a collection, creating an object composed
                 * of keys generated from the results of running each element of the collection
                 * through a callback. The given `setter` function sets the keys and values
                 * of the composed object.
                 *
                 * @private
                 * @param {Function} setter The setter function.
                 * @returns {Function} Returns the new aggregator function.
                 */
            function createAggregator( setter ) {
                    return function( collection, callback, thisArg ) {
                        var result = {};
                        callback = lodash.createCallback( callback, thisArg, 3 );
                        if ( isArray( collection ) ) {
                            var index = -1,
                                length = collection.length;
                            while ( ++index < length ) {
                                var value = collection[ index ];
                                setter( result, value, callback( value, index, collection ), collection );
                            }
                        } else {
                            baseEach( collection, function( value, key, collection ) {
                                setter( result, value, callback( value, key, collection ), collection );
                            } );
                        }
                        return result;
                    };
                }
                /**
                 * Creates a function that, when called, either curries or invokes `func`
                 * with an optional `this` binding and partially applied arguments.
                 *
                 * @private
                 * @param {Function|string} func The function or method name to reference.
                 * @param {number} bitmask The bitmask of method flags to compose.
                 *  The bitmask may be composed of the following flags:
                 *  1 - `_.bind`
                 *  2 - `_.bindKey`
                 *  4 - `_.curry`
                 *  8 - `_.curry` (bound)
                 *  16 - `_.partial`
                 *  32 - `_.partialRight`
                 * @param {Array} [partialArgs] An array of arguments to prepend to those
                 *  provided to the new function.
                 * @param {Array} [partialRightArgs] An array of arguments to append to those
                 *  provided to the new function.
                 * @param {*} [thisArg] The `this` binding of `func`.
                 * @param {number} [arity] The arity of `func`.
                 * @returns {Function} Returns the new function.
                 */
            function createWrapper( func, bitmask, partialArgs, partialRightArgs, thisArg, arity ) {
                    var isBind = bitmask & 1,
                        isBindKey = bitmask & 2,
                        isCurry = bitmask & 4,
                        isCurryBound = bitmask & 8,
                        isPartial = bitmask & 16,
                        isPartialRight = bitmask & 32;
                    if ( !isBindKey && !isFunction( func ) ) {
                        throw new TypeError;
                    }
                    if ( isPartial && !partialArgs.length ) {
                        bitmask &= ~16;
                        isPartial = partialArgs = false;
                    }
                    if ( isPartialRight && !partialRightArgs.length ) {
                        bitmask &= ~32;
                        isPartialRight = partialRightArgs = false;
                    }
                    var bindData = func && func.__bindData__;
                    if ( bindData && bindData !== true ) {
                        // clone `bindData`
                        bindData = slice( bindData );
                        if ( bindData[ 2 ] ) {
                            bindData[ 2 ] = slice( bindData[ 2 ] );
                        }
                        if ( bindData[ 3 ] ) {
                            bindData[ 3 ] = slice( bindData[ 3 ] );
                        }
                        // set `thisBinding` is not previously bound
                        if ( isBind && !( bindData[ 1 ] & 1 ) ) {
                            bindData[ 4 ] = thisArg;
                        }
                        // set if previously bound but not currently (subsequent curried functions)
                        if ( !isBind && bindData[ 1 ] & 1 ) {
                            bitmask |= 8;
                        }
                        // set curried arity if not yet set
                        if ( isCurry && !( bindData[ 1 ] & 4 ) ) {
                            bindData[ 5 ] = arity;
                        }
                        // append partial left arguments
                        if ( isPartial ) {
                            push.apply( bindData[ 2 ] || ( bindData[ 2 ] = [] ), partialArgs );
                        }
                        // append partial right arguments
                        if ( isPartialRight ) {
                            unshift.apply( bindData[ 3 ] || ( bindData[ 3 ] = [] ), partialRightArgs );
                        }
                        // merge flags
                        bindData[ 1 ] |= bitmask;
                        return createWrapper.apply( null, bindData );
                    }
                    // fast path for `_.bind`
                    var creater = ( bitmask == 1 || bitmask === 17 ) ? baseBind : baseCreateWrapper;
                    return creater( [ func, bitmask, partialArgs, partialRightArgs, thisArg, arity ] );
                }
                /**
                 * Creates compiled iteration functions.
                 *
                 * @private
                 * @param {...Object} [options] The compile options object(s).
                 * @param {string} [options.array] Code to determine if the iterable is an array or array-like.
                 * @param {boolean} [options.useHas] Specify using `hasOwnProperty` checks in the object loop.
                 * @param {Function} [options.keys] A reference to `_.keys` for use in own property iteration.
                 * @param {string} [options.args] A comma separated string of iteration function arguments.
                 * @param {string} [options.top] Code to execute before the iteration branches.
                 * @param {string} [options.loop] Code to execute in the object loop.
                 * @param {string} [options.bottom] Code to execute after the iteration branches.
                 * @returns {Function} Returns the compiled function.
                 */
            function createIterator() {
                    // data properties
                    iteratorData.shadowedProps = shadowedProps;
                    // iterator options
                    iteratorData.array = iteratorData.bottom = iteratorData.loop = iteratorData.top = '';
                    iteratorData.init = 'iterable';
                    iteratorData.useHas = true;
                    // merge options into a template data object
                    for ( var object, index = 0; object = arguments[ index ]; index++ ) {
                        for ( var key in object ) {
                            iteratorData[ key ] = object[ key ];
                        }
                    }
                    var args = iteratorData.args;
                    iteratorData.firstArg = /^[^,]+/.exec( args )[ 0 ];
                    // create the function factory
                    var factory = Function( 'baseCreateCallback, errorClass, errorProto, hasOwnProperty, ' + 'indicatorObject, isArguments, isArray, isString, keys, objectProto, ' + 'objectTypes, nonEnumProps, stringClass, stringProto, toString', 'return function(' + args + ') {\n' + iteratorTemplate( iteratorData ) + '\n}' );
                    // return the compiled function
                    return factory( baseCreateCallback, errorClass, errorProto, hasOwnProperty, indicatorObject, isArguments, isArray, isString, iteratorData.keys, objectProto, objectTypes, nonEnumProps, stringClass, stringProto, toString );
                }
                /**
                 * Used by `escape` to convert characters to HTML entities.
                 *
                 * @private
                 * @param {string} match The matched character to escape.
                 * @returns {string} Returns the escaped character.
                 */
            function escapeHtmlChar( match ) {
                    return htmlEscapes[ match ];
                }
                /**
                 * Gets the appropriate "indexOf" function. If the `_.indexOf` method is
                 * customized, this method returns the custom method, otherwise it returns
                 * the `baseIndexOf` function.
                 *
                 * @private
                 * @returns {Function} Returns the "indexOf" function.
                 */
            function getIndexOf() {
                    var result = ( result = lodash.indexOf ) === indexOf ? baseIndexOf : result;
                    return result;
                }
                /**
                 * Checks if `value` is a native function.
                 *
                 * @private
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if the `value` is a native function, else `false`.
                 */
            function isNative( value ) {
                    return typeof value == 'function' && reNative.test( value );
                }
                /**
                 * Sets `this` binding data on a given function.
                 *
                 * @private
                 * @param {Function} func The function to set data on.
                 * @param {Array} value The data array to set.
                 */
            var setBindData = !defineProperty ? noop : function( func, value ) {
                descriptor.value = value;
                defineProperty( func, '__bindData__', descriptor );
            };
            /**
             * A fallback implementation of `isPlainObject` which checks if a given value
             * is an object created by the `Object` constructor, assuming objects created
             * by the `Object` constructor have no inherited enumerable properties and that
             * there are no `Object.prototype` extensions.
             *
             * @private
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
             */
            function shimIsPlainObject( value ) {
                    var ctor,
                        result;
                    // avoid non Object objects, `arguments` objects, and DOM elements
                    if ( !( value && toString.call( value ) == objectClass ) || ( ctor = value.constructor, isFunction( ctor ) && !( ctor instanceof ctor ) ) || ( !support.argsClass && isArguments( value ) ) || ( !support.nodeClass && isNode( value ) ) ) {
                        return false;
                    }
                    // IE < 9 iterates inherited properties before own properties. If the first
                    // iterated property is an object's own property then there are no inherited
                    // enumerable properties.
                    if ( support.ownLast ) {
                        forIn( value, function( value, key, object ) {
                            result = hasOwnProperty.call( object, key );
                            return false;
                        } );
                        return result !== false;
                    }
                    // In most environments an object's own properties are iterated before
                    // its inherited properties. If the last iterated property is an object's
                    // own property then there are no inherited enumerable properties.
                    forIn( value, function( value, key ) {
                        result = key;
                    } );
                    return typeof result == 'undefined' || hasOwnProperty.call( value, result );
                }
                /**
                 * Used by `unescape` to convert HTML entities to characters.
                 *
                 * @private
                 * @param {string} match The matched character to unescape.
                 * @returns {string} Returns the unescaped character.
                 */
            function unescapeHtmlChar( match ) {
                    return htmlUnescapes[ match ];
                }
                /*--------------------------------------------------------------------------*/
                /**
                 * Checks if `value` is an `arguments` object.
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
                 * @example
                 *
                 * (function() { return _.isArguments(arguments); })(1, 2, 3);
                 * // => true
                 *
                 * _.isArguments([1, 2, 3]);
                 * // => false
                 */
            function isArguments( value ) {
                    return value && typeof value == 'object' && typeof value.length == 'number' && toString.call( value ) == argsClass || false;
                }
                // fallback for browsers that can't detect `arguments` objects by [[Class]]
            if ( !support.argsClass ) {
                isArguments = function( value ) {
                    return value && typeof value == 'object' && typeof value.length == 'number' && hasOwnProperty.call( value, 'callee' ) && !propertyIsEnumerable.call( value, 'callee' ) || false;
                };
            }
            /**
             * Checks if `value` is an array.
             *
             * @static
             * @memberOf _
             * @type Function
             * @category Objects
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if the `value` is an array, else `false`.
             * @example
             *
             * (function() { return _.isArray(arguments); })();
             * // => false
             *
             * _.isArray([1, 2, 3]);
             * // => true
             */
            var isArray = nativeIsArray || function( value ) {
                return value && typeof value == 'object' && typeof value.length == 'number' && toString.call( value ) == arrayClass || false;
            };
            /**
             * A fallback implementation of `Object.keys` which produces an array of the
             * given object's own enumerable property names.
             *
             * @private
             * @type Function
             * @param {Object} object The object to inspect.
             * @returns {Array} Returns an array of property names.
             */
            var shimKeys = createIterator( {
                'args': 'object',
                'init': '[]',
                'top': 'if (!(objectTypes[typeof object])) return result',
                'loop': 'result.push(index)'
            } );
            /**
             * Creates an array composed of the own enumerable property names of an object.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Object} object The object to inspect.
             * @returns {Array} Returns an array of property names.
             * @example
             *
             * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
             * // => ['one', 'two', 'three'] (property order is not guaranteed across environments)
             */
            var keys = !nativeKeys ? shimKeys : function( object ) {
                if ( !isObject( object ) ) {
                    return [];
                }
                if ( ( support.enumPrototypes && typeof object == 'function' ) || ( support.nonEnumArgs && object.length && isArguments( object ) ) ) {
                    return shimKeys( object );
                }
                return nativeKeys( object );
            };
            /** Reusable iterator options shared by `each`, `forIn`, and `forOwn` */
            var eachIteratorOptions = {
                'args': 'collection, callback, thisArg',
                'top': "callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback(callback, thisArg, 3)",
                'array': "typeof length == 'number'",
                'keys': keys,
                'loop': 'if (callback(iterable[index], index, collection) === false) return result'
            };
            /** Reusable iterator options for `assign` and `defaults` */
            var defaultsIteratorOptions = {
                'args': 'object, source, guard',
                'top': 'var args = arguments,\n' + '    argsIndex = 0,\n' + "    argsLength = typeof guard == 'number' ? 2 : args.length;\n" + 'while (++argsIndex < argsLength) {\n' + '  iterable = args[argsIndex];\n' + '  if (iterable && objectTypes[typeof iterable]) {',
                'keys': keys,
                'loop': "if (typeof result[index] == 'undefined') result[index] = iterable[index]",
                'bottom': '  }\n}'
            };
            /** Reusable iterator options for `forIn` and `forOwn` */
            var forOwnIteratorOptions = {
                'top': 'if (!objectTypes[typeof iterable]) return result;\n' + eachIteratorOptions.top,
                'array': false
            };
            /**
             * Used to convert characters to HTML entities:
             *
             * Though the `>` character is escaped for symmetry, characters like `>` and `/`
             * don't require escaping in HTML and have no special meaning unless they're part
             * of a tag or an unquoted attribute value.
             * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
             */
            var htmlEscapes = {
                '&': '&amp;',
                '<': '&lt;',
                '>': '&gt;',
                '"': '&quot;',
                "'": '&#39;'
            };
            /** Used to convert HTML entities to characters */
            var htmlUnescapes = invert( htmlEscapes );
            /** Used to match HTML entities and HTML characters */
            var reEscapedHtml = RegExp( '(' + keys( htmlUnescapes ).join( '|' ) + ')', 'g' ),
                reUnescapedHtml = RegExp( '[' + keys( htmlEscapes ).join( '' ) + ']', 'g' );
            /**
             * A function compiled to iterate `arguments` objects, arrays, objects, and
             * strings consistenly across environments, executing the callback for each
             * element in the collection. The callback is bound to `thisArg` and invoked
             * with three arguments; (value, index|key, collection). Callbacks may exit
             * iteration early by explicitly returning `false`.
             *
             * @private
             * @type Function
             * @param {Array|Object|string} collection The collection to iterate over.
             * @param {Function} [callback=identity] The function called per iteration.
             * @param {*} [thisArg] The `this` binding of `callback`.
             * @returns {Array|Object|string} Returns `collection`.
             */
            var baseEach = createIterator( eachIteratorOptions );
            /*--------------------------------------------------------------------------*/
            /**
             * Assigns own enumerable properties of source object(s) to the destination
             * object. Subsequent sources will overwrite property assignments of previous
             * sources. If a callback is provided it will be executed to produce the
             * assigned values. The callback is bound to `thisArg` and invoked with two
             * arguments; (objectValue, sourceValue).
             *
             * @static
             * @memberOf _
             * @type Function
             * @alias extend
             * @category Objects
             * @param {Object} object The destination object.
             * @param {...Object} [source] The source objects.
             * @param {Function} [callback] The function to customize assigning values.
             * @param {*} [thisArg] The `this` binding of `callback`.
             * @returns {Object} Returns the destination object.
             * @example
             *
             * _.assign({ 'name': 'fred' }, { 'employer': 'slate' });
             * // => { 'name': 'fred', 'employer': 'slate' }
             *
             * var defaults = _.partialRight(_.assign, function(a, b) {
             *   return typeof a == 'undefined' ? b : a;
             * });
             *
             * var object = { 'name': 'barney' };
             * defaults(object, { 'name': 'fred', 'employer': 'slate' });
             * // => { 'name': 'barney', 'employer': 'slate' }
             */
            var assign = createIterator( defaultsIteratorOptions, {
                'top': defaultsIteratorOptions.top.replace( ';', ';\n' + "if (argsLength > 3 && typeof args[argsLength - 2] == 'function') {\n" + '  var callback = baseCreateCallback(args[--argsLength - 1], args[argsLength--], 2);\n' + "} else if (argsLength > 2 && typeof args[argsLength - 1] == 'function') {\n" + '  callback = args[--argsLength];\n' + '}' ),
                'loop': 'result[index] = callback ? callback(result[index], iterable[index]) : iterable[index]'
            } );
            /**
             * Creates a clone of `value`. If `isDeep` is `true` nested objects will also
             * be cloned, otherwise they will be assigned by reference. If a callback
             * is provided it will be executed to produce the cloned values. If the
             * callback returns `undefined` cloning will be handled by the method instead.
             * The callback is bound to `thisArg` and invoked with one argument; (value).
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {*} value The value to clone.
             * @param {boolean} [isDeep=false] Specify a deep clone.
             * @param {Function} [callback] The function to customize cloning values.
             * @param {*} [thisArg] The `this` binding of `callback`.
             * @returns {*} Returns the cloned value.
             * @example
             *
             * var characters = [
             *   { 'name': 'barney', 'age': 36 },
             *   { 'name': 'fred',   'age': 40 }
             * ];
             *
             * var shallow = _.clone(characters);
             * shallow[0] === characters[0];
             * // => true
             *
             * var deep = _.clone(characters, true);
             * deep[0] === characters[0];
             * // => false
             *
             * _.mixin({
             *   'clone': _.partialRight(_.clone, function(value) {
             *     return _.isElement(value) ? value.cloneNode(false) : undefined;
             *   })
             * });
             *
             * var clone = _.clone(document.body);
             * clone.childNodes.length;
             * // => 0
             */
            function clone( value, isDeep, callback, thisArg ) {
                    // allows working with "Collections" methods without using their `index`
                    // and `collection` arguments for `isDeep` and `callback`
                    if ( typeof isDeep != 'boolean' && isDeep != null ) {
                        thisArg = callback;
                        callback = isDeep;
                        isDeep = false;
                    }
                    return baseClone( value, isDeep, typeof callback == 'function' && baseCreateCallback( callback, thisArg, 1 ) );
                }
                /**
                 * Creates a deep clone of `value`. If a callback is provided it will be
                 * executed to produce the cloned values. If the callback returns `undefined`
                 * cloning will be handled by the method instead. The callback is bound to
                 * `thisArg` and invoked with one argument; (value).
                 *
                 * Note: This method is loosely based on the structured clone algorithm. Functions
                 * and DOM nodes are **not** cloned. The enumerable properties of `arguments` objects and
                 * objects created by constructors other than `Object` are cloned to plain `Object` objects.
                 * See http://www.w3.org/TR/html5/infrastructure.html#internal-structured-cloning-algorithm.
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {*} value The value to deep clone.
                 * @param {Function} [callback] The function to customize cloning values.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {*} Returns the deep cloned value.
                 * @example
                 *
                 * var characters = [
                 *   { 'name': 'barney', 'age': 36 },
                 *   { 'name': 'fred',   'age': 40 }
                 * ];
                 *
                 * var deep = _.cloneDeep(characters);
                 * deep[0] === characters[0];
                 * // => false
                 *
                 * var view = {
                 *   'label': 'docs',
                 *   'node': element
                 * };
                 *
                 * var clone = _.cloneDeep(view, function(value) {
                 *   return _.isElement(value) ? value.cloneNode(true) : undefined;
                 * });
                 *
                 * clone.node == view.node;
                 * // => false
                 */
            function cloneDeep( value, callback, thisArg ) {
                    return baseClone( value, true, typeof callback == 'function' && baseCreateCallback( callback, thisArg, 1 ) );
                }
                /**
                 * Creates an object that inherits from the given `prototype` object. If a
                 * `properties` object is provided its own enumerable properties are assigned
                 * to the created object.
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {Object} prototype The object to inherit from.
                 * @param {Object} [properties] The properties to assign to the object.
                 * @returns {Object} Returns the new object.
                 * @example
                 *
                 * function Shape() {
                 *   this.x = 0;
                 *   this.y = 0;
                 * }
                 *
                 * function Circle() {
                 *   Shape.call(this);
                 * }
                 *
                 * Circle.prototype = _.create(Shape.prototype, { 'constructor': Circle });
                 *
                 * var circle = new Circle;
                 * circle instanceof Circle;
                 * // => true
                 *
                 * circle instanceof Shape;
                 * // => true
                 */
            function create( prototype, properties ) {
                    var result = baseCreate( prototype );
                    return properties ? assign( result, properties ) : result;
                }
                /**
                 * Assigns own enumerable properties of source object(s) to the destination
                 * object for all destination properties that resolve to `undefined`. Once a
                 * property is set, additional defaults of the same property will be ignored.
                 *
                 * @static
                 * @memberOf _
                 * @type Function
                 * @category Objects
                 * @param {Object} object The destination object.
                 * @param {...Object} [source] The source objects.
                 * @param- {Object} [guard] Allows working with `_.reduce` without using its
                 *  `key` and `object` arguments as sources.
                 * @returns {Object} Returns the destination object.
                 * @example
                 *
                 * var object = { 'name': 'barney' };
                 * _.defaults(object, { 'name': 'fred', 'employer': 'slate' });
                 * // => { 'name': 'barney', 'employer': 'slate' }
                 */
            var defaults = createIterator( defaultsIteratorOptions );
            /**
             * This method is like `_.findIndex` except that it returns the key of the
             * first element that passes the callback check, instead of the element itself.
             *
             * If a property name is provided for `callback` the created "_.pluck" style
             * callback will return the property value of the given element.
             *
             * If an object is provided for `callback` the created "_.where" style callback
             * will return `true` for elements that have the properties of the given object,
             * else `false`.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Object} object The object to search.
             * @param {Function|Object|string} [callback=identity] The function called per
             *  iteration. If a property name or object is provided it will be used to
             *  create a "_.pluck" or "_.where" style callback, respectively.
             * @param {*} [thisArg] The `this` binding of `callback`.
             * @returns {string|undefined} Returns the key of the found element, else `undefined`.
             * @example
             *
             * var characters = {
             *   'barney': {  'age': 36, 'blocked': false },
             *   'fred': {    'age': 40, 'blocked': true },
             *   'pebbles': { 'age': 1,  'blocked': false }
             * };
             *
             * _.findKey(characters, function(chr) {
             *   return chr.age < 40;
             * });
             * // => 'barney' (property order is not guaranteed across environments)
             *
             * // using "_.where" callback shorthand
             * _.findKey(characters, { 'age': 1 });
             * // => 'pebbles'
             *
             * // using "_.pluck" callback shorthand
             * _.findKey(characters, 'blocked');
             * // => 'fred'
             */
            function findKey( object, callback, thisArg ) {
                    var result;
                    callback = lodash.createCallback( callback, thisArg, 3 );
                    forOwn( object, function( value, key, object ) {
                        if ( callback( value, key, object ) ) {
                            result = key;
                            return false;
                        }
                    } );
                    return result;
                }
                /**
                 * This method is like `_.findKey` except that it iterates over elements
                 * of a `collection` in the opposite order.
                 *
                 * If a property name is provided for `callback` the created "_.pluck" style
                 * callback will return the property value of the given element.
                 *
                 * If an object is provided for `callback` the created "_.where" style callback
                 * will return `true` for elements that have the properties of the given object,
                 * else `false`.
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {Object} object The object to search.
                 * @param {Function|Object|string} [callback=identity] The function called per
                 *  iteration. If a property name or object is provided it will be used to
                 *  create a "_.pluck" or "_.where" style callback, respectively.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {string|undefined} Returns the key of the found element, else `undefined`.
                 * @example
                 *
                 * var characters = {
                 *   'barney': {  'age': 36, 'blocked': true },
                 *   'fred': {    'age': 40, 'blocked': false },
                 *   'pebbles': { 'age': 1,  'blocked': true }
                 * };
                 *
                 * _.findLastKey(characters, function(chr) {
                 *   return chr.age < 40;
                 * });
                 * // => returns `pebbles`, assuming `_.findKey` returns `barney`
                 *
                 * // using "_.where" callback shorthand
                 * _.findLastKey(characters, { 'age': 40 });
                 * // => 'fred'
                 *
                 * // using "_.pluck" callback shorthand
                 * _.findLastKey(characters, 'blocked');
                 * // => 'pebbles'
                 */
            function findLastKey( object, callback, thisArg ) {
                    var result;
                    callback = lodash.createCallback( callback, thisArg, 3 );
                    forOwnRight( object, function( value, key, object ) {
                        if ( callback( value, key, object ) ) {
                            result = key;
                            return false;
                        }
                    } );
                    return result;
                }
                /**
                 * Iterates over own and inherited enumerable properties of an object,
                 * executing the callback for each property. The callback is bound to `thisArg`
                 * and invoked with three arguments; (value, key, object). Callbacks may exit
                 * iteration early by explicitly returning `false`.
                 *
                 * @static
                 * @memberOf _
                 * @type Function
                 * @category Objects
                 * @param {Object} object The object to iterate over.
                 * @param {Function} [callback=identity] The function called per iteration.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * function Shape() {
                 *   this.x = 0;
                 *   this.y = 0;
                 * }
                 *
                 * Shape.prototype.move = function(x, y) {
                 *   this.x += x;
                 *   this.y += y;
                 * };
                 *
                 * _.forIn(new Shape, function(value, key) {
                 *   console.log(key);
                 * });
                 * // => logs 'x', 'y', and 'move' (property order is not guaranteed across environments)
                 */
            var forIn = createIterator( eachIteratorOptions, forOwnIteratorOptions, {
                'useHas': false
            } );
            /**
             * This method is like `_.forIn` except that it iterates over elements
             * of a `collection` in the opposite order.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Object} object The object to iterate over.
             * @param {Function} [callback=identity] The function called per iteration.
             * @param {*} [thisArg] The `this` binding of `callback`.
             * @returns {Object} Returns `object`.
             * @example
             *
             * function Shape() {
             *   this.x = 0;
             *   this.y = 0;
             * }
             *
             * Shape.prototype.move = function(x, y) {
             *   this.x += x;
             *   this.y += y;
             * };
             *
             * _.forInRight(new Shape, function(value, key) {
             *   console.log(key);
             * });
             * // => logs 'move', 'y', and 'x' assuming `_.forIn ` logs 'x', 'y', and 'move'
             */
            function forInRight( object, callback, thisArg ) {
                    var pairs = [];
                    forIn( object, function( value, key ) {
                        pairs.push( key, value );
                    } );
                    var length = pairs.length;
                    callback = baseCreateCallback( callback, thisArg, 3 );
                    while ( length-- ) {
                        if ( callback( pairs[ length-- ], pairs[ length ], object ) === false ) {
                            break;
                        }
                    }
                    return object;
                }
                /**
                 * Iterates over own enumerable properties of an object, executing the callback
                 * for each property. The callback is bound to `thisArg` and invoked with three
                 * arguments; (value, key, object). Callbacks may exit iteration early by
                 * explicitly returning `false`.
                 *
                 * @static
                 * @memberOf _
                 * @type Function
                 * @category Objects
                 * @param {Object} object The object to iterate over.
                 * @param {Function} [callback=identity] The function called per iteration.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
                 *   console.log(key);
                 * });
                 * // => logs '0', '1', and 'length' (property order is not guaranteed across environments)
                 */
            var forOwn = createIterator( eachIteratorOptions, forOwnIteratorOptions );
            /**
             * This method is like `_.forOwn` except that it iterates over elements
             * of a `collection` in the opposite order.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {Object} object The object to iterate over.
             * @param {Function} [callback=identity] The function called per iteration.
             * @param {*} [thisArg] The `this` binding of `callback`.
             * @returns {Object} Returns `object`.
             * @example
             *
             * _.forOwnRight({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
             *   console.log(key);
             * });
             * // => logs 'length', '1', and '0' assuming `_.forOwn` logs '0', '1', and 'length'
             */
            function forOwnRight( object, callback, thisArg ) {
                    var props = keys( object ),
                        length = props.length;
                    callback = baseCreateCallback( callback, thisArg, 3 );
                    while ( length-- ) {
                        var key = props[ length ];
                        if ( callback( object[ key ], key, object ) === false ) {
                            break;
                        }
                    }
                    return object;
                }
                /**
                 * Creates a sorted array of property names of all enumerable properties,
                 * own and inherited, of `object` that have function values.
                 *
                 * @static
                 * @memberOf _
                 * @alias methods
                 * @category Objects
                 * @param {Object} object The object to inspect.
                 * @returns {Array} Returns an array of property names that have function values.
                 * @example
                 *
                 * _.functions(_);
                 * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
                 */
            function functions( object ) {
                    var result = [];
                    forIn( object, function( value, key ) {
                        if ( isFunction( value ) ) {
                            result.push( key );
                        }
                    } );
                    return result.sort();
                }
                /**
                 * Checks if the specified property name exists as a direct property of `object`,
                 * instead of an inherited property.
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {Object} object The object to inspect.
                 * @param {string} key The name of the property to check.
                 * @returns {boolean} Returns `true` if key is a direct property, else `false`.
                 * @example
                 *
                 * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
                 * // => true
                 */
            function has( object, key ) {
                    return object ? hasOwnProperty.call( object, key ) : false;
                }
                /**
                 * Creates an object composed of the inverted keys and values of the given object.
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {Object} object The object to invert.
                 * @returns {Object} Returns the created inverted object.
                 * @example
                 *
                 * _.invert({ 'first': 'fred', 'second': 'barney' });
                 * // => { 'fred': 'first', 'barney': 'second' }
                 */
            function invert( object ) {
                    var index = -1,
                        props = keys( object ),
                        length = props.length,
                        result = {};
                    while ( ++index < length ) {
                        var key = props[ index ];
                        result[ object[ key ] ] = key;
                    }
                    return result;
                }
                /**
                 * Checks if `value` is a boolean value.
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if the `value` is a boolean value, else `false`.
                 * @example
                 *
                 * _.isBoolean(null);
                 * // => false
                 */
            function isBoolean( value ) {
                    return value === true || value === false || value && typeof value == 'object' && toString.call( value ) == boolClass || false;
                }
                /**
                 * Checks if `value` is a date.
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if the `value` is a date, else `false`.
                 * @example
                 *
                 * _.isDate(new Date);
                 * // => true
                 */
            function isDate( value ) {
                    return value && typeof value == 'object' && toString.call( value ) == dateClass || false;
                }
                /**
                 * Checks if `value` is a DOM element.
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if the `value` is a DOM element, else `false`.
                 * @example
                 *
                 * _.isElement(document.body);
                 * // => true
                 */
            function isElement( value ) {
                    return value && value.nodeType === 1 || false;
                }
                /**
                 * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
                 * length of `0` and objects with no own enumerable properties are considered
                 * "empty".
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {Array|Object|string} value The value to inspect.
                 * @returns {boolean} Returns `true` if the `value` is empty, else `false`.
                 * @example
                 *
                 * _.isEmpty([1, 2, 3]);
                 * // => false
                 *
                 * _.isEmpty({});
                 * // => true
                 *
                 * _.isEmpty('');
                 * // => true
                 */
            function isEmpty( value ) {
                    var result = true;
                    if ( !value ) {
                        return result;
                    }
                    var className = toString.call( value ),
                        length = value.length;
                    if ( ( className == arrayClass || className == stringClass || ( support.argsClass ? className == argsClass : isArguments( value ) ) ) || ( className == objectClass && typeof length == 'number' && isFunction( value.splice ) ) ) {
                        return !length;
                    }
                    forOwn( value, function() {
                        return ( result = false );
                    } );
                    return result;
                }
                /**
                 * Performs a deep comparison between two values to determine if they are
                 * equivalent to each other. If a callback is provided it will be executed
                 * to compare values. If the callback returns `undefined` comparisons will
                 * be handled by the method instead. The callback is bound to `thisArg` and
                 * invoked with two arguments; (a, b).
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {*} a The value to compare.
                 * @param {*} b The other value to compare.
                 * @param {Function} [callback] The function to customize comparing values.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
                 * @example
                 *
                 * var object = { 'name': 'fred' };
                 * var copy = { 'name': 'fred' };
                 *
                 * object == copy;
                 * // => false
                 *
                 * _.isEqual(object, copy);
                 * // => true
                 *
                 * var words = ['hello', 'goodbye'];
                 * var otherWords = ['hi', 'goodbye'];
                 *
                 * _.isEqual(words, otherWords, function(a, b) {
                 *   var reGreet = /^(?:hello|hi)$/i,
                 *       aGreet = _.isString(a) && reGreet.test(a),
                 *       bGreet = _.isString(b) && reGreet.test(b);
                 *
                 *   return (aGreet || bGreet) ? (aGreet == bGreet) : undefined;
                 * });
                 * // => true
                 */
            function isEqual( a, b, callback, thisArg ) {
                    return baseIsEqual( a, b, typeof callback == 'function' && baseCreateCallback( callback, thisArg, 2 ) );
                }
                /**
                 * Checks if `value` is, or can be coerced to, a finite number.
                 *
                 * Note: This is not the same as native `isFinite` which will return true for
                 * booleans and empty strings. See http://es5.github.io/#x15.1.2.5.
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if the `value` is finite, else `false`.
                 * @example
                 *
                 * _.isFinite(-101);
                 * // => true
                 *
                 * _.isFinite('10');
                 * // => true
                 *
                 * _.isFinite(true);
                 * // => false
                 *
                 * _.isFinite('');
                 * // => false
                 *
                 * _.isFinite(Infinity);
                 * // => false
                 */
            function isFinite( value ) {
                    return nativeIsFinite( value ) && !nativeIsNaN( parseFloat( value ) );
                }
                /**
                 * Checks if `value` is a function.
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if the `value` is a function, else `false`.
                 * @example
                 *
                 * _.isFunction(_);
                 * // => true
                 */
            function isFunction( value ) {
                    return typeof value == 'function';
                }
                // fallback for older versions of Chrome and Safari
            if ( isFunction( /x/ ) ) {
                isFunction = function( value ) {
                    return typeof value == 'function' && toString.call( value ) == funcClass;
                };
            }
            /**
             * Checks if `value` is the language type of Object.
             * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if the `value` is an object, else `false`.
             * @example
             *
             * _.isObject({});
             * // => true
             *
             * _.isObject([1, 2, 3]);
             * // => true
             *
             * _.isObject(1);
             * // => false
             */
            function isObject( value ) {
                    // check if the value is the ECMAScript language type of Object
                    // http://es5.github.io/#x8
                    // and avoid a V8 bug
                    // http://code.google.com/p/v8/issues/detail?id=2291
                    return !!( value && objectTypes[ typeof value ] );
                }
                /**
                 * Checks if `value` is `NaN`.
                 *
                 * Note: This is not the same as native `isNaN` which will return `true` for
                 * `undefined` and other non-numeric values. See http://es5.github.io/#x15.1.2.4.
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if the `value` is `NaN`, else `false`.
                 * @example
                 *
                 * _.isNaN(NaN);
                 * // => true
                 *
                 * _.isNaN(new Number(NaN));
                 * // => true
                 *
                 * isNaN(undefined);
                 * // => true
                 *
                 * _.isNaN(undefined);
                 * // => false
                 */
            function isNaN( value ) {
                    // `NaN` as a primitive is the only value that is not equal to itself
                    // (perform the [[Class]] check first to avoid errors with some host objects in IE)
                    return isNumber( value ) && value != +value;
                }
                /**
                 * Checks if `value` is `null`.
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if the `value` is `null`, else `false`.
                 * @example
                 *
                 * _.isNull(null);
                 * // => true
                 *
                 * _.isNull(undefined);
                 * // => false
                 */
            function isNull( value ) {
                    return value === null;
                }
                /**
                 * Checks if `value` is a number.
                 *
                 * Note: `NaN` is considered a number. See http://es5.github.io/#x8.5.
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if the `value` is a number, else `false`.
                 * @example
                 *
                 * _.isNumber(8.4 * 5);
                 * // => true
                 */
            function isNumber( value ) {
                    return typeof value == 'number' || value && typeof value == 'object' && toString.call( value ) == numberClass || false;
                }
                /**
                 * Checks if `value` is an object created by the `Object` constructor.
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
                 * @example
                 *
                 * function Shape() {
                 *   this.x = 0;
                 *   this.y = 0;
                 * }
                 *
                 * _.isPlainObject(new Shape);
                 * // => false
                 *
                 * _.isPlainObject([1, 2, 3]);
                 * // => false
                 *
                 * _.isPlainObject({ 'x': 0, 'y': 0 });
                 * // => true
                 */
            var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function( value ) {
                if ( !( value && toString.call( value ) == objectClass ) || ( !support.argsClass && isArguments( value ) ) ) {
                    return false;
                }
                var valueOf = value.valueOf,
                    objProto = isNative( valueOf ) && ( objProto = getPrototypeOf( valueOf ) ) && getPrototypeOf( objProto );
                return objProto ? ( value == objProto || getPrototypeOf( value ) == objProto ) : shimIsPlainObject( value );
            };
            /**
             * Checks if `value` is a regular expression.
             *
             * @static
             * @memberOf _
             * @category Objects
             * @param {*} value The value to check.
             * @returns {boolean} Returns `true` if the `value` is a regular expression, else `false`.
             * @example
             *
             * _.isRegExp(/fred/);
             * // => true
             */
            function isRegExp( value ) {
                    return value && objectTypes[ typeof value ] && toString.call( value ) == regexpClass || false;
                }
                /**
                 * Checks if `value` is a string.
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if the `value` is a string, else `false`.
                 * @example
                 *
                 * _.isString('fred');
                 * // => true
                 */
            function isString( value ) {
                    return typeof value == 'string' || value && typeof value == 'object' && toString.call( value ) == stringClass || false;
                }
                /**
                 * Checks if `value` is `undefined`.
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {*} value The value to check.
                 * @returns {boolean} Returns `true` if the `value` is `undefined`, else `false`.
                 * @example
                 *
                 * _.isUndefined(void 0);
                 * // => true
                 */
            function isUndefined( value ) {
                    return typeof value == 'undefined';
                }
                /**
                 * Creates an object with the same keys as `object` and values generated by
                 * running each own enumerable property of `object` through the callback.
                 * The callback is bound to `thisArg` and invoked with three arguments;
                 * (value, key, object).
                 *
                 * If a property name is provided for `callback` the created "_.pluck" style
                 * callback will return the property value of the given element.
                 *
                 * If an object is provided for `callback` the created "_.where" style callback
                 * will return `true` for elements that have the properties of the given object,
                 * else `false`.
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {Object} object The object to iterate over.
                 * @param {Function|Object|string} [callback=identity] The function called
                 *  per iteration. If a property name or object is provided it will be used
                 *  to create a "_.pluck" or "_.where" style callback, respectively.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {Array} Returns a new object with values of the results of each `callback` execution.
                 * @example
                 *
                 * _.mapValues({ 'a': 1, 'b': 2, 'c': 3} , function(num) { return num * 3; });
                 * // => { 'a': 3, 'b': 6, 'c': 9 }
                 *
                 * var characters = {
                 *   'fred': { 'name': 'fred', 'age': 40 },
                 *   'pebbles': { 'name': 'pebbles', 'age': 1 }
                 * };
                 *
                 * // using "_.pluck" callback shorthand
                 * _.mapValues(characters, 'age');
                 * // => { 'fred': 40, 'pebbles': 1 }
                 */
            function mapValues( object, callback, thisArg ) {
                    var result = {};
                    callback = lodash.createCallback( callback, thisArg, 3 );
                    forOwn( object, function( value, key, object ) {
                        result[ key ] = callback( value, key, object );
                    } );
                    return result;
                }
                /**
                 * Recursively merges own enumerable properties of the source object(s), that
                 * don't resolve to `undefined` into the destination object. Subsequent sources
                 * will overwrite property assignments of previous sources. If a callback is
                 * provided it will be executed to produce the merged values of the destination
                 * and source properties. If the callback returns `undefined` merging will
                 * be handled by the method instead. The callback is bound to `thisArg` and
                 * invoked with two arguments; (objectValue, sourceValue).
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {Object} object The destination object.
                 * @param {...Object} [source] The source objects.
                 * @param {Function} [callback] The function to customize merging properties.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {Object} Returns the destination object.
                 * @example
                 *
                 * var names = {
                 *   'characters': [
                 *     { 'name': 'barney' },
                 *     { 'name': 'fred' }
                 *   ]
                 * };
                 *
                 * var ages = {
                 *   'characters': [
                 *     { 'age': 36 },
                 *     { 'age': 40 }
                 *   ]
                 * };
                 *
                 * _.merge(names, ages);
                 * // => { 'characters': [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred', 'age': 40 }] }
                 *
                 * var food = {
                 *   'fruits': ['apple'],
                 *   'vegetables': ['beet']
                 * };
                 *
                 * var otherFood = {
                 *   'fruits': ['banana'],
                 *   'vegetables': ['carrot']
                 * };
                 *
                 * _.merge(food, otherFood, function(a, b) {
                 *   return _.isArray(a) ? a.concat(b) : undefined;
                 * });
                 * // => { 'fruits': ['apple', 'banana'], 'vegetables': ['beet', 'carrot] }
                 */
            function merge( object ) {
                    var args = arguments,
                        length = 2;
                    if ( !isObject( object ) ) {
                        return object;
                    }
                    // allows working with `_.reduce` and `_.reduceRight` without using
                    // their `index` and `collection` arguments
                    if ( typeof args[ 2 ] != 'number' ) {
                        length = args.length;
                    }
                    if ( length > 3 && typeof args[ length - 2 ] == 'function' ) {
                        var callback = baseCreateCallback( args[ --length - 1 ], args[ length-- ], 2 );
                    } else if ( length > 2 && typeof args[ length - 1 ] == 'function' ) {
                        callback = args[ --length ];
                    }
                    var sources = slice( arguments, 1, length ),
                        index = -1,
                        stackA = getArray(),
                        stackB = getArray();
                    while ( ++index < length ) {
                        baseMerge( object, sources[ index ], callback, stackA, stackB );
                    }
                    releaseArray( stackA );
                    releaseArray( stackB );
                    return object;
                }
                /**
                 * Creates a shallow clone of `object` excluding the specified properties.
                 * Property names may be specified as individual arguments or as arrays of
                 * property names. If a callback is provided it will be executed for each
                 * property of `object` omitting the properties the callback returns truey
                 * for. The callback is bound to `thisArg` and invoked with three arguments;
                 * (value, key, object).
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {Object} object The source object.
                 * @param {Function|...string|string[]} [callback] The properties to omit or the
                 *  function called per iteration.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {Object} Returns an object without the omitted properties.
                 * @example
                 *
                 * _.omit({ 'name': 'fred', 'age': 40 }, 'age');
                 * // => { 'name': 'fred' }
                 *
                 * _.omit({ 'name': 'fred', 'age': 40 }, function(value) {
                 *   return typeof value == 'number';
                 * });
                 * // => { 'name': 'fred' }
                 */
            function omit( object, callback, thisArg ) {
                    var result = {};
                    if ( typeof callback != 'function' ) {
                        var props = [];
                        forIn( object, function( value, key ) {
                            props.push( key );
                        } );
                        props = baseDifference( props, baseFlatten( arguments, true, false, 1 ) );
                        var index = -1,
                            length = props.length;
                        while ( ++index < length ) {
                            var key = props[ index ];
                            result[ key ] = object[ key ];
                        }
                    } else {
                        callback = lodash.createCallback( callback, thisArg, 3 );
                        forIn( object, function( value, key, object ) {
                            if ( !callback( value, key, object ) ) {
                                result[ key ] = value;
                            }
                        } );
                    }
                    return result;
                }
                /**
                 * Creates a two dimensional array of an object's key-value pairs,
                 * i.e. `[[key1, value1], [key2, value2]]`.
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {Object} object The object to inspect.
                 * @returns {Array} Returns new array of key-value pairs.
                 * @example
                 *
                 * _.pairs({ 'barney': 36, 'fred': 40 });
                 * // => [['barney', 36], ['fred', 40]] (property order is not guaranteed across environments)
                 */
            function pairs( object ) {
                    var index = -1,
                        props = keys( object ),
                        length = props.length,
                        result = Array( length );
                    while ( ++index < length ) {
                        var key = props[ index ];
                        result[ index ] = [ key, object[ key ] ];
                    }
                    return result;
                }
                /**
                 * Creates a shallow clone of `object` composed of the specified properties.
                 * Property names may be specified as individual arguments or as arrays of
                 * property names. If a callback is provided it will be executed for each
                 * property of `object` picking the properties the callback returns truey
                 * for. The callback is bound to `thisArg` and invoked with three arguments;
                 * (value, key, object).
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {Object} object The source object.
                 * @param {Function|...string|string[]} [callback] The function called per
                 *  iteration or property names to pick, specified as individual property
                 *  names or arrays of property names.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {Object} Returns an object composed of the picked properties.
                 * @example
                 *
                 * _.pick({ 'name': 'fred', '_userid': 'fred1' }, 'name');
                 * // => { 'name': 'fred' }
                 *
                 * _.pick({ 'name': 'fred', '_userid': 'fred1' }, function(value, key) {
                 *   return key.charAt(0) != '_';
                 * });
                 * // => { 'name': 'fred' }
                 */
            function pick( object, callback, thisArg ) {
                    var result = {};
                    if ( typeof callback != 'function' ) {
                        var index = -1,
                            props = baseFlatten( arguments, true, false, 1 ),
                            length = isObject( object ) ? props.length : 0;
                        while ( ++index < length ) {
                            var key = props[ index ];
                            if ( key in object ) {
                                result[ key ] = object[ key ];
                            }
                        }
                    } else {
                        callback = lodash.createCallback( callback, thisArg, 3 );
                        forIn( object, function( value, key, object ) {
                            if ( callback( value, key, object ) ) {
                                result[ key ] = value;
                            }
                        } );
                    }
                    return result;
                }
                /**
                 * An alternative to `_.reduce` this method transforms `object` to a new
                 * `accumulator` object which is the result of running each of its own
                 * enumerable properties through a callback, with each callback execution
                 * potentially mutating the `accumulator` object. The callback is bound to
                 * `thisArg` and invoked with four arguments; (accumulator, value, key, object).
                 * Callbacks may exit iteration early by explicitly returning `false`.
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {Array|Object} object The object to iterate over.
                 * @param {Function} [callback=identity] The function called per iteration.
                 * @param {*} [accumulator] The custom accumulator value.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {*} Returns the accumulated value.
                 * @example
                 *
                 * var squares = _.transform([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], function(result, num) {
                 *   num *= num;
                 *   if (num % 2) {
                 *     return result.push(num) < 3;
                 *   }
                 * });
                 * // => [1, 9, 25]
                 *
                 * var mapped = _.transform({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
                 *   result[key] = num * 3;
                 * });
                 * // => { 'a': 3, 'b': 6, 'c': 9 }
                 */
            function transform( object, callback, accumulator, thisArg ) {
                    var isArr = isArray( object );
                    if ( accumulator == null ) {
                        if ( isArr ) {
                            accumulator = [];
                        } else {
                            var ctor = object && object.constructor,
                                proto = ctor && ctor.prototype;
                            accumulator = baseCreate( proto );
                        }
                    }
                    if ( callback ) {
                        callback = lodash.createCallback( callback, thisArg, 4 );
                        ( isArr ? baseEach : forOwn )( object, function( value, index, object ) {
                            return callback( accumulator, value, index, object );
                        } );
                    }
                    return accumulator;
                }
                /**
                 * Creates an array composed of the own enumerable property values of `object`.
                 *
                 * @static
                 * @memberOf _
                 * @category Objects
                 * @param {Object} object The object to inspect.
                 * @returns {Array} Returns an array of property values.
                 * @example
                 *
                 * _.values({ 'one': 1, 'two': 2, 'three': 3 });
                 * // => [1, 2, 3] (property order is not guaranteed across environments)
                 */
            function values( object ) {
                    var index = -1,
                        props = keys( object ),
                        length = props.length,
                        result = Array( length );
                    while ( ++index < length ) {
                        result[ index ] = object[ props[ index ] ];
                    }
                    return result;
                }
                /*--------------------------------------------------------------------------*/
                /**
                 * Creates an array of elements from the specified indexes, or keys, of the
                 * `collection`. Indexes may be specified as individual arguments or as arrays
                 * of indexes.
                 *
                 * @static
                 * @memberOf _
                 * @category Collections
                 * @param {Array|Object|string} collection The collection to iterate over.
                 * @param {...(number|number[]|string|string[])} [index] The indexes of `collection`
                 *   to retrieve, specified as individual indexes or arrays of indexes.
                 * @returns {Array} Returns a new array of elements corresponding to the
                 *  provided indexes.
                 * @example
                 *
                 * _.at(['a', 'b', 'c', 'd', 'e'], [0, 2, 4]);
                 * // => ['a', 'c', 'e']
                 *
                 * _.at(['fred', 'barney', 'pebbles'], 0, 2);
                 * // => ['fred', 'pebbles']
                 */
            function at( collection ) {
                    var args = arguments,
                        index = -1,
                        props = baseFlatten( args, true, false, 1 ),
                        length = ( args[ 2 ] && args[ 2 ][ args[ 1 ] ] === collection ) ? 1 : props.length,
                        result = Array( length );
                    if ( support.unindexedChars && isString( collection ) ) {
                        collection = collection.split( '' );
                    }
                    while ( ++index < length ) {
                        result[ index ] = collection[ props[ index ] ];
                    }
                    return result;
                }
                /**
                 * Checks if a given value is present in a collection using strict equality
                 * for comparisons, i.e. `===`. If `fromIndex` is negative, it is used as the
                 * offset from the end of the collection.
                 *
                 * @static
                 * @memberOf _
                 * @alias include
                 * @category Collections
                 * @param {Array|Object|string} collection The collection to iterate over.
                 * @param {*} target The value to check for.
                 * @param {number} [fromIndex=0] The index to search from.
                 * @returns {boolean} Returns `true` if the `target` element is found, else `false`.
                 * @example
                 *
                 * _.contains([1, 2, 3], 1);
                 * // => true
                 *
                 * _.contains([1, 2, 3], 1, 2);
                 * // => false
                 *
                 * _.contains({ 'name': 'fred', 'age': 40 }, 'fred');
                 * // => true
                 *
                 * _.contains('pebbles', 'eb');
                 * // => true
                 */
            function contains( collection, target, fromIndex ) {
                    var index = -1,
                        indexOf = getIndexOf(),
                        length = collection ? collection.length : 0,
                        result = false;
                    fromIndex = ( fromIndex < 0 ? nativeMax( 0, length + fromIndex ) : fromIndex ) || 0;
                    if ( isArray( collection ) ) {
                        result = indexOf( collection, target, fromIndex ) > -1;
                    } else if ( typeof length == 'number' ) {
                        result = ( isString( collection ) ? collection.indexOf( target, fromIndex ) : indexOf( collection, target, fromIndex ) ) > -1;
                    } else {
                        baseEach( collection, function( value ) {
                            if ( ++index >= fromIndex ) {
                                return !( result = value === target );
                            }
                        } );
                    }
                    return result;
                }
                /**
                 * Creates an object composed of keys generated from the results of running
                 * each element of `collection` through the callback. The corresponding value
                 * of each key is the number of times the key was returned by the callback.
                 * The callback is bound to `thisArg` and invoked with three arguments;
                 * (value, index|key, collection).
                 *
                 * If a property name is provided for `callback` the created "_.pluck" style
                 * callback will return the property value of the given element.
                 *
                 * If an object is provided for `callback` the created "_.where" style callback
                 * will return `true` for elements that have the properties of the given object,
                 * else `false`.
                 *
                 * @static
                 * @memberOf _
                 * @category Collections
                 * @param {Array|Object|string} collection The collection to iterate over.
                 * @param {Function|Object|string} [callback=identity] The function called
                 *  per iteration. If a property name or object is provided it will be used
                 *  to create a "_.pluck" or "_.where" style callback, respectively.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {Object} Returns the composed aggregate object.
                 * @example
                 *
                 * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
                 * // => { '4': 1, '6': 2 }
                 *
                 * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
                 * // => { '4': 1, '6': 2 }
                 *
                 * _.countBy(['one', 'two', 'three'], 'length');
                 * // => { '3': 2, '5': 1 }
                 */
            var countBy = createAggregator( function( result, value, key ) {
                ( hasOwnProperty.call( result, key ) ? result[ key ] ++ : result[ key ] = 1 );
            } );
            /**
             * Checks if the given callback returns truey value for **all** elements of
             * a collection. The callback is bound to `thisArg` and invoked with three
             * arguments; (value, index|key, collection).
             *
             * If a property name is provided for `callback` the created "_.pluck" style
             * callback will return the property value of the given element.
             *
             * If an object is provided for `callback` the created "_.where" style callback
             * will return `true` for elements that have the properties of the given object,
             * else `false`.
             *
             * @static
             * @memberOf _
             * @alias all
             * @category Collections
             * @param {Array|Object|string} collection The collection to iterate over.
             * @param {Function|Object|string} [callback=identity] The function called
             *  per iteration. If a property name or object is provided it will be used
             *  to create a "_.pluck" or "_.where" style callback, respectively.
             * @param {*} [thisArg] The `this` binding of `callback`.
             * @returns {boolean} Returns `true` if all elements passed the callback check,
             *  else `false`.
             * @example
             *
             * _.every([true, 1, null, 'yes']);
             * // => false
             *
             * var characters = [
             *   { 'name': 'barney', 'age': 36 },
             *   { 'name': 'fred',   'age': 40 }
             * ];
             *
             * // using "_.pluck" callback shorthand
             * _.every(characters, 'age');
             * // => true
             *
             * // using "_.where" callback shorthand
             * _.every(characters, { 'age': 36 });
             * // => false
             */
            function every( collection, callback, thisArg ) {
                    var result = true;
                    callback = lodash.createCallback( callback, thisArg, 3 );
                    if ( isArray( collection ) ) {
                        var index = -1,
                            length = collection.length;
                        while ( ++index < length ) {
                            if ( !( result = !!callback( collection[ index ], index, collection ) ) ) {
                                break;
                            }
                        }
                    } else {
                        baseEach( collection, function( value, index, collection ) {
                            return ( result = !!callback( value, index, collection ) );
                        } );
                    }
                    return result;
                }
                /**
                 * Iterates over elements of a collection, returning an array of all elements
                 * the callback returns truey for. The callback is bound to `thisArg` and
                 * invoked with three arguments; (value, index|key, collection).
                 *
                 * If a property name is provided for `callback` the created "_.pluck" style
                 * callback will return the property value of the given element.
                 *
                 * If an object is provided for `callback` the created "_.where" style callback
                 * will return `true` for elements that have the properties of the given object,
                 * else `false`.
                 *
                 * @static
                 * @memberOf _
                 * @alias select
                 * @category Collections
                 * @param {Array|Object|string} collection The collection to iterate over.
                 * @param {Function|Object|string} [callback=identity] The function called
                 *  per iteration. If a property name or object is provided it will be used
                 *  to create a "_.pluck" or "_.where" style callback, respectively.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {Array} Returns a new array of elements that passed the callback check.
                 * @example
                 *
                 * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
                 * // => [2, 4, 6]
                 *
                 * var characters = [
                 *   { 'name': 'barney', 'age': 36, 'blocked': false },
                 *   { 'name': 'fred',   'age': 40, 'blocked': true }
                 * ];
                 *
                 * // using "_.pluck" callback shorthand
                 * _.filter(characters, 'blocked');
                 * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
                 *
                 * // using "_.where" callback shorthand
                 * _.filter(characters, { 'age': 36 });
                 * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
                 */
            function filter( collection, callback, thisArg ) {
                    var result = [];
                    callback = lodash.createCallback( callback, thisArg, 3 );
                    if ( isArray( collection ) ) {
                        var index = -1,
                            length = collection.length;
                        while ( ++index < length ) {
                            var value = collection[ index ];
                            if ( callback( value, index, collection ) ) {
                                result.push( value );
                            }
                        }
                    } else {
                        baseEach( collection, function( value, index, collection ) {
                            if ( callback( value, index, collection ) ) {
                                result.push( value );
                            }
                        } );
                    }
                    return result;
                }
                /**
                 * Iterates over elements of a collection, returning the first element that
                 * the callback returns truey for. The callback is bound to `thisArg` and
                 * invoked with three arguments; (value, index|key, collection).
                 *
                 * If a property name is provided for `callback` the created "_.pluck" style
                 * callback will return the property value of the given element.
                 *
                 * If an object is provided for `callback` the created "_.where" style callback
                 * will return `true` for elements that have the properties of the given object,
                 * else `false`.
                 *
                 * @static
                 * @memberOf _
                 * @alias detect, findWhere
                 * @category Collections
                 * @param {Array|Object|string} collection The collection to iterate over.
                 * @param {Function|Object|string} [callback=identity] The function called
                 *  per iteration. If a property name or object is provided it will be used
                 *  to create a "_.pluck" or "_.where" style callback, respectively.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {*} Returns the found element, else `undefined`.
                 * @example
                 *
                 * var characters = [
                 *   { 'name': 'barney',  'age': 36, 'blocked': false },
                 *   { 'name': 'fred',    'age': 40, 'blocked': true },
                 *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
                 * ];
                 *
                 * _.find(characters, function(chr) {
                 *   return chr.age < 40;
                 * });
                 * // => { 'name': 'barney', 'age': 36, 'blocked': false }
                 *
                 * // using "_.where" callback shorthand
                 * _.find(characters, { 'age': 1 });
                 * // =>  { 'name': 'pebbles', 'age': 1, 'blocked': false }
                 *
                 * // using "_.pluck" callback shorthand
                 * _.find(characters, 'blocked');
                 * // => { 'name': 'fred', 'age': 40, 'blocked': true }
                 */
            function find( collection, callback, thisArg ) {
                    callback = lodash.createCallback( callback, thisArg, 3 );
                    if ( isArray( collection ) ) {
                        var index = -1,
                            length = collection.length;
                        while ( ++index < length ) {
                            var value = collection[ index ];
                            if ( callback( value, index, collection ) ) {
                                return value;
                            }
                        }
                    } else {
                        var result;
                        baseEach( collection, function( value, index, collection ) {
                            if ( callback( value, index, collection ) ) {
                                result = value;
                                return false;
                            }
                        } );
                        return result;
                    }
                }
                /**
                 * This method is like `_.find` except that it iterates over elements
                 * of a `collection` from right to left.
                 *
                 * @static
                 * @memberOf _
                 * @category Collections
                 * @param {Array|Object|string} collection The collection to iterate over.
                 * @param {Function|Object|string} [callback=identity] The function called
                 *  per iteration. If a property name or object is provided it will be used
                 *  to create a "_.pluck" or "_.where" style callback, respectively.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {*} Returns the found element, else `undefined`.
                 * @example
                 *
                 * _.findLast([1, 2, 3, 4], function(num) {
                 *   return num % 2 == 1;
                 * });
                 * // => 3
                 */
            function findLast( collection, callback, thisArg ) {
                    var result;
                    callback = lodash.createCallback( callback, thisArg, 3 );
                    forEachRight( collection, function( value, index, collection ) {
                        if ( callback( value, index, collection ) ) {
                            result = value;
                            return false;
                        }
                    } );
                    return result;
                }
                /**
                 * Iterates over elements of a collection, executing the callback for each
                 * element. The callback is bound to `thisArg` and invoked with three arguments;
                 * (value, index|key, collection). Callbacks may exit iteration early by
                 * explicitly returning `false`.
                 *
                 * Note: As with other "Collections" methods, objects with a `length` property
                 * are iterated like arrays. To avoid this behavior `_.forIn` or `_.forOwn`
                 * may be used for object iteration.
                 *
                 * @static
                 * @memberOf _
                 * @alias each
                 * @category Collections
                 * @param {Array|Object|string} collection The collection to iterate over.
                 * @param {Function} [callback=identity] The function called per iteration.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {Array|Object|string} Returns `collection`.
                 * @example
                 *
                 * _([1, 2, 3]).forEach(function(num) { console.log(num); }).join(',');
                 * // => logs each number and returns '1,2,3'
                 *
                 * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { console.log(num); });
                 * // => logs each number and returns the object (property order is not guaranteed across environments)
                 */
            function forEach( collection, callback, thisArg ) {
                    if ( callback && typeof thisArg == 'undefined' && isArray( collection ) ) {
                        var index = -1,
                            length = collection.length;
                        while ( ++index < length ) {
                            if ( callback( collection[ index ], index, collection ) === false ) {
                                break;
                            }
                        }
                    } else {
                        baseEach( collection, callback, thisArg );
                    }
                    return collection;
                }
                /**
                 * This method is like `_.forEach` except that it iterates over elements
                 * of a `collection` from right to left.
                 *
                 * @static
                 * @memberOf _
                 * @alias eachRight
                 * @category Collections
                 * @param {Array|Object|string} collection The collection to iterate over.
                 * @param {Function} [callback=identity] The function called per iteration.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {Array|Object|string} Returns `collection`.
                 * @example
                 *
                 * _([1, 2, 3]).forEachRight(function(num) { console.log(num); }).join(',');
                 * // => logs each number from right to left and returns '3,2,1'
                 */
            function forEachRight( collection, callback, thisArg ) {
                    var iterable = collection,
                        length = collection ? collection.length : 0;
                    callback = callback && typeof thisArg == 'undefined' ? callback : baseCreateCallback( callback, thisArg, 3 );
                    if ( isArray( collection ) ) {
                        while ( length-- ) {
                            if ( callback( collection[ length ], length, collection ) === false ) {
                                break;
                            }
                        }
                    } else {
                        if ( typeof length != 'number' ) {
                            var props = keys( collection );
                            length = props.length;
                        } else if ( support.unindexedChars && isString( collection ) ) {
                            iterable = collection.split( '' );
                        }
                        baseEach( collection, function( value, key, collection ) {
                            key = props ? props[ --length ] : --length;
                            return callback( iterable[ key ], key, collection );
                        } );
                    }
                    return collection;
                }
                /**
                 * Creates an object composed of keys generated from the results of running
                 * each element of a collection through the callback. The corresponding value
                 * of each key is an array of the elements responsible for generating the key.
                 * The callback is bound to `thisArg` and invoked with three arguments;
                 * (value, index|key, collection).
                 *
                 * If a property name is provided for `callback` the created "_.pluck" style
                 * callback will return the property value of the given element.
                 *
                 * If an object is provided for `callback` the created "_.where" style callback
                 * will return `true` for elements that have the properties of the given object,
                 * else `false`
                 *
                 * @static
                 * @memberOf _
                 * @category Collections
                 * @param {Array|Object|string} collection The collection to iterate over.
                 * @param {Function|Object|string} [callback=identity] The function called
                 *  per iteration. If a property name or object is provided it will be used
                 *  to create a "_.pluck" or "_.where" style callback, respectively.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {Object} Returns the composed aggregate object.
                 * @example
                 *
                 * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
                 * // => { '4': [4.2], '6': [6.1, 6.4] }
                 *
                 * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
                 * // => { '4': [4.2], '6': [6.1, 6.4] }
                 *
                 * // using "_.pluck" callback shorthand
                 * _.groupBy(['one', 'two', 'three'], 'length');
                 * // => { '3': ['one', 'two'], '5': ['three'] }
                 */
            var groupBy = createAggregator( function( result, value, key ) {
                ( hasOwnProperty.call( result, key ) ? result[ key ] : result[ key ] = [] ).push( value );
            } );
            /**
             * Creates an object composed of keys generated from the results of running
             * each element of the collection through the given callback. The corresponding
             * value of each key is the last element responsible for generating the key.
             * The callback is bound to `thisArg` and invoked with three arguments;
             * (value, index|key, collection).
             *
             * If a property name is provided for `callback` the created "_.pluck" style
             * callback will return the property value of the given element.
             *
             * If an object is provided for `callback` the created "_.where" style callback
             * will return `true` for elements that have the properties of the given object,
             * else `false`.
             *
             * @static
             * @memberOf _
             * @category Collections
             * @param {Array|Object|string} collection The collection to iterate over.
             * @param {Function|Object|string} [callback=identity] The function called
             *  per iteration. If a property name or object is provided it will be used
             *  to create a "_.pluck" or "_.where" style callback, respectively.
             * @param {*} [thisArg] The `this` binding of `callback`.
             * @returns {Object} Returns the composed aggregate object.
             * @example
             *
             * var keys = [
             *   { 'dir': 'left', 'code': 97 },
             *   { 'dir': 'right', 'code': 100 }
             * ];
             *
             * _.indexBy(keys, 'dir');
             * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
             *
             * _.indexBy(keys, function(key) { return String.fromCharCode(key.code); });
             * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
             *
             * _.indexBy(characters, function(key) { this.fromCharCode(key.code); }, String);
             * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
             */
            var indexBy = createAggregator( function( result, value, key ) {
                result[ key ] = value;
            } );
            /**
             * Invokes the method named by `methodName` on each element in the `collection`
             * returning an array of the results of each invoked method. Additional arguments
             * will be provided to each invoked method. If `methodName` is a function it
             * will be invoked for, and `this` bound to, each element in the `collection`.
             *
             * @static
             * @memberOf _
             * @category Collections
             * @param {Array|Object|string} collection The collection to iterate over.
             * @param {Function|string} methodName The name of the method to invoke or
             *  the function invoked per iteration.
             * @param {...*} [arg] Arguments to invoke the method with.
             * @returns {Array} Returns a new array of the results of each invoked method.
             * @example
             *
             * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
             * // => [[1, 5, 7], [1, 2, 3]]
             *
             * _.invoke([123, 456], String.prototype.split, '');
             * // => [['1', '2', '3'], ['4', '5', '6']]
             */
            function invoke( collection, methodName ) {
                    var args = slice( arguments, 2 ),
                        index = -1,
                        isFunc = typeof methodName == 'function',
                        length = collection ? collection.length : 0,
                        result = Array( typeof length == 'number' ? length : 0 );
                    forEach( collection, function( value ) {
                        result[ ++index ] = ( isFunc ? methodName : value[ methodName ] ).apply( value, args );
                    } );
                    return result;
                }
                /**
                 * Creates an array of values by running each element in the collection
                 * through the callback. The callback is bound to `thisArg` and invoked with
                 * three arguments; (value, index|key, collection).
                 *
                 * If a property name is provided for `callback` the created "_.pluck" style
                 * callback will return the property value of the given element.
                 *
                 * If an object is provided for `callback` the created "_.where" style callback
                 * will return `true` for elements that have the properties of the given object,
                 * else `false`.
                 *
                 * @static
                 * @memberOf _
                 * @alias collect
                 * @category Collections
                 * @param {Array|Object|string} collection The collection to iterate over.
                 * @param {Function|Object|string} [callback=identity] The function called
                 *  per iteration. If a property name or object is provided it will be used
                 *  to create a "_.pluck" or "_.where" style callback, respectively.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {Array} Returns a new array of the results of each `callback` execution.
                 * @example
                 *
                 * _.map([1, 2, 3], function(num) { return num * 3; });
                 * // => [3, 6, 9]
                 *
                 * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
                 * // => [3, 6, 9] (property order is not guaranteed across environments)
                 *
                 * var characters = [
                 *   { 'name': 'barney', 'age': 36 },
                 *   { 'name': 'fred',   'age': 40 }
                 * ];
                 *
                 * // using "_.pluck" callback shorthand
                 * _.map(characters, 'name');
                 * // => ['barney', 'fred']
                 */
            function map( collection, callback, thisArg ) {
                    var index = -1,
                        length = collection ? collection.length : 0,
                        result = Array( typeof length == 'number' ? length : 0 );
                    callback = lodash.createCallback( callback, thisArg, 3 );
                    if ( isArray( collection ) ) {
                        while ( ++index < length ) {
                            result[ index ] = callback( collection[ index ], index, collection );
                        }
                    } else {
                        baseEach( collection, function( value, key, collection ) {
                            result[ ++index ] = callback( value, key, collection );
                        } );
                    }
                    return result;
                }
                /**
                 * Retrieves the maximum value of a collection. If the collection is empty or
                 * falsey `-Infinity` is returned. If a callback is provided it will be executed
                 * for each value in the collection to generate the criterion by which the value
                 * is ranked. The callback is bound to `thisArg` and invoked with three
                 * arguments; (value, index, collection).
                 *
                 * If a property name is provided for `callback` the created "_.pluck" style
                 * callback will return the property value of the given element.
                 *
                 * If an object is provided for `callback` the created "_.where" style callback
                 * will return `true` for elements that have the properties of the given object,
                 * else `false`.
                 *
                 * @static
                 * @memberOf _
                 * @category Collections
                 * @param {Array|Object|string} collection The collection to iterate over.
                 * @param {Function|Object|string} [callback=identity] The function called
                 *  per iteration. If a property name or object is provided it will be used
                 *  to create a "_.pluck" or "_.where" style callback, respectively.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {*} Returns the maximum value.
                 * @example
                 *
                 * _.max([4, 2, 8, 6]);
                 * // => 8
                 *
                 * var characters = [
                 *   { 'name': 'barney', 'age': 36 },
                 *   { 'name': 'fred',   'age': 40 }
                 * ];
                 *
                 * _.max(characters, function(chr) { return chr.age; });
                 * // => { 'name': 'fred', 'age': 40 };
                 *
                 * // using "_.pluck" callback shorthand
                 * _.max(characters, 'age');
                 * // => { 'name': 'fred', 'age': 40 };
                 */
            function max( collection, callback, thisArg ) {
                    var computed = -Infinity,
                        result = computed;
                    // allows working with functions like `_.map` without using
                    // their `index` argument as a callback
                    if ( typeof callback != 'function' && thisArg && thisArg[ callback ] === collection ) {
                        callback = null;
                    }
                    if ( callback == null && isArray( collection ) ) {
                        var index = -1,
                            length = collection.length;
                        while ( ++index < length ) {
                            var value = collection[ index ];
                            if ( value > result ) {
                                result = value;
                            }
                        }
                    } else {
                        callback = ( callback == null && isString( collection ) ) ? charAtCallback : lodash.createCallback( callback, thisArg, 3 );
                        baseEach( collection, function( value, index, collection ) {
                            var current = callback( value, index, collection );
                            if ( current > computed ) {
                                computed = current;
                                result = value;
                            }
                        } );
                    }
                    return result;
                }
                /**
                 * Retrieves the minimum value of a collection. If the collection is empty or
                 * falsey `Infinity` is returned. If a callback is provided it will be executed
                 * for each value in the collection to generate the criterion by which the value
                 * is ranked. The callback is bound to `thisArg` and invoked with three
                 * arguments; (value, index, collection).
                 *
                 * If a property name is provided for `callback` the created "_.pluck" style
                 * callback will return the property value of the given element.
                 *
                 * If an object is provided for `callback` the created "_.where" style callback
                 * will return `true` for elements that have the properties of the given object,
                 * else `false`.
                 *
                 * @static
                 * @memberOf _
                 * @category Collections
                 * @param {Array|Object|string} collection The collection to iterate over.
                 * @param {Function|Object|string} [callback=identity] The function called
                 *  per iteration. If a property name or object is provided it will be used
                 *  to create a "_.pluck" or "_.where" style callback, respectively.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {*} Returns the minimum value.
                 * @example
                 *
                 * _.min([4, 2, 8, 6]);
                 * // => 2
                 *
                 * var characters = [
                 *   { 'name': 'barney', 'age': 36 },
                 *   { 'name': 'fred',   'age': 40 }
                 * ];
                 *
                 * _.min(characters, function(chr) { return chr.age; });
                 * // => { 'name': 'barney', 'age': 36 };
                 *
                 * // using "_.pluck" callback shorthand
                 * _.min(characters, 'age');
                 * // => { 'name': 'barney', 'age': 36 };
                 */
            function min( collection, callback, thisArg ) {
                    var computed = Infinity,
                        result = computed;
                    // allows working with functions like `_.map` without using
                    // their `index` argument as a callback
                    if ( typeof callback != 'function' && thisArg && thisArg[ callback ] === collection ) {
                        callback = null;
                    }
                    if ( callback == null && isArray( collection ) ) {
                        var index = -1,
                            length = collection.length;
                        while ( ++index < length ) {
                            var value = collection[ index ];
                            if ( value < result ) {
                                result = value;
                            }
                        }
                    } else {
                        callback = ( callback == null && isString( collection ) ) ? charAtCallback : lodash.createCallback( callback, thisArg, 3 );
                        baseEach( collection, function( value, index, collection ) {
                            var current = callback( value, index, collection );
                            if ( current < computed ) {
                                computed = current;
                                result = value;
                            }
                        } );
                    }
                    return result;
                }
                /**
                 * Retrieves the value of a specified property from all elements in the collection.
                 *
                 * @static
                 * @memberOf _
                 * @type Function
                 * @category Collections
                 * @param {Array|Object|string} collection The collection to iterate over.
                 * @param {string} property The name of the property to pluck.
                 * @returns {Array} Returns a new array of property values.
                 * @example
                 *
                 * var characters = [
                 *   { 'name': 'barney', 'age': 36 },
                 *   { 'name': 'fred',   'age': 40 }
                 * ];
                 *
                 * _.pluck(characters, 'name');
                 * // => ['barney', 'fred']
                 */
            var pluck = map;
            /**
             * Reduces a collection to a value which is the accumulated result of running
             * each element in the collection through the callback, where each successive
             * callback execution consumes the return value of the previous execution. If
             * `accumulator` is not provided the first element of the collection will be
             * used as the initial `accumulator` value. The callback is bound to `thisArg`
             * and invoked with four arguments; (accumulator, value, index|key, collection).
             *
             * @static
             * @memberOf _
             * @alias foldl, inject
             * @category Collections
             * @param {Array|Object|string} collection The collection to iterate over.
             * @param {Function} [callback=identity] The function called per iteration.
             * @param {*} [accumulator] Initial value of the accumulator.
             * @param {*} [thisArg] The `this` binding of `callback`.
             * @returns {*} Returns the accumulated value.
             * @example
             *
             * var sum = _.reduce([1, 2, 3], function(sum, num) {
             *   return sum + num;
             * });
             * // => 6
             *
             * var mapped = _.reduce({ 'a': 1, 'b': 2, 'c': 3 }, function(result, num, key) {
             *   result[key] = num * 3;
             *   return result;
             * }, {});
             * // => { 'a': 3, 'b': 6, 'c': 9 }
             */
            function reduce( collection, callback, accumulator, thisArg ) {
                    var noaccum = arguments.length < 3;
                    callback = lodash.createCallback( callback, thisArg, 4 );
                    if ( isArray( collection ) ) {
                        var index = -1,
                            length = collection.length;
                        if ( noaccum ) {
                            accumulator = collection[ ++index ];
                        }
                        while ( ++index < length ) {
                            accumulator = callback( accumulator, collection[ index ], index, collection );
                        }
                    } else {
                        baseEach( collection, function( value, index, collection ) {
                            accumulator = noaccum ? ( noaccum = false, value ) : callback( accumulator, value, index, collection )
                        } );
                    }
                    return accumulator;
                }
                /**
                 * This method is like `_.reduce` except that it iterates over elements
                 * of a `collection` from right to left.
                 *
                 * @static
                 * @memberOf _
                 * @alias foldr
                 * @category Collections
                 * @param {Array|Object|string} collection The collection to iterate over.
                 * @param {Function} [callback=identity] The function called per iteration.
                 * @param {*} [accumulator] Initial value of the accumulator.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {*} Returns the accumulated value.
                 * @example
                 *
                 * var list = [[0, 1], [2, 3], [4, 5]];
                 * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
                 * // => [4, 5, 2, 3, 0, 1]
                 */
            function reduceRight( collection, callback, accumulator, thisArg ) {
                    var noaccum = arguments.length < 3;
                    callback = lodash.createCallback( callback, thisArg, 4 );
                    forEachRight( collection, function( value, index, collection ) {
                        accumulator = noaccum ? ( noaccum = false, value ) : callback( accumulator, value, index, collection );
                    } );
                    return accumulator;
                }
                /**
                 * The opposite of `_.filter` this method returns the elements of a
                 * collection that the callback does **not** return truey for.
                 *
                 * If a property name is provided for `callback` the created "_.pluck" style
                 * callback will return the property value of the given element.
                 *
                 * If an object is provided for `callback` the created "_.where" style callback
                 * will return `true` for elements that have the properties of the given object,
                 * else `false`.
                 *
                 * @static
                 * @memberOf _
                 * @category Collections
                 * @param {Array|Object|string} collection The collection to iterate over.
                 * @param {Function|Object|string} [callback=identity] The function called
                 *  per iteration. If a property name or object is provided it will be used
                 *  to create a "_.pluck" or "_.where" style callback, respectively.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {Array} Returns a new array of elements that failed the callback check.
                 * @example
                 *
                 * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
                 * // => [1, 3, 5]
                 *
                 * var characters = [
                 *   { 'name': 'barney', 'age': 36, 'blocked': false },
                 *   { 'name': 'fred',   'age': 40, 'blocked': true }
                 * ];
                 *
                 * // using "_.pluck" callback shorthand
                 * _.reject(characters, 'blocked');
                 * // => [{ 'name': 'barney', 'age': 36, 'blocked': false }]
                 *
                 * // using "_.where" callback shorthand
                 * _.reject(characters, { 'age': 36 });
                 * // => [{ 'name': 'fred', 'age': 40, 'blocked': true }]
                 */
            function reject( collection, callback, thisArg ) {
                    callback = lodash.createCallback( callback, thisArg, 3 );
                    return filter( collection, function( value, index, collection ) {
                        return !callback( value, index, collection );
                    } );
                }
                /**
                 * Retrieves a random element or `n` random elements from a collection.
                 *
                 * @static
                 * @memberOf _
                 * @category Collections
                 * @param {Array|Object|string} collection The collection to sample.
                 * @param {number} [n] The number of elements to sample.
                 * @param- {Object} [guard] Allows working with functions like `_.map`
                 *  without using their `index` arguments as `n`.
                 * @returns {Array} Returns the random sample(s) of `collection`.
                 * @example
                 *
                 * _.sample([1, 2, 3, 4]);
                 * // => 2
                 *
                 * _.sample([1, 2, 3, 4], 2);
                 * // => [3, 1]
                 */
            function sample( collection, n, guard ) {
                    if ( collection && typeof collection.length != 'number' ) {
                        collection = values( collection );
                    } else if ( support.unindexedChars && isString( collection ) ) {
                        collection = collection.split( '' );
                    }
                    if ( n == null || guard ) {
                        return collection ? collection[ baseRandom( 0, collection.length - 1 ) ] : undefined;
                    }
                    var result = shuffle( collection );
                    result.length = nativeMin( nativeMax( 0, n ), result.length );
                    return result;
                }
                /**
                 * Creates an array of shuffled values, using a version of the Fisher-Yates
                 * shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
                 *
                 * @static
                 * @memberOf _
                 * @category Collections
                 * @param {Array|Object|string} collection The collection to shuffle.
                 * @returns {Array} Returns a new shuffled collection.
                 * @example
                 *
                 * _.shuffle([1, 2, 3, 4, 5, 6]);
                 * // => [4, 1, 6, 3, 5, 2]
                 */
            function shuffle( collection ) {
                    var index = -1,
                        length = collection ? collection.length : 0,
                        result = Array( typeof length == 'number' ? length : 0 );
                    forEach( collection, function( value ) {
                        var rand = baseRandom( 0, ++index );
                        result[ index ] = result[ rand ];
                        result[ rand ] = value;
                    } );
                    return result;
                }
                /**
                 * Gets the size of the `collection` by returning `collection.length` for arrays
                 * and array-like objects or the number of own enumerable properties for objects.
                 *
                 * @static
                 * @memberOf _
                 * @category Collections
                 * @param {Array|Object|string} collection The collection to inspect.
                 * @returns {number} Returns `collection.length` or number of own enumerable properties.
                 * @example
                 *
                 * _.size([1, 2]);
                 * // => 2
                 *
                 * _.size({ 'one': 1, 'two': 2, 'three': 3 });
                 * // => 3
                 *
                 * _.size('pebbles');
                 * // => 7
                 */
            function size( collection ) {
                    var length = collection ? collection.length : 0;
                    return typeof length == 'number' ? length : keys( collection ).length;
                }
                /**
                 * Checks if the callback returns a truey value for **any** element of a
                 * collection. The function returns as soon as it finds a passing value and
                 * does not iterate over the entire collection. The callback is bound to
                 * `thisArg` and invoked with three arguments; (value, index|key, collection).
                 *
                 * If a property name is provided for `callback` the created "_.pluck" style
                 * callback will return the property value of the given element.
                 *
                 * If an object is provided for `callback` the created "_.where" style callback
                 * will return `true` for elements that have the properties of the given object,
                 * else `false`.
                 *
                 * @static
                 * @memberOf _
                 * @alias any
                 * @category Collections
                 * @param {Array|Object|string} collection The collection to iterate over.
                 * @param {Function|Object|string} [callback=identity] The function called
                 *  per iteration. If a property name or object is provided it will be used
                 *  to create a "_.pluck" or "_.where" style callback, respectively.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {boolean} Returns `true` if any element passed the callback check,
                 *  else `false`.
                 * @example
                 *
                 * _.some([null, 0, 'yes', false], Boolean);
                 * // => true
                 *
                 * var characters = [
                 *   { 'name': 'barney', 'age': 36, 'blocked': false },
                 *   { 'name': 'fred',   'age': 40, 'blocked': true }
                 * ];
                 *
                 * // using "_.pluck" callback shorthand
                 * _.some(characters, 'blocked');
                 * // => true
                 *
                 * // using "_.where" callback shorthand
                 * _.some(characters, { 'age': 1 });
                 * // => false
                 */
            function some( collection, callback, thisArg ) {
                    var result;
                    callback = lodash.createCallback( callback, thisArg, 3 );
                    if ( isArray( collection ) ) {
                        var index = -1,
                            length = collection.length;
                        while ( ++index < length ) {
                            if ( ( result = callback( collection[ index ], index, collection ) ) ) {
                                break;
                            }
                        }
                    } else {
                        baseEach( collection, function( value, index, collection ) {
                            return !( result = callback( value, index, collection ) );
                        } );
                    }
                    return !!result;
                }
                /**
                 * Creates an array of elements, sorted in ascending order by the results of
                 * running each element in a collection through the callback. This method
                 * performs a stable sort, that is, it will preserve the original sort order
                 * of equal elements. The callback is bound to `thisArg` and invoked with
                 * three arguments; (value, index|key, collection).
                 *
                 * If a property name is provided for `callback` the created "_.pluck" style
                 * callback will return the property value of the given element.
                 *
                 * If an array of property names is provided for `callback` the collection
                 * will be sorted by each property value.
                 *
                 * If an object is provided for `callback` the created "_.where" style callback
                 * will return `true` for elements that have the properties of the given object,
                 * else `false`.
                 *
                 * @static
                 * @memberOf _
                 * @category Collections
                 * @param {Array|Object|string} collection The collection to iterate over.
                 * @param {Array|Function|Object|string} [callback=identity] The function called
                 *  per iteration. If a property name or object is provided it will be used
                 *  to create a "_.pluck" or "_.where" style callback, respectively.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {Array} Returns a new array of sorted elements.
                 * @example
                 *
                 * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
                 * // => [3, 1, 2]
                 *
                 * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
                 * // => [3, 1, 2]
                 *
                 * var characters = [
                 *   { 'name': 'barney',  'age': 36 },
                 *   { 'name': 'fred',    'age': 40 },
                 *   { 'name': 'barney',  'age': 26 },
                 *   { 'name': 'fred',    'age': 30 }
                 * ];
                 *
                 * // using "_.pluck" callback shorthand
                 * _.map(_.sortBy(characters, 'age'), _.values);
                 * // => [['barney', 26], ['fred', 30], ['barney', 36], ['fred', 40]]
                 *
                 * // sorting by multiple properties
                 * _.map(_.sortBy(characters, ['name', 'age']), _.values);
                 * // = > [['barney', 26], ['barney', 36], ['fred', 30], ['fred', 40]]
                 */
            function sortBy( collection, callback, thisArg ) {
                    var index = -1,
                        isArr = isArray( callback ),
                        length = collection ? collection.length : 0,
                        result = Array( typeof length == 'number' ? length : 0 );
                    if ( !isArr ) {
                        callback = lodash.createCallback( callback, thisArg, 3 );
                    }
                    forEach( collection, function( value, key, collection ) {
                        var object = result[ ++index ] = getObject();
                        if ( isArr ) {
                            object.criteria = map( callback, function( key ) {
                                return value[ key ];
                            } );
                        } else {
                            ( object.criteria = getArray() )[ 0 ] = callback( value, key, collection );
                        }
                        object.index = index;
                        object.value = value;
                    } );
                    length = result.length;
                    result.sort( compareAscending );
                    while ( length-- ) {
                        var object = result[ length ];
                        result[ length ] = object.value;
                        if ( !isArr ) {
                            releaseArray( object.criteria );
                        }
                        releaseObject( object );
                    }
                    return result;
                }
                /**
                 * Converts the `collection` to an array.
                 *
                 * @static
                 * @memberOf _
                 * @category Collections
                 * @param {Array|Object|string} collection The collection to convert.
                 * @returns {Array} Returns the new converted array.
                 * @example
                 *
                 * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
                 * // => [2, 3, 4]
                 */
            function toArray( collection ) {
                    if ( collection && typeof collection.length == 'number' ) {
                        return ( support.unindexedChars && isString( collection ) ) ? collection.split( '' ) : slice( collection );
                    }
                    return values( collection );
                }
                /**
                 * Performs a deep comparison of each element in a `collection` to the given
                 * `properties` object, returning an array of all elements that have equivalent
                 * property values.
                 *
                 * @static
                 * @memberOf _
                 * @type Function
                 * @category Collections
                 * @param {Array|Object|string} collection The collection to iterate over.
                 * @param {Object} props The object of property values to filter by.
                 * @returns {Array} Returns a new array of elements that have the given properties.
                 * @example
                 *
                 * var characters = [
                 *   { 'name': 'barney', 'age': 36, 'pets': ['hoppy'] },
                 *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
                 * ];
                 *
                 * _.where(characters, { 'age': 36 });
                 * // => [{ 'name': 'barney', 'age': 36, 'pets': ['hoppy'] }]
                 *
                 * _.where(characters, { 'pets': ['dino'] });
                 * // => [{ 'name': 'fred', 'age': 40, 'pets': ['baby puss', 'dino'] }]
                 */
            var where = filter;
            /*--------------------------------------------------------------------------*/
            /**
             * Creates an array with all falsey values removed. The values `false`, `null`,
             * `0`, `""`, `undefined`, and `NaN` are all falsey.
             *
             * @static
             * @memberOf _
             * @category Arrays
             * @param {Array} array The array to compact.
             * @returns {Array} Returns a new array of filtered values.
             * @example
             *
             * _.compact([0, 1, false, 2, '', 3]);
             * // => [1, 2, 3]
             */
            function compact( array ) {
                    var index = -1,
                        length = array ? array.length : 0,
                        result = [];
                    while ( ++index < length ) {
                        var value = array[ index ];
                        if ( value ) {
                            result.push( value );
                        }
                    }
                    return result;
                }
                /**
                 * Creates an array excluding all values of the provided arrays using strict
                 * equality for comparisons, i.e. `===`.
                 *
                 * @static
                 * @memberOf _
                 * @category Arrays
                 * @param {Array} array The array to process.
                 * @param {...Array} [values] The arrays of values to exclude.
                 * @returns {Array} Returns a new array of filtered values.
                 * @example
                 *
                 * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
                 * // => [1, 3, 4]
                 */
            function difference( array ) {
                    return baseDifference( array, baseFlatten( arguments, true, true, 1 ) );
                }
                /**
                 * This method is like `_.find` except that it returns the index of the first
                 * element that passes the callback check, instead of the element itself.
                 *
                 * If a property name is provided for `callback` the created "_.pluck" style
                 * callback will return the property value of the given element.
                 *
                 * If an object is provided for `callback` the created "_.where" style callback
                 * will return `true` for elements that have the properties of the given object,
                 * else `false`.
                 *
                 * @static
                 * @memberOf _
                 * @category Arrays
                 * @param {Array} array The array to search.
                 * @param {Function|Object|string} [callback=identity] The function called
                 *  per iteration. If a property name or object is provided it will be used
                 *  to create a "_.pluck" or "_.where" style callback, respectively.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {number} Returns the index of the found element, else `-1`.
                 * @example
                 *
                 * var characters = [
                 *   { 'name': 'barney',  'age': 36, 'blocked': false },
                 *   { 'name': 'fred',    'age': 40, 'blocked': true },
                 *   { 'name': 'pebbles', 'age': 1,  'blocked': false }
                 * ];
                 *
                 * _.findIndex(characters, function(chr) {
                 *   return chr.age < 20;
                 * });
                 * // => 2
                 *
                 * // using "_.where" callback shorthand
                 * _.findIndex(characters, { 'age': 36 });
                 * // => 0
                 *
                 * // using "_.pluck" callback shorthand
                 * _.findIndex(characters, 'blocked');
                 * // => 1
                 */
            function findIndex( array, callback, thisArg ) {
                    var index = -1,
                        length = array ? array.length : 0;
                    callback = lodash.createCallback( callback, thisArg, 3 );
                    while ( ++index < length ) {
                        if ( callback( array[ index ], index, array ) ) {
                            return index;
                        }
                    }
                    return -1;
                }
                /**
                 * This method is like `_.findIndex` except that it iterates over elements
                 * of a `collection` from right to left.
                 *
                 * If a property name is provided for `callback` the created "_.pluck" style
                 * callback will return the property value of the given element.
                 *
                 * If an object is provided for `callback` the created "_.where" style callback
                 * will return `true` for elements that have the properties of the given object,
                 * else `false`.
                 *
                 * @static
                 * @memberOf _
                 * @category Arrays
                 * @param {Array} array The array to search.
                 * @param {Function|Object|string} [callback=identity] The function called
                 *  per iteration. If a property name or object is provided it will be used
                 *  to create a "_.pluck" or "_.where" style callback, respectively.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {number} Returns the index of the found element, else `-1`.
                 * @example
                 *
                 * var characters = [
                 *   { 'name': 'barney',  'age': 36, 'blocked': true },
                 *   { 'name': 'fred',    'age': 40, 'blocked': false },
                 *   { 'name': 'pebbles', 'age': 1,  'blocked': true }
                 * ];
                 *
                 * _.findLastIndex(characters, function(chr) {
                 *   return chr.age > 30;
                 * });
                 * // => 1
                 *
                 * // using "_.where" callback shorthand
                 * _.findLastIndex(characters, { 'age': 36 });
                 * // => 0
                 *
                 * // using "_.pluck" callback shorthand
                 * _.findLastIndex(characters, 'blocked');
                 * // => 2
                 */
            function findLastIndex( array, callback, thisArg ) {
                    var length = array ? array.length : 0;
                    callback = lodash.createCallback( callback, thisArg, 3 );
                    while ( length-- ) {
                        if ( callback( array[ length ], length, array ) ) {
                            return length;
                        }
                    }
                    return -1;
                }
                /**
                 * Gets the first element or first `n` elements of an array. If a callback
                 * is provided elements at the beginning of the array are returned as long
                 * as the callback returns truey. The callback is bound to `thisArg` and
                 * invoked with three arguments; (value, index, array).
                 *
                 * If a property name is provided for `callback` the created "_.pluck" style
                 * callback will return the property value of the given element.
                 *
                 * If an object is provided for `callback` the created "_.where" style callback
                 * will return `true` for elements that have the properties of the given object,
                 * else `false`.
                 *
                 * @static
                 * @memberOf _
                 * @alias head, take
                 * @category Arrays
                 * @param {Array} array The array to query.
                 * @param {Function|Object|number|string} [callback] The function called
                 *  per element or the number of elements to return. If a property name or
                 *  object is provided it will be used to create a "_.pluck" or "_.where"
                 *  style callback, respectively.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {*} Returns the first element(s) of `array`.
                 * @example
                 *
                 * _.first([1, 2, 3]);
                 * // => 1
                 *
                 * _.first([1, 2, 3], 2);
                 * // => [1, 2]
                 *
                 * _.first([1, 2, 3], function(num) {
                 *   return num < 3;
                 * });
                 * // => [1, 2]
                 *
                 * var characters = [
                 *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
                 *   { 'name': 'fred',    'blocked': false, 'employer': 'slate' },
                 *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
                 * ];
                 *
                 * // using "_.pluck" callback shorthand
                 * _.first(characters, 'blocked');
                 * // => [{ 'name': 'barney', 'blocked': true, 'employer': 'slate' }]
                 *
                 * // using "_.where" callback shorthand
                 * _.pluck(_.first(characters, { 'employer': 'slate' }), 'name');
                 * // => ['barney', 'fred']
                 */
            function first( array, callback, thisArg ) {
                    var n = 0,
                        length = array ? array.length : 0;
                    if ( typeof callback != 'number' && callback != null ) {
                        var index = -1;
                        callback = lodash.createCallback( callback, thisArg, 3 );
                        while ( ++index < length && callback( array[ index ], index, array ) ) {
                            n++;
                        }
                    } else {
                        n = callback;
                        if ( n == null || thisArg ) {
                            return array ? array[ 0 ] : undefined;
                        }
                    }
                    return slice( array, 0, nativeMin( nativeMax( 0, n ), length ) );
                }
                /**
                 * Flattens a nested array (the nesting can be to any depth). If `isShallow`
                 * is truey, the array will only be flattened a single level. If a callback
                 * is provided each element of the array is passed through the callback before
                 * flattening. The callback is bound to `thisArg` and invoked with three
                 * arguments; (value, index, array).
                 *
                 * If a property name is provided for `callback` the created "_.pluck" style
                 * callback will return the property value of the given element.
                 *
                 * If an object is provided for `callback` the created "_.where" style callback
                 * will return `true` for elements that have the properties of the given object,
                 * else `false`.
                 *
                 * @static
                 * @memberOf _
                 * @category Arrays
                 * @param {Array} array The array to flatten.
                 * @param {boolean} [isShallow=false] A flag to restrict flattening to a single level.
                 * @param {Function|Object|string} [callback=identity] The function called
                 *  per iteration. If a property name or object is provided it will be used
                 *  to create a "_.pluck" or "_.where" style callback, respectively.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {Array} Returns a new flattened array.
                 * @example
                 *
                 * _.flatten([1, [2], [3, [[4]]]]);
                 * // => [1, 2, 3, 4];
                 *
                 * _.flatten([1, [2], [3, [[4]]]], true);
                 * // => [1, 2, 3, [[4]]];
                 *
                 * var characters = [
                 *   { 'name': 'barney', 'age': 30, 'pets': ['hoppy'] },
                 *   { 'name': 'fred',   'age': 40, 'pets': ['baby puss', 'dino'] }
                 * ];
                 *
                 * // using "_.pluck" callback shorthand
                 * _.flatten(characters, 'pets');
                 * // => ['hoppy', 'baby puss', 'dino']
                 */
            function flatten( array, isShallow, callback, thisArg ) {
                    // juggle arguments
                    if ( typeof isShallow != 'boolean' && isShallow != null ) {
                        thisArg = callback;
                        callback = ( typeof isShallow != 'function' && thisArg && thisArg[ isShallow ] === array ) ? null : isShallow;
                        isShallow = false;
                    }
                    if ( callback != null ) {
                        array = map( array, callback, thisArg );
                    }
                    return baseFlatten( array, isShallow );
                }
                /**
                 * Gets the index at which the first occurrence of `value` is found using
                 * strict equality for comparisons, i.e. `===`. If the array is already sorted
                 * providing `true` for `fromIndex` will run a faster binary search.
                 *
                 * @static
                 * @memberOf _
                 * @category Arrays
                 * @param {Array} array The array to search.
                 * @param {*} value The value to search for.
                 * @param {boolean|number} [fromIndex=0] The index to search from or `true`
                 *  to perform a binary search on a sorted array.
                 * @returns {number} Returns the index of the matched value or `-1`.
                 * @example
                 *
                 * _.indexOf([1, 2, 3, 1, 2, 3], 2);
                 * // => 1
                 *
                 * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
                 * // => 4
                 *
                 * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
                 * // => 2
                 */
            function indexOf( array, value, fromIndex ) {
                    if ( typeof fromIndex == 'number' ) {
                        var length = array ? array.length : 0;
                        fromIndex = ( fromIndex < 0 ? nativeMax( 0, length + fromIndex ) : fromIndex || 0 );
                    } else if ( fromIndex ) {
                        var index = sortedIndex( array, value );
                        return array[ index ] === value ? index : -1;
                    }
                    return baseIndexOf( array, value, fromIndex );
                }
                /**
                 * Gets all but the last element or last `n` elements of an array. If a
                 * callback is provided elements at the end of the array are excluded from
                 * the result as long as the callback returns truey. The callback is bound
                 * to `thisArg` and invoked with three arguments; (value, index, array).
                 *
                 * If a property name is provided for `callback` the created "_.pluck" style
                 * callback will return the property value of the given element.
                 *
                 * If an object is provided for `callback` the created "_.where" style callback
                 * will return `true` for elements that have the properties of the given object,
                 * else `false`.
                 *
                 * @static
                 * @memberOf _
                 * @category Arrays
                 * @param {Array} array The array to query.
                 * @param {Function|Object|number|string} [callback=1] The function called
                 *  per element or the number of elements to exclude. If a property name or
                 *  object is provided it will be used to create a "_.pluck" or "_.where"
                 *  style callback, respectively.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {Array} Returns a slice of `array`.
                 * @example
                 *
                 * _.initial([1, 2, 3]);
                 * // => [1, 2]
                 *
                 * _.initial([1, 2, 3], 2);
                 * // => [1]
                 *
                 * _.initial([1, 2, 3], function(num) {
                 *   return num > 1;
                 * });
                 * // => [1]
                 *
                 * var characters = [
                 *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
                 *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
                 *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
                 * ];
                 *
                 * // using "_.pluck" callback shorthand
                 * _.initial(characters, 'blocked');
                 * // => [{ 'name': 'barney',  'blocked': false, 'employer': 'slate' }]
                 *
                 * // using "_.where" callback shorthand
                 * _.pluck(_.initial(characters, { 'employer': 'na' }), 'name');
                 * // => ['barney', 'fred']
                 */
            function initial( array, callback, thisArg ) {
                    var n = 0,
                        length = array ? array.length : 0;
                    if ( typeof callback != 'number' && callback != null ) {
                        var index = length;
                        callback = lodash.createCallback( callback, thisArg, 3 );
                        while ( index-- && callback( array[ index ], index, array ) ) {
                            n++;
                        }
                    } else {
                        n = ( callback == null || thisArg ) ? 1 : callback || n;
                    }
                    return slice( array, 0, nativeMin( nativeMax( 0, length - n ), length ) );
                }
                /**
                 * Creates an array of unique values present in all provided arrays using
                 * strict equality for comparisons, i.e. `===`.
                 *
                 * @static
                 * @memberOf _
                 * @category Arrays
                 * @param {...Array} [array] The arrays to inspect.
                 * @returns {Array} Returns an array of shared values.
                 * @example
                 *
                 * _.intersection([1, 2, 3], [5, 2, 1, 4], [2, 1]);
                 * // => [1, 2]
                 */
            function intersection() {
                    var args = [],
                        argsIndex = -1,
                        argsLength = arguments.length,
                        caches = getArray(),
                        indexOf = getIndexOf(),
                        trustIndexOf = indexOf === baseIndexOf,
                        seen = getArray();
                    while ( ++argsIndex < argsLength ) {
                        var value = arguments[ argsIndex ];
                        if ( isArray( value ) || isArguments( value ) ) {
                            args.push( value );
                            caches.push( trustIndexOf && value.length >= largeArraySize && createCache( argsIndex ? args[ argsIndex ] : seen ) );
                        }
                    }
                    var array = args[ 0 ],
                        index = -1,
                        length = array ? array.length : 0,
                        result = [];
                    outer: while ( ++index < length ) {
                        var cache = caches[ 0 ];
                        value = array[ index ];
                        if ( ( cache ? cacheIndexOf( cache, value ) : indexOf( seen, value ) ) < 0 ) {
                            argsIndex = argsLength;
                            ( cache || seen ).push( value );
                            while ( --argsIndex ) {
                                cache = caches[ argsIndex ];
                                if ( ( cache ? cacheIndexOf( cache, value ) : indexOf( args[ argsIndex ], value ) ) < 0 ) {
                                    continue outer;
                                }
                            }
                            result.push( value );
                        }
                    }
                    while ( argsLength-- ) {
                        cache = caches[ argsLength ];
                        if ( cache ) {
                            releaseObject( cache );
                        }
                    }
                    releaseArray( caches );
                    releaseArray( seen );
                    return result;
                }
                /**
                 * Gets the last element or last `n` elements of an array. If a callback is
                 * provided elements at the end of the array are returned as long as the
                 * callback returns truey. The callback is bound to `thisArg` and invoked
                 * with three arguments; (value, index, array).
                 *
                 * If a property name is provided for `callback` the created "_.pluck" style
                 * callback will return the property value of the given element.
                 *
                 * If an object is provided for `callback` the created "_.where" style callback
                 * will return `true` for elements that have the properties of the given object,
                 * else `false`.
                 *
                 * @static
                 * @memberOf _
                 * @category Arrays
                 * @param {Array} array The array to query.
                 * @param {Function|Object|number|string} [callback] The function called
                 *  per element or the number of elements to return. If a property name or
                 *  object is provided it will be used to create a "_.pluck" or "_.where"
                 *  style callback, respectively.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {*} Returns the last element(s) of `array`.
                 * @example
                 *
                 * _.last([1, 2, 3]);
                 * // => 3
                 *
                 * _.last([1, 2, 3], 2);
                 * // => [2, 3]
                 *
                 * _.last([1, 2, 3], function(num) {
                 *   return num > 1;
                 * });
                 * // => [2, 3]
                 *
                 * var characters = [
                 *   { 'name': 'barney',  'blocked': false, 'employer': 'slate' },
                 *   { 'name': 'fred',    'blocked': true,  'employer': 'slate' },
                 *   { 'name': 'pebbles', 'blocked': true,  'employer': 'na' }
                 * ];
                 *
                 * // using "_.pluck" callback shorthand
                 * _.pluck(_.last(characters, 'blocked'), 'name');
                 * // => ['fred', 'pebbles']
                 *
                 * // using "_.where" callback shorthand
                 * _.last(characters, { 'employer': 'na' });
                 * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
                 */
            function last( array, callback, thisArg ) {
                    var n = 0,
                        length = array ? array.length : 0;
                    if ( typeof callback != 'number' && callback != null ) {
                        var index = length;
                        callback = lodash.createCallback( callback, thisArg, 3 );
                        while ( index-- && callback( array[ index ], index, array ) ) {
                            n++;
                        }
                    } else {
                        n = callback;
                        if ( n == null || thisArg ) {
                            return array ? array[ length - 1 ] : undefined;
                        }
                    }
                    return slice( array, nativeMax( 0, length - n ) );
                }
                /**
                 * Gets the index at which the last occurrence of `value` is found using strict
                 * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
                 * as the offset from the end of the collection.
                 *
                 * If a property name is provided for `callback` the created "_.pluck" style
                 * callback will return the property value of the given element.
                 *
                 * If an object is provided for `callback` the created "_.where" style callback
                 * will return `true` for elements that have the properties of the given object,
                 * else `false`.
                 *
                 * @static
                 * @memberOf _
                 * @category Arrays
                 * @param {Array} array The array to search.
                 * @param {*} value The value to search for.
                 * @param {number} [fromIndex=array.length-1] The index to search from.
                 * @returns {number} Returns the index of the matched value or `-1`.
                 * @example
                 *
                 * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
                 * // => 4
                 *
                 * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
                 * // => 1
                 */
            function lastIndexOf( array, value, fromIndex ) {
                    var index = array ? array.length : 0;
                    if ( typeof fromIndex == 'number' ) {
                        index = ( fromIndex < 0 ? nativeMax( 0, index + fromIndex ) : nativeMin( fromIndex, index - 1 ) ) + 1;
                    }
                    while ( index-- ) {
                        if ( array[ index ] === value ) {
                            return index;
                        }
                    }
                    return -1;
                }
                /**
                 * Removes all provided values from the given array using strict equality for
                 * comparisons, i.e. `===`.
                 *
                 * @static
                 * @memberOf _
                 * @category Arrays
                 * @param {Array} array The array to modify.
                 * @param {...*} [value] The values to remove.
                 * @returns {Array} Returns `array`.
                 * @example
                 *
                 * var array = [1, 2, 3, 1, 2, 3];
                 * _.pull(array, 2, 3);
                 * console.log(array);
                 * // => [1, 1]
                 */
            function pull( array ) {
                    var args = arguments,
                        argsIndex = 0,
                        argsLength = args.length,
                        length = array ? array.length : 0;
                    while ( ++argsIndex < argsLength ) {
                        var index = -1,
                            value = args[ argsIndex ];
                        while ( ++index < length ) {
                            if ( array[ index ] === value ) {
                                splice.call( array, index--, 1 );
                                length--;
                            }
                        }
                    }
                    return array;
                }
                /**
                 * Creates an array of numbers (positive and/or negative) progressing from
                 * `start` up to but not including `end`. If `start` is less than `stop` a
                 * zero-length range is created unless a negative `step` is specified.
                 *
                 * @static
                 * @memberOf _
                 * @category Arrays
                 * @param {number} [start=0] The start of the range.
                 * @param {number} end The end of the range.
                 * @param {number} [step=1] The value to increment or decrement by.
                 * @returns {Array} Returns a new range array.
                 * @example
                 *
                 * _.range(4);
                 * // => [0, 1, 2, 3]
                 *
                 * _.range(1, 5);
                 * // => [1, 2, 3, 4]
                 *
                 * _.range(0, 20, 5);
                 * // => [0, 5, 10, 15]
                 *
                 * _.range(0, -4, -1);
                 * // => [0, -1, -2, -3]
                 *
                 * _.range(1, 4, 0);
                 * // => [1, 1, 1]
                 *
                 * _.range(0);
                 * // => []
                 */
            function range( start, end, step ) {
                    start = +start || 0;
                    step = typeof step == 'number' ? step : ( +step || 1 );
                    if ( end == null ) {
                        end = start;
                        start = 0;
                    }
                    // use `Array(length)` so engines like Chakra and V8 avoid slower modes
                    // http://youtu.be/XAqIpGU8ZZk#t=17m25s
                    var index = -1,
                        length = nativeMax( 0, ceil( ( end - start ) / ( step || 1 ) ) ),
                        result = Array( length );
                    while ( ++index < length ) {
                        result[ index ] = start;
                        start += step;
                    }
                    return result;
                }
                /**
                 * Removes all elements from an array that the callback returns truey for
                 * and returns an array of removed elements. The callback is bound to `thisArg`
                 * and invoked with three arguments; (value, index, array).
                 *
                 * If a property name is provided for `callback` the created "_.pluck" style
                 * callback will return the property value of the given element.
                 *
                 * If an object is provided for `callback` the created "_.where" style callback
                 * will return `true` for elements that have the properties of the given object,
                 * else `false`.
                 *
                 * @static
                 * @memberOf _
                 * @category Arrays
                 * @param {Array} array The array to modify.
                 * @param {Function|Object|string} [callback=identity] The function called
                 *  per iteration. If a property name or object is provided it will be used
                 *  to create a "_.pluck" or "_.where" style callback, respectively.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {Array} Returns a new array of removed elements.
                 * @example
                 *
                 * var array = [1, 2, 3, 4, 5, 6];
                 * var evens = _.remove(array, function(num) { return num % 2 == 0; });
                 *
                 * console.log(array);
                 * // => [1, 3, 5]
                 *
                 * console.log(evens);
                 * // => [2, 4, 6]
                 */
            function remove( array, callback, thisArg ) {
                    var index = -1,
                        length = array ? array.length : 0,
                        result = [];
                    callback = lodash.createCallback( callback, thisArg, 3 );
                    while ( ++index < length ) {
                        var value = array[ index ];
                        if ( callback( value, index, array ) ) {
                            result.push( value );
                            splice.call( array, index--, 1 );
                            length--;
                        }
                    }
                    return result;
                }
                /**
                 * The opposite of `_.initial` this method gets all but the first element or
                 * first `n` elements of an array. If a callback function is provided elements
                 * at the beginning of the array are excluded from the result as long as the
                 * callback returns truey. The callback is bound to `thisArg` and invoked
                 * with three arguments; (value, index, array).
                 *
                 * If a property name is provided for `callback` the created "_.pluck" style
                 * callback will return the property value of the given element.
                 *
                 * If an object is provided for `callback` the created "_.where" style callback
                 * will return `true` for elements that have the properties of the given object,
                 * else `false`.
                 *
                 * @static
                 * @memberOf _
                 * @alias drop, tail
                 * @category Arrays
                 * @param {Array} array The array to query.
                 * @param {Function|Object|number|string} [callback=1] The function called
                 *  per element or the number of elements to exclude. If a property name or
                 *  object is provided it will be used to create a "_.pluck" or "_.where"
                 *  style callback, respectively.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {Array} Returns a slice of `array`.
                 * @example
                 *
                 * _.rest([1, 2, 3]);
                 * // => [2, 3]
                 *
                 * _.rest([1, 2, 3], 2);
                 * // => [3]
                 *
                 * _.rest([1, 2, 3], function(num) {
                 *   return num < 3;
                 * });
                 * // => [3]
                 *
                 * var characters = [
                 *   { 'name': 'barney',  'blocked': true,  'employer': 'slate' },
                 *   { 'name': 'fred',    'blocked': false,  'employer': 'slate' },
                 *   { 'name': 'pebbles', 'blocked': true, 'employer': 'na' }
                 * ];
                 *
                 * // using "_.pluck" callback shorthand
                 * _.pluck(_.rest(characters, 'blocked'), 'name');
                 * // => ['fred', 'pebbles']
                 *
                 * // using "_.where" callback shorthand
                 * _.rest(characters, { 'employer': 'slate' });
                 * // => [{ 'name': 'pebbles', 'blocked': true, 'employer': 'na' }]
                 */
            function rest( array, callback, thisArg ) {
                    if ( typeof callback != 'number' && callback != null ) {
                        var n = 0,
                            index = -1,
                            length = array ? array.length : 0;
                        callback = lodash.createCallback( callback, thisArg, 3 );
                        while ( ++index < length && callback( array[ index ], index, array ) ) {
                            n++;
                        }
                    } else {
                        n = ( callback == null || thisArg ) ? 1 : nativeMax( 0, callback );
                    }
                    return slice( array, n );
                }
                /**
                 * Uses a binary search to determine the smallest index at which a value
                 * should be inserted into a given sorted array in order to maintain the sort
                 * order of the array. If a callback is provided it will be executed for
                 * `value` and each element of `array` to compute their sort ranking. The
                 * callback is bound to `thisArg` and invoked with one argument; (value).
                 *
                 * If a property name is provided for `callback` the created "_.pluck" style
                 * callback will return the property value of the given element.
                 *
                 * If an object is provided for `callback` the created "_.where" style callback
                 * will return `true` for elements that have the properties of the given object,
                 * else `false`.
                 *
                 * @static
                 * @memberOf _
                 * @category Arrays
                 * @param {Array} array The array to inspect.
                 * @param {*} value The value to evaluate.
                 * @param {Function|Object|string} [callback=identity] The function called
                 *  per iteration. If a property name or object is provided it will be used
                 *  to create a "_.pluck" or "_.where" style callback, respectively.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {number} Returns the index at which `value` should be inserted
                 *  into `array`.
                 * @example
                 *
                 * _.sortedIndex([20, 30, 50], 40);
                 * // => 2
                 *
                 * // using "_.pluck" callback shorthand
                 * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
                 * // => 2
                 *
                 * var dict = {
                 *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
                 * };
                 *
                 * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
                 *   return dict.wordToNumber[word];
                 * });
                 * // => 2
                 *
                 * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
                 *   return this.wordToNumber[word];
                 * }, dict);
                 * // => 2
                 */
            function sortedIndex( array, value, callback, thisArg ) {
                    var low = 0,
                        high = array ? array.length : low;
                    // explicitly reference `identity` for better inlining in Firefox
                    callback = callback ? lodash.createCallback( callback, thisArg, 1 ) : identity;
                    value = callback( value );
                    while ( low < high ) {
                        var mid = ( low + high ) >>> 1;
                        ( callback( array[ mid ] ) < value ) ? low = mid + 1: high = mid;
                    }
                    return low;
                }
                /**
                 * Creates an array of unique values, in order, of the provided arrays using
                 * strict equality for comparisons, i.e. `===`.
                 *
                 * @static
                 * @memberOf _
                 * @category Arrays
                 * @param {...Array} [array] The arrays to inspect.
                 * @returns {Array} Returns an array of combined values.
                 * @example
                 *
                 * _.union([1, 2, 3], [5, 2, 1, 4], [2, 1]);
                 * // => [1, 2, 3, 5, 4]
                 */
            function union() {
                    return baseUniq( baseFlatten( arguments, true, true ) );
                }
                /**
                 * Creates a duplicate-value-free version of an array using strict equality
                 * for comparisons, i.e. `===`. If the array is sorted, providing
                 * `true` for `isSorted` will use a faster algorithm. If a callback is provided
                 * each element of `array` is passed through the callback before uniqueness
                 * is computed. The callback is bound to `thisArg` and invoked with three
                 * arguments; (value, index, array).
                 *
                 * If a property name is provided for `callback` the created "_.pluck" style
                 * callback will return the property value of the given element.
                 *
                 * If an object is provided for `callback` the created "_.where" style callback
                 * will return `true` for elements that have the properties of the given object,
                 * else `false`.
                 *
                 * @static
                 * @memberOf _
                 * @alias unique
                 * @category Arrays
                 * @param {Array} array The array to process.
                 * @param {boolean} [isSorted=false] A flag to indicate that `array` is sorted.
                 * @param {Function|Object|string} [callback=identity] The function called
                 *  per iteration. If a property name or object is provided it will be used
                 *  to create a "_.pluck" or "_.where" style callback, respectively.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {Array} Returns a duplicate-value-free array.
                 * @example
                 *
                 * _.uniq([1, 2, 1, 3, 1]);
                 * // => [1, 2, 3]
                 *
                 * _.uniq([1, 1, 2, 2, 3], true);
                 * // => [1, 2, 3]
                 *
                 * _.uniq(['A', 'b', 'C', 'a', 'B', 'c'], function(letter) { return letter.toLowerCase(); });
                 * // => ['A', 'b', 'C']
                 *
                 * _.uniq([1, 2.5, 3, 1.5, 2, 3.5], function(num) { return this.floor(num); }, Math);
                 * // => [1, 2.5, 3]
                 *
                 * // using "_.pluck" callback shorthand
                 * _.uniq([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
                 * // => [{ 'x': 1 }, { 'x': 2 }]
                 */
            function uniq( array, isSorted, callback, thisArg ) {
                    // juggle arguments
                    if ( typeof isSorted != 'boolean' && isSorted != null ) {
                        thisArg = callback;
                        callback = ( typeof isSorted != 'function' && thisArg && thisArg[ isSorted ] === array ) ? null : isSorted;
                        isSorted = false;
                    }
                    if ( callback != null ) {
                        callback = lodash.createCallback( callback, thisArg, 3 );
                    }
                    return baseUniq( array, isSorted, callback );
                }
                /**
                 * Creates an array excluding all provided values using strict equality for
                 * comparisons, i.e. `===`.
                 *
                 * @static
                 * @memberOf _
                 * @category Arrays
                 * @param {Array} array The array to filter.
                 * @param {...*} [value] The values to exclude.
                 * @returns {Array} Returns a new array of filtered values.
                 * @example
                 *
                 * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
                 * // => [2, 3, 4]
                 */
            function without( array ) {
                    return baseDifference( array, slice( arguments, 1 ) );
                }
                /**
                 * Creates an array that is the symmetric difference of the provided arrays.
                 * See http://en.wikipedia.org/wiki/Symmetric_difference.
                 *
                 * @static
                 * @memberOf _
                 * @category Arrays
                 * @param {...Array} [array] The arrays to inspect.
                 * @returns {Array} Returns an array of values.
                 * @example
                 *
                 * _.xor([1, 2, 3], [5, 2, 1, 4]);
                 * // => [3, 5, 4]
                 *
                 * _.xor([1, 2, 5], [2, 3, 5], [3, 4, 5]);
                 * // => [1, 4, 5]
                 */
            function xor() {
                    var index = -1,
                        length = arguments.length;
                    while ( ++index < length ) {
                        var array = arguments[ index ];
                        if ( isArray( array ) || isArguments( array ) ) {
                            var result = result ? baseUniq( baseDifference( result, array ).concat( baseDifference( array, result ) ) ) : array;
                        }
                    }
                    return result || [];
                }
                /**
                 * Creates an array of grouped elements, the first of which contains the first
                 * elements of the given arrays, the second of which contains the second
                 * elements of the given arrays, and so on.
                 *
                 * @static
                 * @memberOf _
                 * @alias unzip
                 * @category Arrays
                 * @param {...Array} [array] Arrays to process.
                 * @returns {Array} Returns a new array of grouped elements.
                 * @example
                 *
                 * _.zip(['fred', 'barney'], [30, 40], [true, false]);
                 * // => [['fred', 30, true], ['barney', 40, false]]
                 */
            function zip() {
                    var array = arguments.length > 1 ? arguments : arguments[ 0 ],
                        index = -1,
                        length = array ? max( pluck( array, 'length' ) ) : 0,
                        result = Array( length < 0 ? 0 : length );
                    while ( ++index < length ) {
                        result[ index ] = pluck( array, index );
                    }
                    return result;
                }
                /**
                 * Creates an object composed from arrays of `keys` and `values`. Provide
                 * either a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`
                 * or two arrays, one of `keys` and one of corresponding `values`.
                 *
                 * @static
                 * @memberOf _
                 * @alias object
                 * @category Arrays
                 * @param {Array} keys The array of keys.
                 * @param {Array} [values=[]] The array of values.
                 * @returns {Object} Returns an object composed of the given keys and
                 *  corresponding values.
                 * @example
                 *
                 * _.zipObject(['fred', 'barney'], [30, 40]);
                 * // => { 'fred': 30, 'barney': 40 }
                 */
            function zipObject( keys, values ) {
                    var index = -1,
                        length = keys ? keys.length : 0,
                        result = {};
                    if ( !values && length && !isArray( keys[ 0 ] ) ) {
                        values = [];
                    }
                    while ( ++index < length ) {
                        var key = keys[ index ];
                        if ( values ) {
                            result[ key ] = values[ index ];
                        } else if ( key ) {
                            result[ key[ 0 ] ] = key[ 1 ];
                        }
                    }
                    return result;
                }
                /*--------------------------------------------------------------------------*/
                /**
                 * Creates a function that executes `func`, with  the `this` binding and
                 * arguments of the created function, only after being called `n` times.
                 *
                 * @static
                 * @memberOf _
                 * @category Functions
                 * @param {number} n The number of times the function must be called before
                 *  `func` is executed.
                 * @param {Function} func The function to restrict.
                 * @returns {Function} Returns the new restricted function.
                 * @example
                 *
                 * var saves = ['profile', 'settings'];
                 *
                 * var done = _.after(saves.length, function() {
                 *   console.log('Done saving!');
                 * });
                 *
                 * _.forEach(saves, function(type) {
                 *   asyncSave({ 'type': type, 'complete': done });
                 * });
                 * // => logs 'Done saving!', after all saves have completed
                 */
            function after( n, func ) {
                    if ( !isFunction( func ) ) {
                        throw new TypeError;
                    }
                    return function() {
                        if ( --n < 1 ) {
                            return func.apply( this, arguments );
                        }
                    };
                }
                /**
                 * Creates a function that, when called, invokes `func` with the `this`
                 * binding of `thisArg` and prepends any additional `bind` arguments to those
                 * provided to the bound function.
                 *
                 * @static
                 * @memberOf _
                 * @category Functions
                 * @param {Function} func The function to bind.
                 * @param {*} [thisArg] The `this` binding of `func`.
                 * @param {...*} [arg] Arguments to be partially applied.
                 * @returns {Function} Returns the new bound function.
                 * @example
                 *
                 * var func = function(greeting) {
                 *   return greeting + ' ' + this.name;
                 * };
                 *
                 * func = _.bind(func, { 'name': 'fred' }, 'hi');
                 * func();
                 * // => 'hi fred'
                 */
            function bind( func, thisArg ) {
                    return arguments.length > 2 ? createWrapper( func, 17, slice( arguments, 2 ), null, thisArg ) : createWrapper( func, 1, null, null, thisArg );
                }
                /**
                 * Binds methods of an object to the object itself, overwriting the existing
                 * method. Method names may be specified as individual arguments or as arrays
                 * of method names. If no method names are provided all the function properties
                 * of `object` will be bound.
                 *
                 * @static
                 * @memberOf _
                 * @category Functions
                 * @param {Object} object The object to bind and assign the bound methods to.
                 * @param {...string} [methodName] The object method names to
                 *  bind, specified as individual method names or arrays of method names.
                 * @returns {Object} Returns `object`.
                 * @example
                 *
                 * var view = {
                 *   'label': 'docs',
                 *   'onClick': function() { console.log('clicked ' + this.label); }
                 * };
                 *
                 * _.bindAll(view);
                 * jQuery('#docs').on('click', view.onClick);
                 * // => logs 'clicked docs', when the button is clicked
                 */
            function bindAll( object ) {
                    var funcs = arguments.length > 1 ? baseFlatten( arguments, true, false, 1 ) : functions( object ),
                        index = -1,
                        length = funcs.length;
                    while ( ++index < length ) {
                        var key = funcs[ index ];
                        object[ key ] = createWrapper( object[ key ], 1, null, null, object );
                    }
                    return object;
                }
                /**
                 * Creates a function that, when called, invokes the method at `object[key]`
                 * and prepends any additional `bindKey` arguments to those provided to the bound
                 * function. This method differs from `_.bind` by allowing bound functions to
                 * reference methods that will be redefined or don't yet exist.
                 * See http://michaux.ca/articles/lazy-function-definition-pattern.
                 *
                 * @static
                 * @memberOf _
                 * @category Functions
                 * @param {Object} object The object the method belongs to.
                 * @param {string} key The key of the method.
                 * @param {...*} [arg] Arguments to be partially applied.
                 * @returns {Function} Returns the new bound function.
                 * @example
                 *
                 * var object = {
                 *   'name': 'fred',
                 *   'greet': function(greeting) {
                 *     return greeting + ' ' + this.name;
                 *   }
                 * };
                 *
                 * var func = _.bindKey(object, 'greet', 'hi');
                 * func();
                 * // => 'hi fred'
                 *
                 * object.greet = function(greeting) {
                 *   return greeting + 'ya ' + this.name + '!';
                 * };
                 *
                 * func();
                 * // => 'hiya fred!'
                 */
            function bindKey( object, key ) {
                    return arguments.length > 2 ? createWrapper( key, 19, slice( arguments, 2 ), null, object ) : createWrapper( key, 3, null, null, object );
                }
                /**
                 * Creates a function that is the composition of the provided functions,
                 * where each function consumes the return value of the function that follows.
                 * For example, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
                 * Each function is executed with the `this` binding of the composed function.
                 *
                 * @static
                 * @memberOf _
                 * @category Functions
                 * @param {...Function} [func] Functions to compose.
                 * @returns {Function} Returns the new composed function.
                 * @example
                 *
                 * var realNameMap = {
                 *   'pebbles': 'penelope'
                 * };
                 *
                 * var format = function(name) {
                 *   name = realNameMap[name.toLowerCase()] || name;
                 *   return name.charAt(0).toUpperCase() + name.slice(1).toLowerCase();
                 * };
                 *
                 * var greet = function(formatted) {
                 *   return 'Hiya ' + formatted + '!';
                 * };
                 *
                 * var welcome = _.compose(greet, format);
                 * welcome('pebbles');
                 * // => 'Hiya Penelope!'
                 */
            function compose() {
                    var funcs = arguments,
                        length = funcs.length;
                    while ( length-- ) {
                        if ( !isFunction( funcs[ length ] ) ) {
                            throw new TypeError;
                        }
                    }
                    return function() {
                        var args = arguments,
                            length = funcs.length;
                        while ( length-- ) {
                            args = [ funcs[ length ].apply( this, args ) ];
                        }
                        return args[ 0 ];
                    };
                }
                /**
                 * Creates a function which accepts one or more arguments of `func` that when
                 * invoked either executes `func` returning its result, if all `func` arguments
                 * have been provided, or returns a function that accepts one or more of the
                 * remaining `func` arguments, and so on. The arity of `func` can be specified
                 * if `func.length` is not sufficient.
                 *
                 * @static
                 * @memberOf _
                 * @category Functions
                 * @param {Function} func The function to curry.
                 * @param {number} [arity=func.length] The arity of `func`.
                 * @returns {Function} Returns the new curried function.
                 * @example
                 *
                 * var curried = _.curry(function(a, b, c) {
                 *   console.log(a + b + c);
                 * });
                 *
                 * curried(1)(2)(3);
                 * // => 6
                 *
                 * curried(1, 2)(3);
                 * // => 6
                 *
                 * curried(1, 2, 3);
                 * // => 6
                 */
            function curry( func, arity ) {
                    arity = typeof arity == 'number' ? arity : ( +arity || func.length );
                    return createWrapper( func, 4, null, null, null, arity );
                }
                /**
                 * Creates a function that will delay the execution of `func` until after
                 * `wait` milliseconds have elapsed since the last time it was invoked.
                 * Provide an options object to indicate that `func` should be invoked on
                 * the leading and/or trailing edge of the `wait` timeout. Subsequent calls
                 * to the debounced function will return the result of the last `func` call.
                 *
                 * Note: If `leading` and `trailing` options are `true` `func` will be called
                 * on the trailing edge of the timeout only if the the debounced function is
                 * invoked more than once during the `wait` timeout.
                 *
                 * @static
                 * @memberOf _
                 * @category Functions
                 * @param {Function} func The function to debounce.
                 * @param {number} wait The number of milliseconds to delay.
                 * @param {Object} [options] The options object.
                 * @param {boolean} [options.leading=false] Specify execution on the leading edge of the timeout.
                 * @param {number} [options.maxWait] The maximum time `func` is allowed to be delayed before it's called.
                 * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
                 * @returns {Function} Returns the new debounced function.
                 * @example
                 *
                 * // avoid costly calculations while the window size is in flux
                 * var lazyLayout = _.debounce(calculateLayout, 150);
                 * jQuery(window).on('resize', lazyLayout);
                 *
                 * // execute `sendMail` when the click event is fired, debouncing subsequent calls
                 * jQuery('#postbox').on('click', _.debounce(sendMail, 300, {
                 *   'leading': true,
                 *   'trailing': false
                 * });
                 *
                 * // ensure `batchLog` is executed once after 1 second of debounced calls
                 * var source = new EventSource('/stream');
                 * source.addEventListener('message', _.debounce(batchLog, 250, {
                 *   'maxWait': 1000
                 * }, false);
                 */
            function debounce( func, wait, options ) {
                    var args,
                        maxTimeoutId,
                        result,
                        stamp,
                        thisArg,
                        timeoutId,
                        trailingCall,
                        lastCalled = 0,
                        maxWait = false,
                        trailing = true;
                    if ( !isFunction( func ) ) {
                        throw new TypeError;
                    }
                    wait = nativeMax( 0, wait ) || 0;
                    if ( options === true ) {
                        var leading = true;
                        trailing = false;
                    } else if ( isObject( options ) ) {
                        leading = options.leading;
                        maxWait = 'maxWait' in options && ( nativeMax( wait, options.maxWait ) || 0 );
                        trailing = 'trailing' in options ? options.trailing : trailing;
                    }
                    var delayed = function() {
                        var remaining = wait - ( now() - stamp );
                        if ( remaining <= 0 ) {
                            if ( maxTimeoutId ) {
                                clearTimeout( maxTimeoutId );
                            }
                            var isCalled = trailingCall;
                            maxTimeoutId = timeoutId = trailingCall = undefined;
                            if ( isCalled ) {
                                lastCalled = now();
                                result = func.apply( thisArg, args );
                                if ( !timeoutId && !maxTimeoutId ) {
                                    args = thisArg = null;
                                }
                            }
                        } else {
                            timeoutId = setTimeout( delayed, remaining );
                        }
                    };
                    var maxDelayed = function() {
                        if ( timeoutId ) {
                            clearTimeout( timeoutId );
                        }
                        maxTimeoutId = timeoutId = trailingCall = undefined;
                        if ( trailing || ( maxWait !== wait ) ) {
                            lastCalled = now();
                            result = func.apply( thisArg, args );
                            if ( !timeoutId && !maxTimeoutId ) {
                                args = thisArg = null;
                            }
                        }
                    };
                    return function() {
                        args = arguments;
                        stamp = now();
                        thisArg = this;
                        trailingCall = trailing && ( timeoutId || !leading );
                        if ( maxWait === false ) {
                            var leadingCall = leading && !timeoutId;
                        } else {
                            if ( !maxTimeoutId && !leading ) {
                                lastCalled = stamp;
                            }
                            var remaining = maxWait - ( stamp - lastCalled ),
                                isCalled = remaining <= 0;
                            if ( isCalled ) {
                                if ( maxTimeoutId ) {
                                    maxTimeoutId = clearTimeout( maxTimeoutId );
                                }
                                lastCalled = stamp;
                                result = func.apply( thisArg, args );
                            } else if ( !maxTimeoutId ) {
                                maxTimeoutId = setTimeout( maxDelayed, remaining );
                            }
                        }
                        if ( isCalled && timeoutId ) {
                            timeoutId = clearTimeout( timeoutId );
                        } else if ( !timeoutId && wait !== maxWait ) {
                            timeoutId = setTimeout( delayed, wait );
                        }
                        if ( leadingCall ) {
                            isCalled = true;
                            result = func.apply( thisArg, args );
                        }
                        if ( isCalled && !timeoutId && !maxTimeoutId ) {
                            args = thisArg = null;
                        }
                        return result;
                    };
                }
                /**
                 * Defers executing the `func` function until the current call stack has cleared.
                 * Additional arguments will be provided to `func` when it is invoked.
                 *
                 * @static
                 * @memberOf _
                 * @category Functions
                 * @param {Function} func The function to defer.
                 * @param {...*} [arg] Arguments to invoke the function with.
                 * @returns {number} Returns the timer id.
                 * @example
                 *
                 * _.defer(function(text) { console.log(text); }, 'deferred');
                 * // logs 'deferred' after one or more milliseconds
                 */
            function defer( func ) {
                    if ( !isFunction( func ) ) {
                        throw new TypeError;
                    }
                    var args = slice( arguments, 1 );
                    return setTimeout( function() {
                        func.apply( undefined, args );
                    }, 1 );
                }
                /**
                 * Executes the `func` function after `wait` milliseconds. Additional arguments
                 * will be provided to `func` when it is invoked.
                 *
                 * @static
                 * @memberOf _
                 * @category Functions
                 * @param {Function} func The function to delay.
                 * @param {number} wait The number of milliseconds to delay execution.
                 * @param {...*} [arg] Arguments to invoke the function with.
                 * @returns {number} Returns the timer id.
                 * @example
                 *
                 * _.delay(function(text) { console.log(text); }, 1000, 'later');
                 * // => logs 'later' after one second
                 */
            function delay( func, wait ) {
                    if ( !isFunction( func ) ) {
                        throw new TypeError;
                    }
                    var args = slice( arguments, 2 );
                    return setTimeout( function() {
                        func.apply( undefined, args );
                    }, wait );
                }
                /**
                 * Creates a function that memoizes the result of `func`. If `resolver` is
                 * provided it will be used to determine the cache key for storing the result
                 * based on the arguments provided to the memoized function. By default, the
                 * first argument provided to the memoized function is used as the cache key.
                 * The `func` is executed with the `this` binding of the memoized function.
                 * The result cache is exposed as the `cache` property on the memoized function.
                 *
                 * @static
                 * @memberOf _
                 * @category Functions
                 * @param {Function} func The function to have its output memoized.
                 * @param {Function} [resolver] A function used to resolve the cache key.
                 * @returns {Function} Returns the new memoizing function.
                 * @example
                 *
                 * var fibonacci = _.memoize(function(n) {
                 *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
                 * });
                 *
                 * fibonacci(9)
                 * // => 34
                 *
                 * var data = {
                 *   'fred': { 'name': 'fred', 'age': 40 },
                 *   'pebbles': { 'name': 'pebbles', 'age': 1 }
                 * };
                 *
                 * // modifying the result cache
                 * var get = _.memoize(function(name) { return data[name]; }, _.identity);
                 * get('pebbles');
                 * // => { 'name': 'pebbles', 'age': 1 }
                 *
                 * get.cache.pebbles.name = 'penelope';
                 * get('pebbles');
                 * // => { 'name': 'penelope', 'age': 1 }
                 */
            function memoize( func, resolver ) {
                    if ( !isFunction( func ) ) {
                        throw new TypeError;
                    }
                    var memoized = function() {
                        var cache = memoized.cache,
                            key = resolver ? resolver.apply( this, arguments ) : keyPrefix + arguments[ 0 ];
                        return hasOwnProperty.call( cache, key ) ? cache[ key ] : ( cache[ key ] = func.apply( this, arguments ) );
                    }
                    memoized.cache = {};
                    return memoized;
                }
                /**
                 * Creates a function that is restricted to execute `func` once. Repeat calls to
                 * the function will return the value of the first call. The `func` is executed
                 * with the `this` binding of the created function.
                 *
                 * @static
                 * @memberOf _
                 * @category Functions
                 * @param {Function} func The function to restrict.
                 * @returns {Function} Returns the new restricted function.
                 * @example
                 *
                 * var initialize = _.once(createApplication);
                 * initialize();
                 * initialize();
                 * // `initialize` executes `createApplication` once
                 */
            function once( func ) {
                    var ran,
                        result;
                    if ( !isFunction( func ) ) {
                        throw new TypeError;
                    }
                    return function() {
                        if ( ran ) {
                            return result;
                        }
                        ran = true;
                        result = func.apply( this, arguments );
                        // clear the `func` variable so the function may be garbage collected
                        func = null;
                        return result;
                    };
                }
                /**
                 * Creates a function that, when called, invokes `func` with any additional
                 * `partial` arguments prepended to those provided to the new function. This
                 * method is similar to `_.bind` except it does **not** alter the `this` binding.
                 *
                 * @static
                 * @memberOf _
                 * @category Functions
                 * @param {Function} func The function to partially apply arguments to.
                 * @param {...*} [arg] Arguments to be partially applied.
                 * @returns {Function} Returns the new partially applied function.
                 * @example
                 *
                 * var greet = function(greeting, name) { return greeting + ' ' + name; };
                 * var hi = _.partial(greet, 'hi');
                 * hi('fred');
                 * // => 'hi fred'
                 */
            function partial( func ) {
                    return createWrapper( func, 16, slice( arguments, 1 ) );
                }
                /**
                 * This method is like `_.partial` except that `partial` arguments are
                 * appended to those provided to the new function.
                 *
                 * @static
                 * @memberOf _
                 * @category Functions
                 * @param {Function} func The function to partially apply arguments to.
                 * @param {...*} [arg] Arguments to be partially applied.
                 * @returns {Function} Returns the new partially applied function.
                 * @example
                 *
                 * var defaultsDeep = _.partialRight(_.merge, _.defaults);
                 *
                 * var options = {
                 *   'variable': 'data',
                 *   'imports': { 'jq': $ }
                 * };
                 *
                 * defaultsDeep(options, _.templateSettings);
                 *
                 * options.variable
                 * // => 'data'
                 *
                 * options.imports
                 * // => { '_': _, 'jq': $ }
                 */
            function partialRight( func ) {
                    return createWrapper( func, 32, null, slice( arguments, 1 ) );
                }
                /**
                 * Creates a function that, when executed, will only call the `func` function
                 * at most once per every `wait` milliseconds. Provide an options object to
                 * indicate that `func` should be invoked on the leading and/or trailing edge
                 * of the `wait` timeout. Subsequent calls to the throttled function will
                 * return the result of the last `func` call.
                 *
                 * Note: If `leading` and `trailing` options are `true` `func` will be called
                 * on the trailing edge of the timeout only if the the throttled function is
                 * invoked more than once during the `wait` timeout.
                 *
                 * @static
                 * @memberOf _
                 * @category Functions
                 * @param {Function} func The function to throttle.
                 * @param {number} wait The number of milliseconds to throttle executions to.
                 * @param {Object} [options] The options object.
                 * @param {boolean} [options.leading=true] Specify execution on the leading edge of the timeout.
                 * @param {boolean} [options.trailing=true] Specify execution on the trailing edge of the timeout.
                 * @returns {Function} Returns the new throttled function.
                 * @example
                 *
                 * // avoid excessively updating the position while scrolling
                 * var throttled = _.throttle(updatePosition, 100);
                 * jQuery(window).on('scroll', throttled);
                 *
                 * // execute `renewToken` when the click event is fired, but not more than once every 5 minutes
                 * jQuery('.interactive').on('click', _.throttle(renewToken, 300000, {
                 *   'trailing': false
                 * }));
                 */
            function throttle( func, wait, options ) {
                    var leading = true,
                        trailing = true;
                    if ( !isFunction( func ) ) {
                        throw new TypeError;
                    }
                    if ( options === false ) {
                        leading = false;
                    } else if ( isObject( options ) ) {
                        leading = 'leading' in options ? options.leading : leading;
                        trailing = 'trailing' in options ? options.trailing : trailing;
                    }
                    debounceOptions.leading = leading;
                    debounceOptions.maxWait = wait;
                    debounceOptions.trailing = trailing;
                    return debounce( func, wait, debounceOptions );
                }
                /**
                 * Creates a function that provides `value` to the wrapper function as its
                 * first argument. Additional arguments provided to the function are appended
                 * to those provided to the wrapper function. The wrapper is executed with
                 * the `this` binding of the created function.
                 *
                 * @static
                 * @memberOf _
                 * @category Functions
                 * @param {*} value The value to wrap.
                 * @param {Function} wrapper The wrapper function.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var p = _.wrap(_.escape, function(func, text) {
                 *   return '<p>' + func(text) + '</p>';
                 * });
                 *
                 * p('Fred, Wilma, & Pebbles');
                 * // => '<p>Fred, Wilma, &amp; Pebbles</p>'
                 */
            function wrap( value, wrapper ) {
                    return createWrapper( wrapper, 16, [ value ] );
                }
                /*--------------------------------------------------------------------------*/
                /**
                 * Creates a function that returns `value`.
                 *
                 * @static
                 * @memberOf _
                 * @category Utilities
                 * @param {*} value The value to return from the new function.
                 * @returns {Function} Returns the new function.
                 * @example
                 *
                 * var object = { 'name': 'fred' };
                 * var getter = _.constant(object);
                 * getter() === object;
                 * // => true
                 */
            function constant( value ) {
                    return function() {
                        return value;
                    };
                }
                /**
                 * Produces a callback bound to an optional `thisArg`. If `func` is a property
                 * name the created callback will return the property value for a given element.
                 * If `func` is an object the created callback will return `true` for elements
                 * that contain the equivalent object properties, otherwise it will return `false`.
                 *
                 * @static
                 * @memberOf _
                 * @category Utilities
                 * @param {*} [func=identity] The value to convert to a callback.
                 * @param {*} [thisArg] The `this` binding of the created callback.
                 * @param {number} [argCount] The number of arguments the callback accepts.
                 * @returns {Function} Returns a callback function.
                 * @example
                 *
                 * var characters = [
                 *   { 'name': 'barney', 'age': 36 },
                 *   { 'name': 'fred',   'age': 40 }
                 * ];
                 *
                 * // wrap to create custom callback shorthands
                 * _.createCallback = _.wrap(_.createCallback, function(func, callback, thisArg) {
                 *   var match = /^(.+?)__([gl]t)(.+)$/.exec(callback);
                 *   return !match ? func(callback, thisArg) : function(object) {
                 *     return match[2] == 'gt' ? object[match[1]] > match[3] : object[match[1]] < match[3];
                 *   };
                 * });
                 *
                 * _.filter(characters, 'age__gt38');
                 * // => [{ 'name': 'fred', 'age': 40 }]
                 */
            function createCallback( func, thisArg, argCount ) {
                    var type = typeof func;
                    if ( func == null || type == 'function' ) {
                        return baseCreateCallback( func, thisArg, argCount );
                    }
                    // handle "_.pluck" style callback shorthands
                    if ( type != 'object' ) {
                        return property( func );
                    }
                    var props = keys( func ),
                        key = props[ 0 ],
                        a = func[ key ];
                    // handle "_.where" style callback shorthands
                    if ( props.length == 1 && a === a && !isObject( a ) ) {
                        // fast path the common case of providing an object with a single
                        // property containing a primitive value
                        return function( object ) {
                            var b = object[ key ];
                            return a === b && ( a !== 0 || ( 1 / a == 1 / b ) );
                        };
                    }
                    return function( object ) {
                        var length = props.length,
                            result = false;
                        while ( length-- ) {
                            if ( !( result = baseIsEqual( object[ props[ length ] ], func[ props[ length ] ], null, true ) ) ) {
                                break;
                            }
                        }
                        return result;
                    };
                }
                /**
                 * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
                 * corresponding HTML entities.
                 *
                 * @static
                 * @memberOf _
                 * @category Utilities
                 * @param {string} string The string to escape.
                 * @returns {string} Returns the escaped string.
                 * @example
                 *
                 * _.escape('Fred, Wilma, & Pebbles');
                 * // => 'Fred, Wilma, &amp; Pebbles'
                 */
            function escape( string ) {
                    return string == null ? '' : String( string ).replace( reUnescapedHtml, escapeHtmlChar );
                }
                /**
                 * This method returns the first argument provided to it.
                 *
                 * @static
                 * @memberOf _
                 * @category Utilities
                 * @param {*} value Any value.
                 * @returns {*} Returns `value`.
                 * @example
                 *
                 * var object = { 'name': 'fred' };
                 * _.identity(object) === object;
                 * // => true
                 */
            function identity( value ) {
                    return value;
                }
                /**
                 * Adds function properties of a source object to the destination object.
                 * If `object` is a function methods will be added to its prototype as well.
                 *
                 * @static
                 * @memberOf _
                 * @category Utilities
                 * @param {Function|Object} [object=lodash] object The destination object.
                 * @param {Object} source The object of functions to add.
                 * @param {Object} [options] The options object.
                 * @param {boolean} [options.chain=true] Specify whether the functions added are chainable.
                 * @example
                 *
                 * function capitalize(string) {
                 *   return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
                 * }
                 *
                 * _.mixin({ 'capitalize': capitalize });
                 * _.capitalize('fred');
                 * // => 'Fred'
                 *
                 * _('fred').capitalize().value();
                 * // => 'Fred'
                 *
                 * _.mixin({ 'capitalize': capitalize }, { 'chain': false });
                 * _('fred').capitalize();
                 * // => 'Fred'
                 */
            function mixin( object, source, options ) {
                    var chain = true,
                        methodNames = source && functions( source );
                    if ( !source || ( !options && !methodNames.length ) ) {
                        if ( options == null ) {
                            options = source;
                        }
                        ctor = lodashWrapper;
                        source = object;
                        object = lodash;
                        methodNames = functions( source );
                    }
                    if ( options === false ) {
                        chain = false;
                    } else if ( isObject( options ) && 'chain' in options ) {
                        chain = options.chain;
                    }
                    var ctor = object,
                        isFunc = isFunction( ctor );
                    forEach( methodNames, function( methodName ) {
                        var func = object[ methodName ] = source[ methodName ];
                        if ( isFunc ) {
                            ctor.prototype[ methodName ] = function() {
                                var chainAll = this.__chain__,
                                    value = this.__wrapped__,
                                    args = [ value ];
                                push.apply( args, arguments );
                                var result = func.apply( object, args );
                                if ( chain || chainAll ) {
                                    if ( value === result && isObject( result ) ) {
                                        return this;
                                    }
                                    result = new ctor( result );
                                    result.__chain__ = chainAll;
                                }
                                return result;
                            };
                        }
                    } );
                }
                /**
                 * Reverts the '_' variable to its previous value and returns a reference to
                 * the `lodash` function.
                 *
                 * @static
                 * @memberOf _
                 * @category Utilities
                 * @returns {Function} Returns the `lodash` function.
                 * @example
                 *
                 * var lodash = _.noConflict();
                 */
            function noConflict() {
                    context._ = oldDash;
                    return this;
                }
                /**
                 * A no-operation function.
                 *
                 * @static
                 * @memberOf _
                 * @category Utilities
                 * @example
                 *
                 * var object = { 'name': 'fred' };
                 * _.noop(object) === undefined;
                 * // => true
                 */
            function noop() {
                    // no operation performed
                }
                /**
                 * Gets the number of milliseconds that have elapsed since the Unix epoch
                 * (1 January 1970 00:00:00 UTC).
                 *
                 * @static
                 * @memberOf _
                 * @category Utilities
                 * @example
                 *
                 * var stamp = _.now();
                 * _.defer(function() { console.log(_.now() - stamp); });
                 * // => logs the number of milliseconds it took for the deferred function to be called
                 */
            var now = isNative( now = Date.now ) && now || function() {
                return new Date().getTime();
            };
            /**
             * Converts the given value into an integer of the specified radix.
             * If `radix` is `undefined` or `0` a `radix` of `10` is used unless the
             * `value` is a hexadecimal, in which case a `radix` of `16` is used.
             *
             * Note: This method avoids differences in native ES3 and ES5 `parseInt`
             * implementations. See http://es5.github.io/#E.
             *
             * @static
             * @memberOf _
             * @category Utilities
             * @param {string} value The value to parse.
             * @param {number} [radix] The radix used to interpret the value to parse.
             * @returns {number} Returns the new integer value.
             * @example
             *
             * _.parseInt('08');
             * // => 8
             */
            var parseInt = nativeParseInt( whitespace + '08' ) == 8 ? nativeParseInt : function( value, radix ) {
                // Firefox < 21 and Opera < 15 follow the ES3 specified implementation of `parseInt`
                return nativeParseInt( isString( value ) ? value.replace( reLeadingSpacesAndZeros, '' ) : value, radix || 0 );
            };
            /**
             * Creates a "_.pluck" style function, which returns the `key` value of a
             * given object.
             *
             * @static
             * @memberOf _
             * @category Utilities
             * @param {string} key The name of the property to retrieve.
             * @returns {Function} Returns the new function.
             * @example
             *
             * var characters = [
             *   { 'name': 'fred',   'age': 40 },
             *   { 'name': 'barney', 'age': 36 }
             * ];
             *
             * var getName = _.property('name');
             *
             * _.map(characters, getName);
             * // => ['barney', 'fred']
             *
             * _.sortBy(characters, getName);
             * // => [{ 'name': 'barney', 'age': 36 }, { 'name': 'fred',   'age': 40 }]
             */
            function property( key ) {
                    return function( object ) {
                        return object[ key ];
                    };
                }
                /**
                 * Produces a random number between `min` and `max` (inclusive). If only one
                 * argument is provided a number between `0` and the given number will be
                 * returned. If `floating` is truey or either `min` or `max` are floats a
                 * floating-point number will be returned instead of an integer.
                 *
                 * @static
                 * @memberOf _
                 * @category Utilities
                 * @param {number} [min=0] The minimum possible value.
                 * @param {number} [max=1] The maximum possible value.
                 * @param {boolean} [floating=false] Specify returning a floating-point number.
                 * @returns {number} Returns a random number.
                 * @example
                 *
                 * _.random(0, 5);
                 * // => an integer between 0 and 5
                 *
                 * _.random(5);
                 * // => also an integer between 0 and 5
                 *
                 * _.random(5, true);
                 * // => a floating-point number between 0 and 5
                 *
                 * _.random(1.2, 5.2);
                 * // => a floating-point number between 1.2 and 5.2
                 */
            function random( min, max, floating ) {
                    var noMin = min == null,
                        noMax = max == null;
                    if ( floating == null ) {
                        if ( typeof min == 'boolean' && noMax ) {
                            floating = min;
                            min = 1;
                        } else if ( !noMax && typeof max == 'boolean' ) {
                            floating = max;
                            noMax = true;
                        }
                    }
                    if ( noMin && noMax ) {
                        max = 1;
                    }
                    min = +min || 0;
                    if ( noMax ) {
                        max = min;
                        min = 0;
                    } else {
                        max = +max || 0;
                    }
                    if ( floating || min % 1 || max % 1 ) {
                        var rand = nativeRandom();
                        return nativeMin( min + ( rand * ( max - min + parseFloat( '1e-' + ( ( rand + '' ).length - 1 ) ) ) ), max );
                    }
                    return baseRandom( min, max );
                }
                /**
                 * Resolves the value of property `key` on `object`. If `key` is a function
                 * it will be invoked with the `this` binding of `object` and its result returned,
                 * else the property value is returned. If `object` is falsey then `undefined`
                 * is returned.
                 *
                 * @static
                 * @memberOf _
                 * @category Utilities
                 * @param {Object} object The object to inspect.
                 * @param {string} key The name of the property to resolve.
                 * @returns {*} Returns the resolved value.
                 * @example
                 *
                 * var object = {
                 *   'cheese': 'crumpets',
                 *   'stuff': function() {
                 *     return 'nonsense';
                 *   }
                 * };
                 *
                 * _.result(object, 'cheese');
                 * // => 'crumpets'
                 *
                 * _.result(object, 'stuff');
                 * // => 'nonsense'
                 */
            function result( object, key ) {
                    if ( object ) {
                        var value = object[ key ];
                        return isFunction( value ) ? object[ key ]() : value;
                    }
                }
                /**
                 * A micro-templating method that handles arbitrary delimiters, preserves
                 * whitespace, and correctly escapes quotes within interpolated code.
                 *
                 * Note: In the development build, `_.template` utilizes sourceURLs for easier
                 * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
                 *
                 * For more information on precompiling templates see:
                 * http://lodash.com/custom-builds
                 *
                 * For more information on Chrome extension sandboxes see:
                 * http://developer.chrome.com/stable/extensions/sandboxingEval.html
                 *
                 * @static
                 * @memberOf _
                 * @category Utilities
                 * @param {string} text The template text.
                 * @param {Object} data The data object used to populate the text.
                 * @param {Object} [options] The options object.
                 * @param {RegExp} [options.escape] The "escape" delimiter.
                 * @param {RegExp} [options.evaluate] The "evaluate" delimiter.
                 * @param {Object} [options.imports] An object to import into the template as local variables.
                 * @param {RegExp} [options.interpolate] The "interpolate" delimiter.
                 * @param {string} [sourceURL] The sourceURL of the template's compiled source.
                 * @param {string} [variable] The data object variable name.
                 * @returns {Function|string} Returns a compiled function when no `data` object
                 *  is given, else it returns the interpolated text.
                 * @example
                 *
                 * // using the "interpolate" delimiter to create a compiled template
                 * var compiled = _.template('hello <%= name %>');
                 * compiled({ 'name': 'fred' });
                 * // => 'hello fred'
                 *
                 * // using the "escape" delimiter to escape HTML in data property values
                 * _.template('<b><%- value %></b>', { 'value': '<script>' });
                 * // => '<b>&lt;script&gt;</b>'
                 *
                 * // using the "evaluate" delimiter to generate HTML
                 * var list = '<% _.forEach(people, function(name) { %><li><%- name %></li><% }); %>';
                 * _.template(list, { 'people': ['fred', 'barney'] });
                 * // => '<li>fred</li><li>barney</li>'
                 *
                 * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
                 * _.template('hello ${ name }', { 'name': 'pebbles' });
                 * // => 'hello pebbles'
                 *
                 * // using the internal `print` function in "evaluate" delimiters
                 * _.template('<% print("hello " + name); %>!', { 'name': 'barney' });
                 * // => 'hello barney!'
                 *
                 * // using a custom template delimiters
                 * _.templateSettings = {
                 *   'interpolate': /{{([\s\S]+?)}}/g
                 * };
                 *
                 * _.template('hello {{ name }}!', { 'name': 'mustache' });
                 * // => 'hello mustache!'
                 *
                 * // using the `imports` option to import jQuery
                 * var list = '<% jq.each(people, function(name) { %><li><%- name %></li><% }); %>';
                 * _.template(list, { 'people': ['fred', 'barney'] }, { 'imports': { 'jq': jQuery } });
                 * // => '<li>fred</li><li>barney</li>'
                 *
                 * // using the `sourceURL` option to specify a custom sourceURL for the template
                 * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
                 * compiled(data);
                 * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
                 *
                 * // using the `variable` option to ensure a with-statement isn't used in the compiled template
                 * var compiled = _.template('hi <%= data.name %>!', null, { 'variable': 'data' });
                 * compiled.source;
                 * // => function(data) {
                 *   var __t, __p = '', __e = _.escape;
                 *   __p += 'hi ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
                 *   return __p;
                 * }
                 *
                 * // using the `source` property to inline compiled templates for meaningful
                 * // line numbers in error messages and a stack trace
                 * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
                 *   var JST = {\
                 *     "main": ' + _.template(mainText).source + '\
                 *   };\
                 * ');
                 */
            function template( text, data, options ) {
                    // based on John Resig's `tmpl` implementation
                    // http://ejohn.org/blog/javascript-micro-templating/
                    // and Laura Doktorova's doT.js
                    // https://github.com/olado/doT
                    var settings = lodash.templateSettings;
                    text = String( text || '' );
                    // avoid missing dependencies when `iteratorTemplate` is not defined
                    options = defaults( {}, options, settings );
                    var imports = defaults( {}, options.imports, settings.imports ),
                        importsKeys = keys( imports ),
                        importsValues = values( imports );
                    var isEvaluating,
                        index = 0,
                        interpolate = options.interpolate || reNoMatch,
                        source = "__p += '";
                    // compile the regexp to match each delimiter
                    var reDelimiters = RegExp(
                        ( options.escape || reNoMatch ).source + '|' + interpolate.source + '|' + ( interpolate === reInterpolate ? reEsTemplate : reNoMatch ).source + '|' + ( options.evaluate || reNoMatch ).source + '|$', 'g' );
                    text.replace( reDelimiters, function( match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset ) {
                        interpolateValue || ( interpolateValue = esTemplateValue );
                        // escape characters that cannot be included in string literals
                        source += text.slice( index, offset ).replace( reUnescapedString, escapeStringChar );
                        // replace delimiters with snippets
                        if ( escapeValue ) {
                            source += "' +\n__e(" + escapeValue + ") +\n'";
                        }
                        if ( evaluateValue ) {
                            isEvaluating = true;
                            source += "';\n" + evaluateValue + ";\n__p += '";
                        }
                        if ( interpolateValue ) {
                            source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
                        }
                        index = offset + match.length;
                        // the JS engine embedded in Adobe products requires returning the `match`
                        // string in order to produce the correct `offset` value
                        return match;
                    } );
                    source += "';\n";
                    // if `variable` is not specified, wrap a with-statement around the generated
                    // code to add the data object to the top of the scope chain
                    var variable = options.variable,
                        hasVariable = variable;
                    if ( !hasVariable ) {
                        variable = 'obj';
                        source = 'with (' + variable + ') {\n' + source + '\n}\n';
                    }
                    // cleanup code by stripping empty strings
                    source = ( isEvaluating ? source.replace( reEmptyStringLeading, '' ) : source ).replace( reEmptyStringMiddle, '$1' ).replace( reEmptyStringTrailing, '$1;' );
                    // frame code as the function body
                    source = 'function(' + variable + ') {\n' + ( hasVariable ? '' : variable + ' || (' + variable + ' = {});\n' ) + "var __t, __p = '', __e = _.escape" + ( isEvaluating ? ', __j = Array.prototype.join;\n' + "function print() { __p += __j.call(arguments, '') }\n" : ';\n' ) + source + 'return __p\n}';
                    // Use a sourceURL for easier debugging.
                    // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
                    var sourceURL = '\n/*\n//# sourceURL=' + ( options.sourceURL || '/lodash/template/source[' + ( templateCounter++ ) + ']' ) + '\n*/';
                    try {
                        var result = Function( importsKeys, 'return ' + source + sourceURL ).apply( undefined, importsValues );
                    } catch ( e ) {
                        e.source = source;
                        throw e;
                    }
                    if ( data ) {
                        return result( data );
                    }
                    // provide the compiled function's source by its `toString` method, in
                    // supported environments, or the `source` property as a convenience for
                    // inlining compiled templates during the build process
                    result.source = source;
                    return result;
                }
                /**
                 * Executes the callback `n` times, returning an array of the results
                 * of each callback execution. The callback is bound to `thisArg` and invoked
                 * with one argument; (index).
                 *
                 * @static
                 * @memberOf _
                 * @category Utilities
                 * @param {number} n The number of times to execute the callback.
                 * @param {Function} callback The function called per iteration.
                 * @param {*} [thisArg] The `this` binding of `callback`.
                 * @returns {Array} Returns an array of the results of each `callback` execution.
                 * @example
                 *
                 * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
                 * // => [3, 6, 4]
                 *
                 * _.times(3, function(n) { mage.castSpell(n); });
                 * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
                 *
                 * _.times(3, function(n) { this.cast(n); }, mage);
                 * // => also calls `mage.castSpell(n)` three times
                 */
            function times( n, callback, thisArg ) {
                    n = ( n = +n ) > -1 ? n : 0;
                    var index = -1,
                        result = Array( n );
                    callback = baseCreateCallback( callback, thisArg, 1 );
                    while ( ++index < n ) {
                        result[ index ] = callback( index );
                    }
                    return result;
                }
                /**
                 * The inverse of `_.escape` this method converts the HTML entities
                 * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to their
                 * corresponding characters.
                 *
                 * @static
                 * @memberOf _
                 * @category Utilities
                 * @param {string} string The string to unescape.
                 * @returns {string} Returns the unescaped string.
                 * @example
                 *
                 * _.unescape('Fred, Barney &amp; Pebbles');
                 * // => 'Fred, Barney & Pebbles'
                 */
            function unescape( string ) {
                    return string == null ? '' : String( string ).replace( reEscapedHtml, unescapeHtmlChar );
                }
                /**
                 * Generates a unique ID. If `prefix` is provided the ID will be appended to it.
                 *
                 * @static
                 * @memberOf _
                 * @category Utilities
                 * @param {string} [prefix] The value to prefix the ID with.
                 * @returns {string} Returns the unique ID.
                 * @example
                 *
                 * _.uniqueId('contact_');
                 * // => 'contact_104'
                 *
                 * _.uniqueId();
                 * // => '105'
                 */
            function uniqueId( prefix ) {
                    var id = ++idCounter;
                    return String( prefix == null ? '' : prefix ) + id;
                }
                /*--------------------------------------------------------------------------*/
                /**
                 * Creates a `lodash` object that wraps the given value with explicit
                 * method chaining enabled.
                 *
                 * @static
                 * @memberOf _
                 * @category Chaining
                 * @param {*} value The value to wrap.
                 * @returns {Object} Returns the wrapper object.
                 * @example
                 *
                 * var characters = [
                 *   { 'name': 'barney',  'age': 36 },
                 *   { 'name': 'fred',    'age': 40 },
                 *   { 'name': 'pebbles', 'age': 1 }
                 * ];
                 *
                 * var youngest = _.chain(characters)
                 *     .sortBy('age')
                 *     .map(function(chr) { return chr.name + ' is ' + chr.age; })
                 *     .first()
                 *     .value();
                 * // => 'pebbles is 1'
                 */
            function chain( value ) {
                    value = new lodashWrapper( value );
                    value.__chain__ = true;
                    return value;
                }
                /**
                 * Invokes `interceptor` with the `value` as the first argument and then
                 * returns `value`. The purpose of this method is to "tap into" a method
                 * chain in order to perform operations on intermediate results within
                 * the chain.
                 *
                 * @static
                 * @memberOf _
                 * @category Chaining
                 * @param {*} value The value to provide to `interceptor`.
                 * @param {Function} interceptor The function to invoke.
                 * @returns {*} Returns `value`.
                 * @example
                 *
                 * _([1, 2, 3, 4])
                 *  .tap(function(array) { array.pop(); })
                 *  .reverse()
                 *  .value();
                 * // => [3, 2, 1]
                 */
            function tap( value, interceptor ) {
                    interceptor( value );
                    return value;
                }
                /**
                 * Enables explicit method chaining on the wrapper object.
                 *
                 * @name chain
                 * @memberOf _
                 * @category Chaining
                 * @returns {*} Returns the wrapper object.
                 * @example
                 *
                 * var characters = [
                 *   { 'name': 'barney', 'age': 36 },
                 *   { 'name': 'fred',   'age': 40 }
                 * ];
                 *
                 * // without explicit chaining
                 * _(characters).first();
                 * // => { 'name': 'barney', 'age': 36 }
                 *
                 * // with explicit chaining
                 * _(characters).chain()
                 *   .first()
                 *   .pick('age')
                 *   .value();
                 * // => { 'age': 36 }
                 */
            function wrapperChain() {
                    this.__chain__ = true;
                    return this;
                }
                /**
                 * Produces the `toString` result of the wrapped value.
                 *
                 * @name toString
                 * @memberOf _
                 * @category Chaining
                 * @returns {string} Returns the string result.
                 * @example
                 *
                 * _([1, 2, 3]).toString();
                 * // => '1,2,3'
                 */
            function wrapperToString() {
                    return String( this.__wrapped__ );
                }
                /**
                 * Extracts the wrapped value.
                 *
                 * @name valueOf
                 * @memberOf _
                 * @alias value
                 * @category Chaining
                 * @returns {*} Returns the wrapped value.
                 * @example
                 *
                 * _([1, 2, 3]).valueOf();
                 * // => [1, 2, 3]
                 */
            function wrapperValueOf() {
                    return this.__wrapped__;
                }
                /*--------------------------------------------------------------------------*/
                // add functions that return wrapped values when chaining
            lodash.after = after;
            lodash.assign = assign;
            lodash.at = at;
            lodash.bind = bind;
            lodash.bindAll = bindAll;
            lodash.bindKey = bindKey;
            lodash.chain = chain;
            lodash.compact = compact;
            lodash.compose = compose;
            lodash.constant = constant;
            lodash.countBy = countBy;
            lodash.create = create;
            lodash.createCallback = createCallback;
            lodash.curry = curry;
            lodash.debounce = debounce;
            lodash.defaults = defaults;
            lodash.defer = defer;
            lodash.delay = delay;
            lodash.difference = difference;
            lodash.filter = filter;
            lodash.flatten = flatten;
            lodash.forEach = forEach;
            lodash.forEachRight = forEachRight;
            lodash.forIn = forIn;
            lodash.forInRight = forInRight;
            lodash.forOwn = forOwn;
            lodash.forOwnRight = forOwnRight;
            lodash.functions = functions;
            lodash.groupBy = groupBy;
            lodash.indexBy = indexBy;
            lodash.initial = initial;
            lodash.intersection = intersection;
            lodash.invert = invert;
            lodash.invoke = invoke;
            lodash.keys = keys;
            lodash.map = map;
            lodash.mapValues = mapValues;
            lodash.max = max;
            lodash.memoize = memoize;
            lodash.merge = merge;
            lodash.min = min;
            lodash.omit = omit;
            lodash.once = once;
            lodash.pairs = pairs;
            lodash.partial = partial;
            lodash.partialRight = partialRight;
            lodash.pick = pick;
            lodash.pluck = pluck;
            lodash.property = property;
            lodash.pull = pull;
            lodash.range = range;
            lodash.reject = reject;
            lodash.remove = remove;
            lodash.rest = rest;
            lodash.shuffle = shuffle;
            lodash.sortBy = sortBy;
            lodash.tap = tap;
            lodash.throttle = throttle;
            lodash.times = times;
            lodash.toArray = toArray;
            lodash.transform = transform;
            lodash.union = union;
            lodash.uniq = uniq;
            lodash.values = values;
            lodash.where = where;
            lodash.without = without;
            lodash.wrap = wrap;
            lodash.xor = xor;
            lodash.zip = zip;
            lodash.zipObject = zipObject;
            // add aliases
            lodash.collect = map;
            lodash.drop = rest;
            lodash.each = forEach;
            lodash.eachRight = forEachRight;
            lodash.extend = assign;
            lodash.methods = functions;
            lodash.object = zipObject;
            lodash.select = filter;
            lodash.tail = rest;
            lodash.unique = uniq;
            lodash.unzip = zip;
            // add functions to `lodash.prototype`
            mixin( lodash );
            /*--------------------------------------------------------------------------*/
            // add functions that return unwrapped values when chaining
            lodash.clone = clone;
            lodash.cloneDeep = cloneDeep;
            lodash.contains = contains;
            lodash.escape = escape;
            lodash.every = every;
            lodash.find = find;
            lodash.findIndex = findIndex;
            lodash.findKey = findKey;
            lodash.findLast = findLast;
            lodash.findLastIndex = findLastIndex;
            lodash.findLastKey = findLastKey;
            lodash.has = has;
            lodash.identity = identity;
            lodash.indexOf = indexOf;
            lodash.isArguments = isArguments;
            lodash.isArray = isArray;
            lodash.isBoolean = isBoolean;
            lodash.isDate = isDate;
            lodash.isElement = isElement;
            lodash.isEmpty = isEmpty;
            lodash.isEqual = isEqual;
            lodash.isFinite = isFinite;
            lodash.isFunction = isFunction;
            lodash.isNaN = isNaN;
            lodash.isNull = isNull;
            lodash.isNumber = isNumber;
            lodash.isObject = isObject;
            lodash.isPlainObject = isPlainObject;
            lodash.isRegExp = isRegExp;
            lodash.isString = isString;
            lodash.isUndefined = isUndefined;
            lodash.lastIndexOf = lastIndexOf;
            lodash.mixin = mixin;
            lodash.noConflict = noConflict;
            lodash.noop = noop;
            lodash.now = now;
            lodash.parseInt = parseInt;
            lodash.random = random;
            lodash.reduce = reduce;
            lodash.reduceRight = reduceRight;
            lodash.result = result;
            lodash.runInContext = runInContext;
            lodash.size = size;
            lodash.some = some;
            lodash.sortedIndex = sortedIndex;
            lodash.template = template;
            lodash.unescape = unescape;
            lodash.uniqueId = uniqueId;
            // add aliases
            lodash.all = every;
            lodash.any = some;
            lodash.detect = find;
            lodash.findWhere = find;
            lodash.foldl = reduce;
            lodash.foldr = reduceRight;
            lodash.include = contains;
            lodash.inject = reduce;
            mixin( function() {
                var source = {}
                forOwn( lodash, function( func, methodName ) {
                    if ( !lodash.prototype[ methodName ] ) {
                        source[ methodName ] = func;
                    }
                } );
                return source;
            }(), false );
            /*--------------------------------------------------------------------------*/
            // add functions capable of returning wrapped and unwrapped values when chaining
            lodash.first = first;
            lodash.last = last;
            lodash.sample = sample;
            // add aliases
            lodash.take = first;
            lodash.head = first;
            forOwn( lodash, function( func, methodName ) {
                var callbackable = methodName !== 'sample';
                if ( !lodash.prototype[ methodName ] ) {
                    lodash.prototype[ methodName ] = function( n, guard ) {
                        var chainAll = this.__chain__,
                            result = func( this.__wrapped__, n, guard );
                        return !chainAll && ( n == null || ( guard && !( callbackable && typeof n == 'function' ) ) ) ? result : new lodashWrapper( result, chainAll );
                    };
                }
            } );
            /*--------------------------------------------------------------------------*/
            /**
             * The semantic version number.
             *
             * @static
             * @memberOf _
             * @type string
             */
            lodash.VERSION = '2.4.1';
            // add "Chaining" functions to the wrapper
            lodash.prototype.chain = wrapperChain;
            lodash.prototype.toString = wrapperToString;
            lodash.prototype.value = wrapperValueOf;
            lodash.prototype.valueOf = wrapperValueOf;
            // add `Array` functions that return unwrapped values
            baseEach( [ 'join', 'pop', 'shift' ], function( methodName ) {
                var func = arrayRef[ methodName ];
                lodash.prototype[ methodName ] = function() {
                    var chainAll = this.__chain__,
                        result = func.apply( this.__wrapped__, arguments );
                    return chainAll ? new lodashWrapper( result, chainAll ) : result;
                };
            } );
            // add `Array` functions that return the existing wrapped value
            baseEach( [ 'push', 'reverse', 'sort', 'unshift' ], function( methodName ) {
                var func = arrayRef[ methodName ];
                lodash.prototype[ methodName ] = function() {
                    func.apply( this.__wrapped__, arguments );
                    return this;
                };
            } );
            // add `Array` functions that return new wrapped values
            baseEach( [ 'concat', 'slice', 'splice' ], function( methodName ) {
                var func = arrayRef[ methodName ];
                lodash.prototype[ methodName ] = function() {
                    return new lodashWrapper( func.apply( this.__wrapped__, arguments ), this.__chain__ );
                };
            } );
            // avoid array-like object bugs with `Array#shift` and `Array#splice`
            // in IE < 9, Firefox < 10, Narwhal, and RingoJS
            if ( !support.spliceObjects ) {
                baseEach( [ 'pop', 'shift', 'splice' ], function( methodName ) {
                    var func = arrayRef[ methodName ],
                        isSplice = methodName == 'splice';
                    lodash.prototype[ methodName ] = function() {
                        var chainAll = this.__chain__,
                            value = this.__wrapped__,
                            result = func.apply( value, arguments );
                        if ( value.length === 0 ) {
                            delete value[ 0 ];
                        }
                        return ( chainAll || isSplice ) ? new lodashWrapper( result, chainAll ) : result;
                    };
                } );
            }
            return lodash;
        }
        /*--------------------------------------------------------------------------*/
        // expose Lo-Dash
    var _ = runInContext();
    // some AMD build optimizers like r.js check for condition patterns like the following:
    if ( typeof define == 'function' && typeof define.amd == 'object' && define.amd ) {
        // Expose Lo-Dash to the global object even when an AMD loader is present in
        // case Lo-Dash is loaded with a RequireJS shim config.
        // See http://requirejs.org/docs/api.html#config-shim
        root._ = _;
        // define as an anonymous module so, through path mapping, it can be
        // referenced as the "underscore" module
        define( function() {
            return _;
        } );
    }
    // check for `exports` after `define` in case a build optimizer adds an `exports` object
    else if ( freeExports && freeModule ) {
        // in Node.js or RingoJS
        if ( moduleExports ) {
            ( freeModule.exports = _ )._ = _;
        }
        // in Narwhal or Rhino -require
        else {
            freeExports._ = _;
        }
    } else {
        // in a browser or Rhino
        root._ = _;
    }
}.call( this ) );
 
//####dev/js/tmp/snake3210.js
var Snake3210 = angular.module( 'Snake3210', [ 'ngAnimate', 'ngMaterial', 'ngRoute', 'ngSanitize', 'ngAria' ] );
Snake3210.config( ['$routeProvider', function( $routeProvider ) {
    'use strict';
    $routeProvider.when( '/', {
        templateUrl: './views/play.html',
        controller: 'PlayCtrl'
    } ).when( '/classement', {
        templateUrl: './views/classement.html',
        controller: 'ClassementCtrl'
    } ).when( '/aide', {
        templateUrl: './views/aide.html',
        controller: 'AideCtrl'
    } ).otherwise( {
        redirectTo: '/'
    } );
}] );
 
//####dev/js/controllers/aide.js
/**
 * @ngdoc function
 * @name Snake3210.controller:AideCtrl
 * @description
 * # AideCtrl
 * Controller of the Snake3210
 */
Snake3210.controller( 'AideCtrl', [ '$scope', function( $scope ) {
    'use strict';
} ] );
 
//####dev/js/controllers/classement.js
/**
 * @ngdoc function
 * @name Snake3210.controller:ClassementCtrl
 * @description
 * # ClassementCtrl
 * Controller of the Snake3210
 */
Snake3210.controller( 'ClassementCtrl', [ '$rootScope', '$scope', function( $rootScope, $scope ) {
    'use strict';
    /*
    ##         ## ##      ##       ########    ###    ########  ######## ########  ########   #######     ###    ########  ########
    ##         ## ##      ##       ##         ## ##   ##     ## ##       ##     ## ##     ## ##     ##   ## ##   ##     ## ##     ##
    ##       #########    ##       ##        ##   ##  ##     ## ##       ##     ## ##     ## ##     ##  ##   ##  ##     ## ##     ##
    ##         ## ##      ##       ######   ##     ## ##     ## ######   ########  ########  ##     ## ##     ## ########  ##     ##
    ##       #########    ##       ##       ######### ##     ## ##       ##   ##   ##     ## ##     ## ######### ##   ##   ##     ##
    ##         ## ##      ##       ##       ##     ## ##     ## ##       ##    ##  ##     ## ##     ## ##     ## ##    ##  ##     ##
    ########   ## ##      ######## ######## ##     ## ########  ######## ##     ## ########   #######  ##     ## ##     ## ########
    */
    var LEADERBOARD_SIZE = 20;
    // Create our Firebase reference
    var scoreListRef = new Firebase( 'https://snakeleader.firebaseio.com//scoreList' );
    /*
  var onComplete = function(error) {
  if (error) {
  console.log('Synchronization failed',error);
} else {
console.log('Synchronization succeeded');
}
};
var userScoreRef = scoreListRef.push();
userScoreRef.set({ distance: 'Fred', last: 'Flintstone' }, onComplete);
*/
    // Keep a mapping of firebase locations to HTML elements, so we can move / remove elements as necessary.
    var htmlForPath = {};
    // Create a view to only receive callbacks for the last LEADERBOARD_SIZE scores
    var scoreListView = scoreListRef.limitToFirst( LEADERBOARD_SIZE );
    // Add a callback to handle when a new score is added.
    scoreListView.on( 'child_added', function( newScoreSnapshot, prevScoreName ) {
        handleScoreAdded( newScoreSnapshot, prevScoreName );
    } );
    // Add a callback to handle when a score is removed
    scoreListView.on( 'child_removed', function( oldScoreSnapshot ) {
        handleScoreRemoved( oldScoreSnapshot );
    } );
    // Add a callback to handle when a score changes or moves positions.
    var changedCallback = function( scoreSnapshot, prevScoreName ) {
        handleScoreRemoved( scoreSnapshot );
        handleScoreAdded( scoreSnapshot, prevScoreName );
    };
    scoreListView.on( 'child_moved', changedCallback );
    scoreListView.on( 'child_changed', changedCallback );
    angular.element( ".btn-success" ).on( 'click', function() {
        updatetheScore();
    } );
    // Helper function that takes a new score snapshot and adds an appropriate row to our leaderboard table.
    function handleScoreAdded( scoreSnapshot, prevScoreName ) {
            $rootScope.loading = true;
            var vitesseMoyenne = scoreSnapshot.val().distance / scoreSnapshot.val().timer;
            vitesseMoyenne = Math.round( vitesseMoyenne * 100 ) / 10;
            var newScoreRow = angular.element( "<md-item-content/>" );
            //newScoreRow.append( angular.element( '<div class="md-tile-left"/>' ).append( angular.element( "<em/>" ).html( '<h5>' + scoreSnapshot.val().score + '</h5>' ) ) );
            newScoreRow.append( $( '<div class="md-tile-right"/>' ).append( $( "<em/>" ).html( '<h1>' + scoreSnapshot.val().score + '</h1>' ) ).append( $( '<h3/>' ).text( scoreSnapshot.val().name ) ).append( scoreSnapshot.val().distance + " m | Vitesse moy. : " + vitesseMoyenne + " px/s" ) );
            newScoreRow.append( '<md-divider></md-divider>' );
            $( "<md-item/>" ).append( newScoreRow );
            // Store a reference to the table row so we can get it again later.
            htmlForPath[ scoreSnapshot.key() ] = newScoreRow;
            // Insert the new score in the appropriate place in the table.
            if ( prevScoreName === null ) {
                angular.element( "#leaderboardTable" ).append( newScoreRow );
            } else {
                var lowerScoreRow = htmlForPath[ prevScoreName ];
                lowerScoreRow.before( newScoreRow );
            }
            $rootScope.loading = false;
        }
        // Helper function to handle a score object being removed; just removes the corresponding table row.
    function handleScoreRemoved( scoreSnapshot ) {
        var removedScoreRow = htmlForPath[ scoreSnapshot.key() ];
        removedScoreRow.remove();
        delete htmlForPath[ scoreSnapshot.key() ];
    }
} ] );
 
//####dev/js/controllers/play.js
/**
 * @ngdoc function
 * @name Snake3210.controller:PlayCtrl
 * @description
 * # PlayCtrl
 * Controller of the Snake3210
 */
Snake3210.controller( 'PlayCtrl', [ '$rootScope', '$scope', function( $rootScope, $scope ) {
    'use strict';
    var snakecanvas = document.getElementById( "the-game" );
    var snakecontext = snakecanvas.getContext( "2d" );
    angular.element( '.submitScore' ).prop( 'disabled', true );
    var snakegame = {
        score: 0,
        fps: 8,
        over: false,
        message: null,
        distance: 1,
        timer: 0,
        /*
        ##         ## ##       ######  ########    ###    ########  ########     ######  ########  #######  ########
        ##         ## ##      ##    ##    ##      ## ##   ##     ##    ##       ##    ##    ##    ##     ## ##     ##
        ##       #########    ##          ##     ##   ##  ##     ##    ##       ##          ##    ##     ## ##     ##
        ##         ## ##       ######     ##    ##     ## ########     ##        ######     ##    ##     ## ########
        ##       #########          ##    ##    ######### ##   ##      ##             ##    ##    ##     ## ##
        ##         ## ##      ##    ##    ##    ##     ## ##    ##     ##       ##    ##    ##    ##     ## ##
        ########   ## ##       ######     ##    ##     ## ##     ##    ##        ######     ##     #######  ##
        */
        start: function() {
            snakegame.over = false;
            snakegame.message = null;
            snakegame.score = 0;
            snakegame.fps = 8;
            snakeserpent.init();
            snakefood.set();
            snakegame.distance = 1;
            snakegame.timer = 0;
            $( '.leaderboard-score' ).show();
            $( '.leaderboard-distance' ).show();
            $( '.distancelabel' ).show();
            angular.element( '.submitScore' ).prop( 'disabled', true );
            angular.element( '.alerts' ).html( '' );
        },
        stop: function() {
            snakegame.over = true;
            snakegame.message = 'START';
            angular.element( '.submitScore' ).prop( 'disabled', false );
            $( '.soumettre' ).show();
            var globalRef = new Firebase( 'https://snakeleader.firebaseio.com/snakeGlobal/distanceTotale' );
            globalRef.transaction( function( current ) {
                // If /users/fred/rank has never been set, currentRank will be null.
                //console.log( snakegame.distance );
                return current + ( Math.round( snakegame.distance * 0.02 * snakegame.fps ) );
            } );
        },
        drawBox: function( x, y, size, color ) {
            snakecontext.fillStyle = color;
            snakecontext.beginPath();
            snakecontext.moveTo( x - ( size / 2 ), y - ( size / 2 ) );
            snakecontext.lineTo( x + ( size / 2 ), y - ( size / 2 ) );
            snakecontext.lineTo( x + ( size / 2 ), y + ( size / 2 ) );
            snakecontext.lineTo( x - ( size / 2 ), y + ( size / 2 ) );
            snakecontext.closePath();
            snakecontext.fill();
        },
        drawScore: function() {
            //snakecontext.fillStyle = '#172516';
            //snakecontext.font = ( snakecanvas.height / 10 ) + 'px Arial';
            //snakecontext.textAlign = 'left';
            //snakecontext.fillText( snakegame.score, snakecanvas.width / 2, snakecanvas.height * 0.9 );
            angular.element( '.leaderboard-score' ).val( snakegame.score * 100 );
            angular.element( '.timer' ).val( Math.round( snakegame.timer / 10 ) );
            angular.element( '.vitesse' ).val( Math.round( snakegame.fps ) );
            angular.element( '.leaderboard-distance' ).val( Math.round( snakegame.distance * 0.02 * snakegame.fps ) );
        },
        drawMessage: function() {
            if ( snakegame.message !== null ) {
                snakecontext.fillStyle = '#eee';
                snakecontext.strokeStyle = '#000';
                snakecontext.font = ( snakecanvas.height / 4 ) + 'px VT323';
                snakecontext.textAlign = 'center';
                snakecontext.fillText( snakegame.message, snakecanvas.width / 2, snakecanvas.height / 2 );
                snakecontext.strokeText( snakegame.message, snakecanvas.width / 2, snakecanvas.height / 2 );
            }
        },
        resetCanvas: function() {
            snakecontext.clearRect( 0, 0, snakecanvas.width, snakecanvas.height );
        }
    };
    var snakeserpent = {
        size: snakecanvas.width / 40,
        x: null,
        y: null,
        color: '#e23134',
        direction: 'left',
        sections: [],
        init: function() {
            snakeserpent.sections = [];
            snakeserpent.direction = 'left';
            snakeserpent.x = snakecanvas.width / 2 + snakeserpent.size / 2;
            snakeserpent.y = snakecanvas.height / 2 + snakeserpent.size / 2;
            for ( var i = snakeserpent.x + ( 5 * snakeserpent.size ); i >= snakeserpent.x; i -= snakeserpent.size ) {
                snakeserpent.sections.push( i + ',' + snakeserpent.y );
            }
        },
        move: function() {
            switch ( snakeserpent.direction ) {
                case 'up':
                    snakeserpent.y -= snakeserpent.size;
                    break;
                case 'down':
                    snakeserpent.y += snakeserpent.size;
                    break;
                case 'left':
                    snakeserpent.x -= snakeserpent.size;
                    break;
                case 'right':
                    snakeserpent.x += snakeserpent.size;
                    break;
            }
            snakeserpent.checkCollision();
            snakeserpent.checkGrowth();
            snakeserpent.sections.push( snakeserpent.x + ',' + snakeserpent.y );
        },
        draw: function() {
            for ( var i = 0; i < snakeserpent.sections.length; i++ ) {
                snakeserpent.drawSection( snakeserpent.sections[ i ].split( ',' ) );
            }
        },
        drawSection: function( section ) {
            snakegame.drawBox( parseInt( section[ 0 ] ), parseInt( section[ 1 ] ), snakeserpent.size, snakeserpent.color );
        },
        checkCollision: function() {
            if ( snakeserpent.isCollision( snakeserpent.x, snakeserpent.y ) === true ) {
                snakegame.stop();
            }
        },
        isCollision: function( x, y ) {
            if ( x < snakeserpent.size / 2 || x > snakecanvas.width || y < snakeserpent.size / 2 || y > snakecanvas.height || snakeserpent.sections.indexOf( x + ',' + y ) >= 0 ) {
                return true;
            }
        },
        checkGrowth: function() {
            if ( snakeserpent.x == snakefood.x && snakeserpent.y == snakefood.y ) {
                snakegame.score++;
                if ( snakegame.score % 5 === 0 && snakegame.fps < 60 ) {
                    snakegame.fps++;
                }
                snakefood.set();
                snakefood.set();
                /*
                var globalRef = new Firebase( 'https://snakeleader.firebaseio.com/scoreList/global/distanceTotale' );
                globalRef.transaction( function( current ) {
                // If /users/fred/rank has never been set, currentRank will be null.
                //console.log( snakegame.distance );
                return current + ( Math.round( snakegame.distance * 0.02 * snakegame.fps ) );
              } );*/
            } else {
                snakeserpent.sections.shift();
            }
        }
    };
    var snakefood = {
        size: null,
        x: null,
        y: null,
        color: '#eee',
        set: function() {
            snakefood.size = snakeserpent.size;
            snakefood.x = ( Math.ceil( Math.random() * 10 ) * snakeserpent.size * 4 ) - snakeserpent.size / 2;
            snakefood.y = ( Math.ceil( Math.random() * 10 ) * snakeserpent.size * 3 ) - snakeserpent.size / 2;
        },
        draw: function() {
            snakegame.drawBox( snakefood.x, snakefood.y, snakefood.size, snakefood.color );
        }
    };
    /*
    ##         ## ##       ######   #######  ##    ## ######## ########   #######  ##       ########  ######
    ##         ## ##      ##    ## ##     ## ###   ##    ##    ##     ## ##     ## ##       ##       ##    ##
    ##       #########    ##       ##     ## ####  ##    ##    ##     ## ##     ## ##       ##       ##
    ##         ## ##      ##       ##     ## ## ## ##    ##    ########  ##     ## ##       ######    ######
    ##       #########    ##       ##     ## ##  ####    ##    ##   ##   ##     ## ##       ##             ##
    ##         ## ##      ##    ## ##     ## ##   ###    ##    ##    ##  ##     ## ##       ##       ##    ##
    ########   ## ##       ######   #######  ##    ##    ##    ##     ##  #######  ######## ########  ######
    */
    var inverseDirection = {
        'up': 'down',
        'left': 'right',
        'right': 'left',
        'down': 'up'
    };
    var kbd = [];
    //kbd[13]='start_snakegame';
    //kbd[96]='start_snakegame';
    kbd[ 38 ] = 'up';
    kbd[ 104 ] = 'up';
    kbd[ 39 ] = 'right';
    kbd[ 102 ] = 'right';
    kbd[ 40 ] = 'down';
    kbd[ 98 ] = 'down';
    kbd[ 37 ] = 'left';
    kbd[ 100 ] = 'left';
    addEventListener( "keydown", function( e ) {
        var lastKey = kbd[ e.which ];
        //lastKey = Ctrlkeys.getKey( e.keyCode );
        if ( [ 'up', 'down', 'left', 'right' ].indexOf( lastKey ) >= 0 && lastKey != inverseDirection[ snakeserpent.direction ] ) {
            snakeserpent.direction = lastKey;
        } else if ( [ 'start_snakegame' ].indexOf( lastKey ) >= 0 && snakegame.over ) {
            snakegame.start();
        }
    }, false );
    var requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame;
    /*
    ##         ## ##      ##        #######   #######  ########
    ##         ## ##      ##       ##     ## ##     ## ##     ##
    ##       #########    ##       ##     ## ##     ## ##     ##
    ##         ## ##      ##       ##     ## ##     ## ########
    ##       #########    ##       ##     ## ##     ## ##
    ##         ## ##      ##       ##     ## ##     ## ##
    ########   ## ##      ########  #######   #######  ##
    */
    function snakeloop() {
        if ( snakegame.over === false ) {
            snakegame.resetCanvas();
            snakegame.drawScore();
            snakeserpent.move();
            snakefood.draw();
            snakeserpent.draw();
            snakegame.drawMessage();
            snakegame.distance++;
        }
        setTimeout( function() {
            requestAnimationFrame( snakeloop );
        }, 1000 / snakegame.fps );
        setTimeout( function() {
            snakegame.timer++;
        }, 1000 );
    }
    requestAnimationFrame( snakeloop );
    angular.element( '#the-game' ).on( 'click', function() {
        snakegame.start();
    } );
    /*
    ##         ## ##      ##       ########    ###    ########  ######## ########  ########   #######     ###    ########  ########
    ##         ## ##      ##       ##         ## ##   ##     ## ##       ##     ## ##     ## ##     ##   ## ##   ##     ## ##     ##
    ##       #########    ##       ##        ##   ##  ##     ## ##       ##     ## ##     ## ##     ##  ##   ##  ##     ## ##     ##
    ##         ## ##      ##       ######   ##     ## ##     ## ######   ########  ########  ##     ## ##     ## ########  ##     ##
    ##       #########    ##       ##       ######### ##     ## ##       ##   ##   ##     ## ##     ## ######### ##   ##   ##     ##
    ##         ## ##      ##       ##       ##     ## ##     ## ##       ##    ##  ##     ## ##     ## ##     ## ##    ##  ##     ##
    ########   ## ##      ######## ######## ##     ## ########  ######## ##     ## ########   #######  ##     ## ##     ## ########
    */
    var LEADERBOARD_SIZE = 20;
    // Create our Firebase reference
    var scoreListRef = new Firebase( 'https://snakeleader.firebaseio.com//scoreList' );
    /*
        var onComplete = function(error) {
        if (error) {
        console.log('Synchronization failed',error);
      } else {
      console.log('Synchronization succeeded');
    }
  };
  var userScoreRef = scoreListRef.push();
  userScoreRef.set({ distance: 'Fred', last: 'Flintstone' }, onComplete);
  */
    // Keep a mapping of firebase locations to HTML elements, so we can move / remove elements as necessary.
    var htmlForPath = {};
    // Create a view to only receive callbacks for the last LEADERBOARD_SIZE scores
    var scoreListView = scoreListRef.limitToFirst( LEADERBOARD_SIZE );
    // Add a callback to handle when a new score is added.
    scoreListView.on( 'child_added', function( newScoreSnapshot, prevScoreName ) {
        handleScoreAdded( newScoreSnapshot, prevScoreName );
    } );
    // Add a callback to handle when a score is removed
    scoreListView.on( 'child_removed', function( oldScoreSnapshot ) {
        handleScoreRemoved( oldScoreSnapshot );
    } );
    // Add a callback to handle when a score changes or moves positions.
    var changedCallback = function( scoreSnapshot, prevScoreName ) {
        handleScoreRemoved( scoreSnapshot );
        handleScoreAdded( scoreSnapshot, prevScoreName );
    };
    scoreListView.on( 'child_moved', changedCallback );
    scoreListView.on( 'child_changed', changedCallback );
    angular.element( ".submitScore" ).on( 'click', function() {
        updatetheScore();
    } );
    // Helper function that takes a new score snapshot and adds an appropriate row to our leaderboard table.
    function handleScoreAdded( scoreSnapshot, prevScoreName ) {
            var newScoreRow = angular.element( "<tr/>" );
            newScoreRow.append( angular.element( "<td/>" ).append( angular.element( "<em/>" ).html( '<h4>' + scoreSnapshot.val().name + '</h4>' ) ) );
            newScoreRow.append( angular.element( "<td/>" ).text( scoreSnapshot.val().distance + " m" ) );
            var vitesseMoyenne = scoreSnapshot.val().distance / scoreSnapshot.val().timer;
            vitesseMoyenne = Math.round( vitesseMoyenne * 100 ) / 10;
            newScoreRow.append( angular.element( "<td/>" ).text( vitesseMoyenne + " px/s" ) );
            newScoreRow.append( angular.element( "<td/>" ).html( '<h4>' + scoreSnapshot.val().score + '</h4>' ) );
            // Store a reference to the table row so we can get it again later.
            htmlForPath[ scoreSnapshot.key() ] = newScoreRow;
            // Insert the new score in the appropriate place in the table.
            if ( prevScoreName === null ) {
                angular.element( "#leaderboardTable" ).append( newScoreRow );
            } else {
                var lowerScoreRow = htmlForPath[ prevScoreName ];
                lowerScoreRow.before( newScoreRow );
            }
        }
        // Helper function to handle a score object being removed; just removes the corresponding table row.
    function handleScoreRemoved( scoreSnapshot ) {
        var removedScoreRow = htmlForPath[ scoreSnapshot.key() ];
        removedScoreRow.remove();
        delete htmlForPath[ scoreSnapshot.key() ];
    }

    function updatetheScore() {
        var newScore = Number( angular.element( "#scoreInput" ).val() );
        var newDistance = Number( angular.element( "#distanceInput" ).val() );
        var newTimer = Number( angular.element( "#timerInput" ).val() );
        var name = angular.element( "#nameInput" ).val();
        if ( name.length === 0 ) return;
        if ( newScore === 0 ) return;
        angular.element( "#scoreInput" ).val( 0 );
        angular.element( "#distanceInput" ).val( 0 );
        angular.element( "#timerInput" ).val( 0 );
        angular.element( "#vitesseInput" ).val( 0 );
        angular.element( ".submitScore" ).prop( 'disabled', true );
        $( '.leaderboard-score' ).hide();
        $( '.leaderboard-distance' ).hide();
        $( '.text-info' ).hide();
        //if(newScore>snapshot.val().score) {
        var userScoreRef = scoreListRef.push();
        // Use setWithPriority to put the name / score in Firebase, and set the priority to be the score.
        userScoreRef.setWithPriority( {
            name: name,
            score: newScore,
            distance: newDistance,
            timer: newTimer,
            timestamp: Firebase.ServerValue.TIMESTAMP
        }, newScore );
    }
} ] );
